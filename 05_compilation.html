<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Этапы компиляции - C++ course notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li class="chapter-item expanded "><a href="05_compilation.html" class="active"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li class="chapter-item expanded "><a href="07_inheritance.html"><strong aria-hidden="true">8.</strong> Наследование (в т.ч. виртуальное), виртуальные функции</a></li><li class="chapter-item expanded "><a href="08_exceptions.html"><strong aria-hidden="true">9.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li class="chapter-item expanded "><a href="09_allocations_optimizations.html"><strong aria-hidden="true">10.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации</a></li><li class="chapter-item expanded "><a href="10_libraries.html"><strong aria-hidden="true">11.</strong> Статические и динамические библиотеки</a></li><li class="chapter-item expanded "><a href="11_undefined_behaviour.html"><strong aria-hidden="true">12.</strong> Undefined behaviour: примеры и способы его понимать</a></li><li class="chapter-item expanded "><a href="12_validation.html"><strong aria-hidden="true">13.</strong> Способы валидации программы</a></li><li class="chapter-item expanded "><a href="13_tools.html"><strong aria-hidden="true">14.</strong> Полезные инструменты, которые пригодятся вам в жизни</a></li><li class="chapter-item expanded "><a href="14_templates.html"><strong aria-hidden="true">15.</strong> Шаблоны (templates)</a></li><li class="chapter-item expanded "><a href="15_stl.html"><strong aria-hidden="true">16.</strong> Обзор STL, tag-dispatching, SFINAE</a></li><li class="chapter-item expanded "><a href="16_namespaces_using_adl.html"><strong aria-hidden="true">17.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li class="chapter-item expanded "><a href="17_move_rvalue.html"><strong aria-hidden="true">18.</strong> Move-семантика, rvalue-ссылки</a></li><li class="chapter-item expanded "><a href="18_intrusive_containers.html"><strong aria-hidden="true">19.</strong> Интрузивные контейнеры</a></li><li class="chapter-item expanded "><a href="19_smart_pointers.html"><strong aria-hidden="true">20.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li class="chapter-item expanded "><a href="20_perfect_forwarding.html"><strong aria-hidden="true">21.</strong> Perfect forwarding, variadic templates</a></li><li class="chapter-item expanded "><a href="21_decltype_auto_nullptr.html"><strong aria-hidden="true">22.</strong> Decltype, declval, auto, nullptr</a></li><li class="chapter-item expanded "><a href="22_lambdas_type_erasure.html"><strong aria-hidden="true">23.</strong> Анонимные функции, type erasure, std::function</a></li><li class="chapter-item expanded "><a href="23_signals_reetrancy_errors.html"><strong aria-hidden="true">24.</strong> Сигналы, reetrancy, обработки ошибок</a></li><li class="chapter-item expanded "><a href="24_optional_variant_tuple_stringview.html"><strong aria-hidden="true">25.</strong> Optional, variant, tuple, string_view</a></li><li class="chapter-item expanded "><a href="25_constexpr.html"><strong aria-hidden="true">26.</strong> Статическая и динамическая инициализация, constexpr</a></li><li class="chapter-item expanded "><a href="26_multithreading.html"><strong aria-hidden="true">27.</strong> Многопоточность</a></li><li class="chapter-item expanded "><a href="27_qt.html"><strong aria-hidden="true">28.</strong> Qt</a></li><li class="chapter-item expanded "><a href="28_concepts.html"><strong aria-hidden="true">29.</strong> Концепты</a></li><li class="chapter-item expanded "><a href="29_ranges.html"><strong aria-hidden="true">30.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="30_encoding.html"><strong aria-hidden="true">31.</strong> Кодировки</a></li><li class="chapter-item expanded "><a href="31_coroutines.html"><strong aria-hidden="true">32.</strong> Корутины</a></li><li class="chapter-item expanded "><a href="32_modules.html"><strong aria-hidden="true">33.</strong> Модули</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">C++ course notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/cpp-kt/cpp-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Процесс-компиляции-программ" id="Процесс-компиляции-программ">Процесс компиляции программ</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=Fm-EmbQVrLE">Запись лекции №1</a></li>
<li><a href="https://www.youtube.com/watch?v=w0G66pR3JuY">Запись лекции №2</a></li>
<li><a href="https://www.youtube.com/watch?v=gsFYkmckcZs">Запись лекции №3</a></li>
<li><a href="https://www.youtube.com/watch?v=jZAWVxcHLKA">Практика</a></li>
</ul>
<hr />
<p>Зачем нам нужно это изучать? </p>
<ul>
<li>У студентов часто возникают с этим проблемы — когда компилятор пишет ошибку, а человек не понимает, что ему говорят.</li>
<li>Если вы делаете ошибку в организации программы, причём такую ошибку, которая сразу к проблеме не приводит, то бывает такое, что при компиляции чуть-чуть по-другому всё сломается. Причём даже в крупных компаниях
такое случается.</li>
</ul>
<p>Самое интересное, что ни в одной литературе про компиляцию не рассказывается (в совсем базовой считается что это сложно, а в продвинутой — что вы всё знаете), а все кто это знает,
говорят, что пришло с опытом.</p>
<h2><a class="header" href="#Базовые-знания-об-этапах-компиляции" id="Базовые-знания-об-этапах-компиляции">Базовые знания об этапах компиляции.</a></h2>
<p>Обычно мы компилируем программу как <em>g++ program.cpp</em>. А вот чего мы пока не знаем, так это того, что <em>g++</em> не делает всю работу самостоятельно, а вызывает другие команды, которые выполняют компиляцию по частям. И если посмотреть, что там, то происходит <em>cc1plus</em>, потом <em>as</em>, в конце <em>collect2</em>, который вызывает <em>ld</em>. Давайте попытаемся это повторить. </p>
<p>Дальше будет перечисление стадий с указанием двух моментов: как их можно выполнить руками и какое расширение обычно имеет результат этой стадии.</p>
<ol>
<li><em>Препроцессирование</em>. Выполняется при помощи <em>g++ -E</em> (если дополнительно передать ключ <em>-P</em>, то вывод будет чуть короче), выходной файл обычно имеет расширение <em>.i</em>. На файл с расширением <em>.i</em> можно и глазами посмотреть — в нём будет куча текста вместо <code>#include</code>, а потом наш код. Собственно, <strong><code>#include</code> — директива препроцессора, которая тупо вставляет указанный файл в то место, где написана</strong>. Также препроцессор занимается макросами (<code>#define</code>). О них позже.</li>
<li><em>Трансляция</em>. Выполняется при помощи <em>g++ -S</em>, выходной файл обычно имеет расширение <em>.s</em>. «Трансляция» — это (с английского) «перевод». Кого и куда переводим? Наш язык в ассемблер. Если передать параметр <em>-masm=intel</em>, можно уточнить, в какой именно ассемблер переводить (как было сказано в <a href="./01_asm.html#%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80">01_asm</a>, ассемблеры отличаются в зависимости от инструмента).</li>
<li><em>Ассемблирование</em>. Выполняется специальной утилитой <em>as</em>, выходной файл обычно имеет расширение <em>.o</em> (и называется <em>объектным файлом</em>). На данном этапе не происходит ничего интересного — просто инструкции, которые были в ассемблере, перегоняются в машинный код. Поэтому файлы <em>.o</em> бесполезно смотреть глазами, они бинарные, для этого есть специальные утилиты, например, <em>objdump</em>. Про него будет рассказано чуть позже.</li>
<li><em>Линковка</em>. Выполняется простым вызовом <em>g++</em> от объектного файла. На выходе даёт исполняемый файл. Нужна, если файлов несколько: мы запускаем препроцессор, трансляцию и ассемблирование независимо для каждого файла, а объединяются они только на этапе линковки. Независимые <em>.cpp</em> файлы называют <em>единицами трансляции</em>. Разумеется, <strong>только в одной единице должен быть <code>main</code></strong>. В этом <code>main</code>'е, кстати, можно не делать <code>return 0</code>, его туда вставит компилятор.<br />
Сто́ит сказать, что информация о линковке верна до появления модулей в C++20, где можно доставать данные одного файла для другого. Там появляется зависимость файлов друг от друга, а значит компилировать их надо в определённом порядке. </li>
</ol>
<p>Классическая схема этапов компиляции выглядит так:</p>
<p><img src="./images/03.28_compilation_graph.png" alt="Compilation graph" /></p>
<p>Есть похожая <a href="https://habr.com/ru/post/478124/">статья на хабре</a> по теме.</p>
<h2><a class="header" href="#Объявление-и-определение" id="Объявление-и-определение">Объявление и определение.</a></h2>
<p>Очень хочется слинковать вот это:</p>
<pre><code class="language-c++">// a.cpp:
int main() {
	f();
}
</code></pre>
<pre><code class="language-c++">// b.cpp:
#include &lt;cstdio&gt;

void f() {
	printf(&quot;Hello, world!\n&quot;);
}
</code></pre>
<p>Это не компилируется, а точнее ошибка происходит на этапе трансляции <em>a.cpp</em>. В тексте ошибки написано, что <code>f</code> не определена в области видимости. Всё потому, что для того <strong>чтобы вызвать функцию, надо что-то про неё знать</strong>. Например, если мы передаём в функцию <code>int</code> — это один ассемблерный код, а если <code>double</code> — то совершенно другой (потому что разные calling convention'ы могут быть). Поэтому на этапе трансляции нужно знать сигнатуру функции. Чтобы указать эту сигнатуру, в C++ есть <em>объявления</em>:</p>
<pre><code class="language-c++">// a.cpp:			
void f(); // Вот это объявление.

int main() {
	f();
}
</code></pre>
<pre><code class="language-c++">// b.cpp:
#include &lt;cstdio&gt;

void f() {
	printf(&quot;Hello world&quot;);
}
</code></pre>
<p>Когда мы пишем функцию и точку с запятой — это <em>объявление</em>/<em>декларация</em> (<em>declaration</em>). Это значит, что где-то в программе такая функция есть. А когда мы пишем тело функции в фигурных скобках — это <em>определение</em> (<em>definition</em>).</p>
<p>Кстати, <strong>написать объявление бывает полезно даже если у нас один файл</strong>. Например, в таком файле:</p>
<pre><code class="language-c++">#include &lt;cstdio&gt;

int main() {
	f();
}

void f() {
	printf(&quot;Hello, world\n&quot;);
}
</code></pre>
<p>Это не компилируется, и дело в том, что компилятор смотрит файл сверху вниз, и когда доходит до вызова функции <code>f</code> внутри <code>main</code>, он ещё не дошёл до её определения. Тут можно переставить функции местами, да, но если у нас есть взаиморекурсивные функции, то там переставить их не получится — только написать декларацию.</p>
<!--
- Функцию нужно объявлять до её вызова.
Это есть в последнем пункте.
-->
<!--
- Если в обеих программах есть main, то невозможно будет слинковать (какой main запускать?)
- В main можно не делать `return`, по умолчанию вернёт 0.
Это я переместил повыше.
-->
<!--
- Можно писать функцию на ассемблере и вызывать из `*.cpp` файла, потому что на этапе линковки нет разницы.
Про это есть ниже.
-->
<!--
- Во всех единицах трансляции только одно определение.
Об этом чуть ниже.
-->
<!--
- Функцию нужно объявлять до её использования. Если она описана ниже, то транслятор не увидит её и кинет ошибку.
На это пример выше.
-->
<h2><a class="header" href="#Ошибки-линковки-Инструменты-nm-и-objdump-Ключевое-слово-static" id="Ошибки-линковки-Инструменты-nm-и-objdump-Ключевое-слово-static">Ошибки линковки. Инструменты <em>nm</em> и <em>objdump</em>. Ключевое слово <code>static</code>.</a></h2>
<p>Рассмотрим такой пример:</p>
<pre><code class="language-c++">// a.cpp
#include &lt;cstdio&gt;

void f()
{
	printf(&quot;Hello, a.cpp!\n&quot;);
}
</code></pre>
<pre><code class="language-c++">// b.cpp
#include &lt;cstdio&gt;

void f()
{
	printf(&quot;Hello, b.cpp!\n&quot;);
}
</code></pre>
<pre><code class="language-c++">// main.cpp
void f();

int main()
{
	f();
}
</code></pre>
<p>Тут вам на этапе линковки напишут, что функция <code>f()</code> определяется дважды. Чтобы красиво посмотреть, как это работает, можно использовать утилиту <em>nm</em>. Когда вы сгенерируете <em>a.o</em> и вызовете <em>nm -C a.o</em>, то увидите что-то такое:</p>
<pre><code>                 U puts
0000000000000000 T f()
</code></pre>
<p>Что делает ключ <em>-C</em>, <a href="./05_compilation.html#%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BC%D1%91%D0%BD-extern-c">оставим на потом</a>. На то что тут находится <code>puts</code> вместо <code>printf</code>, тоже обращать внимание не надо, это просто такая оптимизация компилятора — когда можно заменить <code>printf</code> на <code>puts</code>, заменяем.<br />
А обратить внимание надо на то, что <code>puts</code> не определена (об этом нам говорит буква <em>U</em>), а функция <code>f()</code> — определена в секции <em>.text</em> (буква <em>T</em>). У <em>main.cpp</em>, понятно, будет неопределённая функция <code>f()</code> и определённая <code>main</code>. Поэтому, имея эти объектные файлы, можно слинковать <em>main.cpp</em> и <em>a.cpp</em>, а можно — <em>main.cpp</em> и <em>b.cpp</em>. Без перекомпиляции. Но нельзя все три вместе, ведь <code>f()</code> будет определена дважды.</p>
<p>Если мы хотим посмотреть на объектные файлы поподробнее, нам понадобится утилита <em>objdump</em>. У неё есть бесчисленное много ключей, которые говорят, что мы хотим увидеть. Например <em>-x</em> — выдать вообще всё. Нам сейчас нужно <em>-d</em> — дизассемблирование и <em>-r</em> — релокации. Когда мы вызовем <em>objdump -dr -Mintel -C main.o</em>, мы увидим, что на месте вызова функции <code>f</code> находится <code>call</code> и нули. Потому что неизвестно, где эта функция, надо на этапе линковки подставить её адрес. А чтобы узнать, что именно подставить, есть <em>релокации</em>, которые информацию об этом и содержат. В общем случае <strong><em>релокация</em> — информация о том, какие изменения нужно сделать с программой, чтобы файл можно было запустить</strong>.</p>
<p>Давайте теперь вот на что посмотрим. Пусть в нашем файле определена функция <code>f()</code>. И где-то по случайному совпадению далеко-далеко также определена функция <code>f()</code>. Понятно, что оно так не слинкуется. Но мы можем иметь ввиду, что наша функция <code>f</code> нужна только нам и никак наружу не торчит. Для этого имеется специальный модификатор: <code>static</code>. Если сделать на такие функции <em>nm</em>, то можно увидеть символ <em>t</em> вместо <em>T</em>, который как раз обозначает локальность для единицы трансляции. Вообще <strong>функции, локальные для одного файла сто́ит помечать как <code>static</code> в любом случае, потому что это ещё помогает компилятору сделать оптимизации</strong>.</p>
<h2><a class="header" href="#Глобальные-переменные" id="Глобальные-переменные">Глобальные переменные.</a></h2>
<p>Для глобальных переменных всё то же самое, что и для функций: например, мы также можем сослаться на глобальную переменную из другого файла. Только тут другой синтаксис:</p>
<pre><code class="language-c++">extern int x; // Объявление.

int x;        // Определение.
</code></pre>
<p>И точно также в глобальных переменных можно писать <code>static</code>. А теперь пример:</p>
<pre><code class="language-c++">// a.cpp
extern int a;

void f();

int main()
{
	f();
	a = 5;
	f();
}
</code></pre>
<pre><code class="language-c++">// b.cpp
#include &lt;cstdio&gt;

int a;

void f()
{
	printf(&quot;%d\n&quot;, a);
}
</code></pre>
<p>В первый раз вам выведут <em>0</em>, потому что <strong>глобальные переменные инициализируются нулями</strong>. Локальные переменные хранятся на стеке, и там какие данные были до захода в функцию, те там и будут. А глобальные выделяются один раз, и ОС даёт вам их проинициализированные нулём (иначе там могут быть чужие данные, их нельзя отдавать).</p>
<h2><a class="header" href="#Декорирование-имён-extern-c" id="Декорирование-имён-extern-c">Декорирование имён. <code>extern &quot;C&quot;</code>.</a></h2>
<p>Обсуждённая нами модель компиляции позволяет использовать несколько разных языков программирования. <strong>Пока ЯП умеет транслироваться в объектные файлы, проблемы могут возникнуть только на этапе линковки.</strong> Например, никто не мешает вам взять уже готовый ассемблерник и скомпилировать его с <em>.cpp</em> файлом. Но в вызове ассемблера есть одна проблема. Тут надо поговорить о такой вещи как <code>extern &quot;C&quot;</code>. В языке C всё было так: имя функции и имя символа для линковщика — это одно и то же. Если мы скомпилируем файл</p>
<pre><code class="language-c">// a.c &lt;-- C, не C++.
void foo(int)
{
	// ...
}
</code></pre>
<p>То имя символа, которое мы увидим в <em>nm</em> будет <em>foo</em>. А в C++ появилась перегрузка функций, то есть <code>void foo(int)</code> и <code>void foo(double)</code> — это две разные функции, обе из которых можно вызывать. Поэтому одно имя символа присвоить им нельзя. Так что <strong>компилятор mangle'ит/декорирует имена, то есть изменяет их так, чтобы символы получились уникальными</strong>. <em>nm</em> даже может выдать вам эти имена (в данном случае получится <em>_Z3fooi</em> и <em>_Z3food</em>). Но у вас есть и возможность увидеть их по-человечески: для этого существует уже упомянутый ключ <em>-C</em>, который если передать программе <em>nm</em>, то она раздекорирует всё обратно и выдаст вам имена человекочитаемо. <em>objdump</em>'у этот ключ дать тоже можно. А ещё есть утилита
<em>c++filt</em>, которая по имени символа даёт сигнатуру функции.</p>
<p>Так вот, <strong><code>extern &quot;C&quot;</code> говорит, что при линковке нам не нужно проводить декорацию</strong>. И если у нас в ассемблерном файле написано <code>fibonacci:</code>, то вам и нужно оставить имя символа как есть:</p>
<pre><code class="language-c++">extern &quot;C&quot; uint32_t fibonacci(uint32_t n);
</code></pre>
<p>У функций с разными сигнатурами, но помеченных как <code>extern &quot;C&quot;</code>, после компиляции не будет информации об типах их аргументов, поэтому это слинкуется, но работать не будет (ну либо будет, но тут UB, так как, например, типы аргументов ожидаются разные).</p>
<h2><a class="header" href="#Линковка-со-стандартной-библиотекой" id="Линковка-со-стандартной-библиотекой">Линковка со стандартной библиотекой.</a></h2>
<p>Возьмём теперь объявление <code>printf</code> из <code>cstdio</code> и вставим его объявление вручную:</p>
<pre><code class="language-c++">extern &quot;C&quot; int printf(const char*, ...);

int main() {
	printf(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Такая программа тоже работает. А где определение <code>printf</code>, возникает вопрос? А вот смотрите. На этапе связывания
связываются не только ваши файлы. Помимо этого <strong>в параметры связывания добавляются несколько ещё объектных файлов и несколько библиотек</strong>. В нашей модели мира хватит информации о том, что библиотека — просто набор объектных файлов. И вот при линковке вам дают библиотеку стандартную библиотеку C++ (<em>-lstdc++</em>), математическую библиотеку (<em>-lm</em>), библиотеку <em>-libgcc</em>, чтобы если вы делаете арифметику в 128-битных числах, то компилятор мог вызвать функцию <code>__udivti3</code> (деление), и кучу всего ещё. В нашем случае нужна одна — <em>-lc</em>, в которой и лежит <code>printf</code>. А ещё один из объектных файлов, с которыми вы линкуетесь, содержит функцию <code>_start</code> (это может быть файл <code>crt1.o</code>), которая вызывает <code>main</code>.</p>
<h2><a class="header" href="#headers-заголовочные-файлы-Директива-include" id="headers-заголовочные-файлы-Директива-include">Headers (заголовочные файлы). Директива <code>#include</code>.</a></h2>
<!--
`2.h` - файлы не участвующие в компиляции, в них пишут объявления функций. Не нужно делать  `#include file.cpp`, а в `.h` не нужно определять функции.

Какая-то сомнительная подводка, честно говоря.
Мне подводка из 2021–22 нравится больше.
-->
<p>Если мы используем одну функцию во многих файлах, то нам надо писать её сигнатуру везде. А если мы её меняем, то вообще повеситься можно. Поэтому так не делают. А как делают? А так: <strong>декларация выделяется в отдельный файл</strong>. Это файл имеет расширение <em>.h</em> и называется <em>заголовочным</em>. По сути это же происходит в стандартной библиотеке. Подключаются заголовочные файлы директивой <code>#include &lt;filename&gt;</code>, если они из какой-то библиотеки, или <code>#include &quot;filename&quot;</code>, если он ваш. В чём разница? Стандартное объяснение — тем, что треугольные скобки сначала ищут в библиотеках, а потом в вашей программе, а кавычки — наоборот. На самом желе у обоих вариантов просто есть список путей, где искать файл, и эти списки разные.</p>
<p>Но с заголовками нужно правильно работать. Например, <strong>нельзя делать <code>#include &quot;a.cpp&quot;</code></strong>. Почему? Потому что все определённые в <code>a.cpp</code> функции и переменные просочатся туда, куда вы его подключили. И если файл у вас один, то ещё ничего, а если больше, то в каждом, где написано <code>#include &quot;a.cpp&quot;</code>, будет определение, а значит определение одного и того же объекта будет написано несколько раз.
Аналогичной эффект будет, если <strong>писать определение сразу в заголовочном файле, не надо так</strong>.</p>
<p>К сожалению, у директивы <code>#include</code> есть несколько нюансов.</p>
<h3><a class="header" href="#Предотвращение-повторного-включения" id="Предотвращение-повторного-включения">Предотвращение повторного включения.</a></h3>
<p>Давайте поговорим про структуры. Что будет, если мы в заголовочном файле создадим <code>struct</code>, и подключим этот файл? Да ничего. Абсолютно ничего. Сгенерированный ассемблерный код будет одинаковым. <strong>У структур нет определения по сути, потому что они не генерируют код</strong>. Поэтому их пишут в заголовках. При этом их методы можно (но не нужно) определять там же, потому что они воспринимаются компилятором как <code>inline</code>. А кто такой этот <code>inline</code> и как он работает — смотри дальше. Но со структурами есть один нюанс. Рассмотрим вот что:</p>
<pre><code class="language-c++">// x.h:
struct x {};
</code></pre>
<pre><code class="language-c++">// y.h:
#include &quot;x.h&quot;
</code></pre>
<pre><code class="language-c++">// z.h:
#include &quot;x.h&quot;
</code></pre>
<pre><code class="language-c++">// a.cpp:
#include &quot;y.h&quot; //    --&gt;    `struct x{};`.
#include &quot;z.h&quot; //    --&gt;    `struct x{};` ошибка компиляции, повторное определение.
</code></pre>
<p>Стандартный способ это поправить выглядит так:</p>
<pre><code class="language-c++">// x.h:
#ifndef X_H // Если мы уже определили макрос, то заголовок целиком игнорируется.
#define X_H	// Если не игнорируется, то помечаем, что файл мы подключили.

struct x {};

#endif // В блок #ifndef...#endif заключается весь файл целиком.
</code></pre>
<p>Это называется <em>include guard</em>. Ещё все возможные компиляторы поддерживают <code>#pragma once</code> (эффект как у <em>include guard</em>, но проще). И на самом деле <code>#pragma once</code> работает лучше, потому что не опирается на имя файла, например. Но его нет в стандарте, что грустно.</p>
<p>Есть один нюанс с <code>#pragma once</code>'ом. Если у вас есть две жёстких ссылки на один файл, то у него проблемы. Если у вас include guard, то интуитивно понятно, что такое разные файлы — когда макросы у них разные. А вот считать ли разными файлами две жёстких ссылки на одно и то же — вопрос сложный. Другое дело, что делать так, чтобы источники содержали жёсткие
или символические ссылки, уже довольно странно.</p>
<h3><a class="header" href="#forward-декларации" id="forward-декларации">Forward-декларации.</a></h3>
<pre><code class="language-c++">// a.h
#ifndef A_H
#define A_H

#include &quot;b.h&quot; // Nothing, then `struct b { ... };`

struct a {
	b* bb;
};
#endif
</code></pre>
<pre><code class="language-c++">// b.h
#ifndef B_H
#define B_H

#include &quot;a.h&quot; // Nothing, then `struct a { ... };`

struct b {
	a* aa;
};
#endif
</code></pre>
<pre><code class="language-c++">// main.cpp
#include &quot;a.h&quot; // `struct b { ... }; struct a { ... };`
#include &quot;b.h&quot; // Nothing.
</code></pre>
<p>Понятно, в чём проблема заключается. Мы подключаем <em>a.h</em>, в нём — <em>b.h</em>, в нём, поскольку мы уже зашли в <em>a.h</em>, include guard нам его блокирует. И мы сначала определяем структуру <code>b</code>, а потом — <code>a</code>. И при просмотре структуры <code>b</code>, мы не будем знать, что такое <code>a</code>.</p>
<p>Для этого есть конструкция, называемая <em>forward-декларацией</em>. Она выглядит так:</p>
<pre><code class="language-c++">// a.h
#ifndef A_H
#define A_H

struct b;

struct a {
	b* bb;
};
#endif
</code></pre>
<pre><code class="language-c++">// b.h
#ifndef B_H
#define B_H

struct a;

struct b {
	a* aa;
};
#endif
</code></pre>
<p><strong>Чтобы завести указатель, нам не надо знать содержимое структуры.</strong> Поэтому мы просто говорим, что <code>b</code> — это некоторая структура, которую мы дальше определим.</p>
<p>Вообще <strong>forward-декларацию в любом случае лучше использовать вместо подключения заголовочных файлов</strong> (если возможно, конечно). Почему?</p>
<ul>
<li>Во-первых, из-за времени компиляции. Большое количество подключений в заголовочных файлах негативно влияет на него, потому что если меняется <em>header</em>, то необходимо перекомпилировать все файлы, которые подключают его (даже не непосредственно), что может быть долго.</li>
<li>Второй момент — когда у нас <strong>цикл из заголовочных файлов, это всегда ошибка</strong>, даже если там нет проблем как в примере, потому что результат компиляции зависит от того, что вы подключаете первым.</li>
</ul>
<!--
```c++
#define PI 3.14 
// препроцессор подставляет вместо PI 3.14
```
Макросы обычно пишут капсом

Это тут при чём вообще? Мы, вроде, заголовки обсуждали. Про макросы я лучше напишу сам и пониже.
-->
<p>Пока структуру не определили, структура — это <em>incomplete type</em>. Например, на момент объявление <code>struct b;</code> в коде выше, <code>b</code> — incomplete. Кстати, в тот момент, когда вы находитесь в середине определения класса, он всё ещё incomplete.
Все, что можно с incomplete типами делать — это объявлять функции с их использованием и создавать указатель. Становятся полным типом после определения.
Пока что информация об incomplete-типах нам ни к чему, но <a href="./14_templates.html#incomplete-type">она выстрелит позже</a>.</p>
<h2><a class="header" href="#Правило-единственного-определения" id="Правило-единственного-определения">Правило единственного определения.</a></h2>
<p>А теперь такой пример:</p>
<pre><code class="language-c++">// a.cpp
#include &lt;iostream&gt;

struct x {
	int a;
	// padding
	double b;
	int c;
	int d;
};

x f();

int main() {
	x xx = f();
	std::cout &lt;&lt; xx.a &lt;&lt; &quot; &quot;
	          &lt;&lt; xx.b &lt;&lt; &quot; &quot;
	          &lt;&lt; xx.c &lt;&lt; &quot; &quot;
	          &lt;&lt; xx.d &lt;&lt; std::endl;
}
</code></pre>
<pre><code class="language-c++">// b.cpp
struct x {
	int a;
	int b;
	int c;
	int d;
	int e;
};

x f() {
	x result;
	result.a = 1;
	result.b = 2;
	result.c = 3;
	result.d = 4;
	result.e = 5;
	return result;
};
</code></pre>
<p>Тут стоит вспомнить, что <strong>структуры при линковке не играют никакой роли</strong>, то есть линковщику всё равно, что у нас структура <code>x</code> определена в двух местах. Поэтому такая программа отлично скомпилируется и запустится, но тем не менее она является некорректной. По стандарту такая программа будет работать неизвестно как, а по жизни данные поедут. А именно <code>2</code> пропадёт из-за выравнивания <code>double</code>, <code>3</code> и <code>4</code> превратятся в одно число (<code>double</code>), а <code>5</code> будет на своём месте, а <code>x::e</code> из файла <em>a.cpp</em> будет просто не проинициализирован. Правило, согласно которому так нельзя, называется <em>one-definition rule</em>/<em>правило единственного определения</em>. Кстати, нарушением ODR является даже тасовка полей.</p>
<h2><a class="header" href="#inlining" id="inlining">Inlining.</a></h2>
<pre><code class="language-c++">int foo(int a, int b) {
	return a + b;
}

int bar(int a, int b) {
	return foo(a, b) - a;
}
</code></pre>
<p>Если посмотреть на ассемблерный код для <code>bar</code>, то там не будет вызова функции <code>foo</code>, а будет <code>return b;</code>. Это называется <em>inlining</em> — когда мы берём тело одной функции и вставляем внутрь другой как оно есть. Это связано, например, со стилем программирования в текущем мире (много маленьких функций, которые делают маленькие вещи) — мы убираем все эти абстракции, сливаем функции в одну и потом оптимизируем что там есть.</p>
<p>Но есть один нюанс...</p>
<h3><a class="header" href="#Модификатор-inline" id="Модификатор-inline">Модификатор <code>inline</code>.</a></h3>
<pre><code class="language-c++">// a.c
void say_hello();

int main() {
	say_hello();
}
</code></pre>
<pre><code class="language-c++">// b.c
#include &lt;cstdio&gt;

void say_hello() {
	printf(&quot;Hello, world!\n&quot;);
}
</code></pre>
<p>Тут не произойдёт inlining, а почему? А потому что <strong>компилятор умеет подставлять тело функций только внутри одной единицы трансляции</strong> (так как inlining происходит на момент трансляции, а тогда у компилятора нет функций из других единиц).</p>
<p>Тут умеренно умалчивается, что модель компиляции, которую мы обсуждаем — древняя и бородатая. Мы можем передать ключ <em>-flto</em> в компилятор, тогда всё будет за'inline'ено. Дело в том, что <strong>при включенном режиме linking time optimization, мы откладываем на потом генерацию кода и генерируем его на этапе линковки</strong>. В таком случае линковка может занимать много времени, поэтому применяется при сборке с оптимизациями. Подробнее о режиме LTO — сильно позже.</p>
<p>Но тем не менее давайте рассмотрим, как без LTO исправить проблему с отсутствием inlining'а. Мы можем написать в заголовочном файле тело, это поможет, но это, как мы знаем, ошибка компиляции. Хм-м, ну, можно не только написать функцию в заголовочном файле, но и пометить её как <code>static</code>, но это, даёт вам свою функцию на каждую единицу трансляции, что, во-первых, бывает просто не тем, что вы хотите, а во-вторых, кратно увеличивает размер выходного файла. </p>
<p>Поэтому есть модификатор <code>inline</code>. Он нужен для того, чтобы линковщик не дал ошибку нарушения ODR. <strong>Модификатор <code>inline</code> напрямую никак не влияет на то, что функции встраиваются.</strong>. Если посмотреть на <code>inline</code> через <em>nm</em>, то там увидим <em>W</em> (weak) — из нескольких функций можно выбрать любую (предполагается, что все они одинаковые).</p>
<p>По сути <code>inline</code> — указание компилятору, что теперь за соблюдением ODR следите вы, а не он. И если ODR вы нарушаете, то это неопределённое поведение (<em>ill-formed, no diagnostic required</em>). <em>ill-formed, no diagnostic required</em> — это ситуация, когда программа некорректна, но никто не заставляет компилятор вам об этом говорить. Он может (у GCC есть такая возможность: если дать <em>g++</em> ключи <em>-flto -Wodr</em>, он вам об этом скажет), но не обязан. А по жизни линковщик выберет произвольную из имеющихся функций (например, из первой единицы трансляции или вообще разные в разных местах):</p>
<pre><code class="language-c++">// a.cpp
#include &lt;cstdio&gt;

inline void f() {
	printf(&quot;Hello, a.cpp!\n&quot;);
}

void g();

int main() {
	f();
	g();
}
</code></pre>
<pre><code class="language-c++">// b.cpp
inline void f() {
	printf(&quot;Hello, b.cpp!\n&quot;);
}

void g() {
	f();
}
</code></pre>
<p>Если скомпилировать этот код с оптимизацией, обе функции <code>f</code> будут за'inline'ены, и всё будет хорошо. Если без, то зависит от порядка файлов: <em>g++ a.cpp b.cpp</em> может вполне выдавать <em>Hello, a.cpp!</em> два раза, а <em>g++ b.cpp a.cpp</em> — <em>Hello, b.cpp!</em> два раза.</p>
<p>Если нужно именно за'inline'ить функцию, то есть нестандартизированные модификаторы типа <code>__forceinline</code>, однако даже они могут игнорироваться компилятором. Inlining функции может снизить производительность: на эту тему можно послушать <a href="https://youtu.be/rJWSSWYL83U?t=1970">доклад Антона Полухина на C++ Russia 2017</a>.</p>
<h2><a class="header" href="#Остальные-команды-препроцессора" id="Остальные-команды-препроцессора">Остальные команды препроцессора.</a></h2>
<p><code>#include</code> обсудили уже вдоль и поперёк. Ещё есть директивы <code>#if</code>, <code>#ifdef</code>, <code>#ifndef</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code>, которые дают условную компиляцию. То есть если выполнено какое-то условие, можно выполнить один код, а иначе — другой.</p>
<h3><a class="header" href="#Определение-макроса" id="Определение-макроса">Определение макроса.</a></h3>
<p>И ещё есть <em>макросы</em>: определить макрос (<code>#define</code>) и разопределить макрос (<code>#undef</code>):</p>
<pre><code class="language-c++">#define PI 3.14159265
double circumference(double r) {
    return 2 * PI * r;
}
</code></pre>
<p>Текст, который идет после имени макроса, называется <em>replacement</em>. Replacement отделяется от имени макроса пробелом и распространяется до конца строки. Все вхождения идентификатора <code>PI</code> ниже этой директивы будут заменены на <em>replacement</em>. Самый простой макрос — <em>object-like</em>, его вы видите выше, чуть более сложный — <em>function-like</em>:</p>
<pre><code class="language-c++">#define MIN(x, y) x &lt; y ? x : y

printf(&quot;%d&quot;, MIN(4, 5));
</code></pre>
<p>Что нам нужно про это знать — <strong>макросы работают с токенами</strong>. Они не знают вообще ничего о том, что вы делаете. Вы можете написать</p>
<pre><code class="language-c++">#include &lt;cerrno&gt;

int main() {
	int errno = 42;
}
</code></pre>
<p>И получить отрешённое от реальности сообщение об ошибке. А дело всё в том, что это на этапе препроцессинга раскрывается, например, так:</p>
<pre><code class="language-c++">int main() {
	int (*__errno_location()) = 42;
}
</code></pre>
<p>И тут компилятор видит более отъявленный бред, нежели называние переменной так, как нельзя.</p>
<p>Что ещё не видит препроцессор, так это синтаксическую структуру и приоритет операций. Более страшные вещи получаются, когда пишется что-то такое:</p>
<pre><code class="language-c++">#define MUL(x, y) x * y

int main() {
	int z = MUL(2, 1 + 1);
}
</code></pre>
<p>Потому что раскрывается это в</p>
<pre><code class="language-c++">int main() {
	int z = 2 * 1 + 1;
}
</code></pre>
<p>Это не то что вы хотите. Поэтому когда вы такое пишите, <strong>нужно во-первых, все аргументы запихивать в скобки, во-вторых — само выражение тоже</strong>, а в-третьих, это вас никак не спасёт от чего-то такого:</p>
<pre><code class="language-c++">#define max(a, b) ((a) &lt; (b) ? (a) : (b))

int main() {
	int x = 1;
	int y = 2;
	int z = max(x++, ++y);
}
</code></pre>
<p>Поэтому <strong>перед написанием макросов три раза подумайте, нужно ли оно, а если нужно, будьте очень аккуратны</strong>. А ещё, если вы используете отладчик, то он ничего не знает про макросы, зачем ему знать. Поэтому в отладчике написать «вызов макроса» Вы обычно не можете. Cм. также <a href="http://www.stroustrup.com/bs_faq2.html#macro">FAQ Бьярна Страуструпа</a> о том, почему макросы — это плохо.</p>
<p>Ещё <code>#define</code> позволяет переопределять макросы.</p>
<pre><code class="language-c++">#define STR &quot;abc&quot;
const char* first = STR; // &quot;abc&quot;.
#define STR &quot;def&quot;
const char* second = STR; // &quot;def&quot;.
</code></pre>
<p><em>Replacement</em> макроса не препроцессируется при определении макроса, но результат раскрытия макроса препроцессируется повторно:</p>
<pre><code class="language-c++">#define Y foo
#define X Y   // Это не `#define X foo`.
#define Y bar // Это не `#define foo bar`.
X             // Раскрывается `X` -&gt; `Y` -&gt; `bar`.
</code></pre>
<p>Также по спецификации препроцессор никогда не должен раскрывать макрос изнутри самого себя, а оставлять вложенный идентификатор как есть:</p>
<pre><code class="language-c++">#define M { M }
M   // Раскрывается в { M }.
</code></pre>
<p><u>Ещё пример</u>:</p>
<pre><code class="language-c++">#define A a{ B }
#define B b{ C }
#define C c{ A }
A // a{ b{ c{ A } } }
B // b{ c{ a{ B } } }
C // c{ a{ b{ C } } }
</code></pre>
<h3><a class="header" href="#Условная-компиляция-Проверка-макроса" id="Условная-компиляция-Проверка-макроса">Условная компиляция. Проверка макроса.</a></h3>
<p>Директивы <code>#ifdef</code>, <code>#ifndef</code>, <code>#if</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> позволяют отпрепроцессировать часть файла, лишь при определенном условии. Директивы <code>#ifdef</code>, <code>#ifndef</code> проверяют определен ли указанный макрос. Например, они полезны для разной компиляции:</p>
<pre><code class="language-c++">#ifdef __x86_64__
typedef unsigned long uint64_t;
#else
typedef unsigned long long uint64_t;
#endif
</code></pre>
<p>Директива <code>#if</code> позволяет проверить произвольное арифметическое выражение.</p>
<pre><code class="language-c++">#define TWO 2
#if TWO + TWO == 4
// ...
#endif
</code></pre>
<p>Директива <code>#if</code> препроцессирует свой аргумент, а затем парсит то, что получилось как арифметическое выражение. Если после препроцессирования в аргументе <code>#if</code> остаются идентификаторы, то они заменяются на 0, кроме идентификатора <code>true</code>, который заменяется на 1.</p>
<p>Одно из применений <code>#ifndef</code> — это include guard, которые уже обсуждались <a href="./05_compilation.html#headers-%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%B0-include">ранее</a>.</p>
<h3><a class="header" href="#Константы" id="Константы">Константы.</a></h3>
<p>Понадобилась нам, например, $\pi$. Традиционно в C это делалось через <code>#define</code>. Но у препроцессора, как мы знаем, есть куча проблем. В случае с константой <code>PI</code> ничего не случится, вряд ли кто-то будет называть переменную так, особенно большими буквами, но всё же.</p>
<p>А в C++ (а позже и в C) появился <code>const</code>. Но всё же, зачем он нужен, почему нельзя просто написать глобальную переменную <code>double PI = 3.141592;</code>?</p>
<ol>
<li>Во-первых, константы могут быть оптимизированы компилятором. Если вы делаете обычную переменную, компилятор обязан её взять из памяти (или регистров), ведь в другом файле кто-то мог её поменять. А если вы напишете <code>const</code>, то у вас не будет проблем ни с оптимизацией (ассемблер будет как при <code>#define</code>), ни с адекватностью сообщений об ошибках.</li>
<li>Во-вторых, она несёт документирующую функцию, когда вы пишете <code>const</code> с указателями. Если в заголовке функции написано <code>const char*</code>, то вы точно знаете, что вы передаёте в неё строку, которая не меняется, а если <code>char*</code>, то, скорее всего, меняется (то есть функция создана для того, чтобы менять).</li>
<li>В-третьих, имея <code>const</code>, компилятор может вообще не создавать переменную: если мы напишем <code>return PI * 2</code>, то там будет возвращаться константа, и никакого умножения на этапе исполнения.</li>
</ol>
<p>Кстати, как вообще взаимодействует <code>const</code> с указателями? Посмотрим на такой пример:</p>
<pre><code class="language-c++">int main() {
	const int MAGIC = 42;
	int* p = &amp;MAGIC;
}
</code></pre>
<p>Так нельзя, это имеет фундаментальную проблему: вы можете потом записать <code>*p = 3</code>, и это всё порушит. Поэтому вторая строка не компилируется, и её надо заменить на</p>
<pre><code class="language-c++">	const int* p = &amp;MAGIC;
</code></pre>
<p>Но тут нужно вот на что посмотреть. У указателя в некотором смысле два понятия неизменяемости. Мы же можем сделать так:</p>
<pre><code class="language-c++">int main() {
	const int MAGIC = 42;
	const int* p = &amp;MAGIC;
	// ...
	p = nullptr;
}
</code></pre>
<p>Кто нам мешает так сделать? Да никто, нам нельзя менять содержимое <code>p</code>, а не его самого. А если вы хотите написать, что нельзя менять именно сам указатель, то это не <code>const int*</code>/<code>int const*</code>, а <code>int* const</code>. Если вам нужно запретить оба варианта использования, то, что логично, <code>const int* const</code> или <code>int const* const</code>. То есть</p>
<pre><code class="language-c++">int main() {
	int* a;
	*a = 1;      // ok.
	a = nullptr; // ok.

	const int* b;       // Синоним `int const* b;`
	*b = 1;      // Error.
	b = nullptr; // ok.

	int* const c;
	*c = 1;      // ok.
	c = nullptr; // Error.

	const int* const d; // Синоним `int const* const d;`
	*d = 1;      // Error.
	d = nullptr; // Error.
}
</code></pre>
<p>Теперь вот на что посмотрим:</p>
<pre><code class="language-c++">int main() {
	int a = 3;
	const int b = 42;

	int* pa = &amp;a;        // 1.
	const int* pca = &amp;a; // 2.
	int* pb = &amp;b;        // 3.
	const int* pcb = &amp;b; // 4.
}
</code></pre>
<p>Что из этого содержит ошибку? Ну, в третьем точно ошибка, это мы уже обсудили. Также первое и четвёртое точно корректно. А что со вторым? Ну, нарушает ли второе чьи-то права? Ну, нет. Или как бы сказали на парадигмах программирования, никто не нарушает контракт, мы только его расширяем (дополнительно обещая неизменяемость), а значит всё должно быть хорошо. Ну, так и работают неявные преобразования в C++, <strong>вы можете навешивать <code>const</code> везде, куда хотите, но не можете его убирать</strong>.</p>
<p>Константными могут быть и составные типы (в частности, структуры). Тогда у этой структуры просто будут константными все поля.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="04_syntax_types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="06_classes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="04_syntax_types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="06_classes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
