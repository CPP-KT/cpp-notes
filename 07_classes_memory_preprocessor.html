<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ещё про классы, выделение памяти, препроцессор - C++ course notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li class="chapter-item expanded "><a href="07_classes_memory_preprocessor.html" class="active"><strong aria-hidden="true">8.</strong> Ещё про классы, выделение памяти, препроцессор</a></li><li class="chapter-item expanded "><a href="08_inheritance.html"><strong aria-hidden="true">9.</strong> Наследование, виртуальные функции</a></li><li class="chapter-item expanded "><a href="09_exceptions.html"><strong aria-hidden="true">10.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li class="chapter-item expanded "><a href="10_memory_allocation.html"><strong aria-hidden="true">11.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации, статические и динамические библиотеки</a></li><li class="chapter-item expanded "><a href="11_templates.html"><strong aria-hidden="true">12.</strong> Шаблоны (templates)</a></li><li class="chapter-item expanded "><a href="12_stl_sfinae.html"><strong aria-hidden="true">13.</strong> Обзор STL, tag-dispatching, SFINAE, пространства имён</a></li><li class="chapter-item expanded "><a href="13_namespaces_using_adl.html"><strong aria-hidden="true">14.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li class="chapter-item expanded "><a href="14_move_rvalue.html"><strong aria-hidden="true">15.</strong> Move-семантика, rvalue-ссылки</a></li><li class="chapter-item expanded "><a href="15_intrusive_containers.html"><strong aria-hidden="true">16.</strong> Интрузивные контейнеры</a></li><li class="chapter-item expanded "><a href="16_smart_pointers.html"><strong aria-hidden="true">17.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li class="chapter-item expanded "><a href="17_perfect_forwarding.html"><strong aria-hidden="true">18.</strong> Perfect forwarding, variadic templates</a></li><li class="chapter-item expanded "><a href="18_decltype_auto_nullptr.html"><strong aria-hidden="true">19.</strong> Decltype, declval, auto, nullptr</a></li><li class="chapter-item expanded "><a href="19_lambdas_type_erasure.html"><strong aria-hidden="true">20.</strong> Анонимные функции, type erasure, std::function</a></li><li class="chapter-item expanded "><a href="20_signals_reetrancy_errors.html"><strong aria-hidden="true">21.</strong> Сигналы, reetrancy, обработки ошибок</a></li><li class="chapter-item expanded "><a href="21_optional_variant_tuple_stringview.html"><strong aria-hidden="true">22.</strong> Optional, variant, tuple, string_view</a></li><li class="chapter-item expanded "><a href="22_constexpr.html"><strong aria-hidden="true">23.</strong> Статическая и динамическая инициализация, constexpr</a></li><li class="chapter-item expanded "><a href="23_multithreading.html"><strong aria-hidden="true">24.</strong> Многопоточность</a></li><li class="chapter-item expanded "><a href="24_qt.html"><strong aria-hidden="true">25.</strong> Qt</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">C++ course notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/lejabque/cpp-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Ещё-немного-про-классы" id="Ещё-немного-про-классы">Ещё немного про классы</a></h1>
<ul>
<li><a href="https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp">Пример к лекции</a></li>
<li><a href="https://www.youtube.com/watch?v=nI6NEPYPRXU">Запись лекции №1</a></li>
<li><a href="https://www.youtube.com/watch?v=8JAp3tG6IrA">Запись лекции №2</a></li>
</ul>
<hr />
<h2><a class="header" href="#special-member-функции" id="special-member-функции">Special member функции</a></h2>
<p>Такие функции компилятор сгенерирует сам, если не написать их.</p>
<ul>
<li>
<p>Default constructor - конструктор без аргументов.</p>
</li>
<li>
<p>Destructor - вызывается при выходе из области видимости, используется для освобождения ресурсов. Вызываются в обратном порядке по отношению к порядку вызовов конструктора.</p>
</li>
</ul>
<pre><code class="language-c++">~my_string() {
	free(data_);
}
</code></pre>
<ul>
<li>
<p>Copy constructor - конструктор копирования:</p>
<pre><code class="language-c++">my_string(my_string const&amp; other) {
  size_ = other.size_;
  capacity_ = other.capacity_;
  data_ = (char*)malloc(size_ + 1);
  memcpy(data_, other.data_, size_ + 1);	
}
</code></pre>
</li>
<li>
<p>Assignment operator - оператор присваивания, похож на конструктор копирования, но не создает объект, а меняет уже существующий.<br />
Поэтому в <code>my_string bb = a;</code> вызывается конструктор копирования, так как объект <code>bb</code> ещё не создан.</p>
</li>
</ul>
<pre><code class="language-c++">my_string&amp; operator=(my_string const&amp; other){
	if (this != &amp;other) { 
		// важно проверить, что не присваиваем a = a
		// иначе почистим data_ у себя же
		free(data_);
		size_ = other.size_;
		capacity_ = other.capacity_;
		data_ = (char*)malloc(size_ + 1);
		memcpy(data_, other.data_, size_ + 1);	
	}
	return *this;
}
</code></pre>
<p>Special member функции позволяют реализовать поведение пользовательским типам аналогично стандартным типам (присваивание, копирование), поэтому если они не написаны, то их генерирует компилятор по следующим правилам:</p>
<ul>
<li>
<p>Default constructor - генерируется пустой, если нет других конструкторов.</p>
</li>
<li>
<p>Destructor - генерируется пустой, если не написан.</p>
</li>
<li>
<p>Copy constructor - генерируется, если не написан. Сгенерированный автоматически копирует все поля класса, при этом все члены класса копируются не побайтово, а с вызовом их конструкторов копирования.</p>
<p>Дефолтный конструктор копирования будет копировать указатели без выделения новой памяти. Так, например, у двух объектов <code>my_string</code> будут одинаковые указатели на <code>data_</code> и при выходе из области видимости, оба деструктора вызовут <code>free(data_)</code>. </p>
</li>
<li>
<p>Assignment constructor - генерируется, если не написан. </p>
</li>
</ul>
<p>Как запретить копирования и присваивания?</p>
<pre><code class="language-c++">my_string&amp; operator=(my_string const&amp;) = delete;
my_string(my_string const&amp;) = delete;
</code></pre>
<p>Также можно явно создать дефолтный конструктор (например, если есть уже какой-то другой и из-за него дефолтный не сгенерируется):</p>
<pre><code class="language-c++">my_string() = default;
my_string(my_string const&amp;) = default;
</code></pre>
<p>Так ещё может быть полезно писать, чтобы явно документировать, что дефолтный подходит.</p>
<p>Отличается ли чем-то пустой конструктор от дефолтного?  Пустой конструктор - это <em>user-defined</em> конструктор. Класс с <em>default</em> конструктором - это  <em>trivially constructible</em>. Для них, например, при создании массива не будут вызываться конструкторы.</p>
<p>Если <code>= default</code> писать в определении в какой-нибудь из единиц трансляции, то другие единицы трансляции во время компиляции не знают, что класс <em>trivially constructible</em> и не используют это.</p>
<h2><a class="header" href="#cписки-инициализации-у-конструкторов" id="cписки-инициализации-у-конструкторов">Cписки инициализации у конструкторов</a></h2>
<p>Перед исполнением кода конструктора, вызываются дефолтные конструкторы у всех полей класса. Списки инициализации позволяют заменить вызов дефолтного конструктора поля на вызов конструктора с аргументами.</p>
<pre><code class="language-c++">person() : name(&quot;Ivan&quot;), surname (&quot;Sorokin&quot;) {
	// ...
}
</code></pre>
<p>Хорошее правило - порядок инициализации такой же, как порядок объявления полей, потому что вне зависимости от написанного порядка, они будут инициализироваться в том порядке, в котором объявлены. Подробнее про порядок инициализации <a href="https://en.cppreference.com/w/cpp/language/constructor">здесь</a></p>
<p>Кроме того, конструкторы можно делегировать:</p>
<pre><code class="language-c++">person() : person(&quot;Ivan&quot;, &quot;Sorokin&quot;) {
	// сначала вызовет конструктор от двух char const*, а затем будет выполнять тело это конструктора
}
</code></pre>
<h2><a class="header" href="#Выделение-памяти" id="Выделение-памяти">Выделение памяти</a></h2>
<pre><code class="language-c++">void f(person const&amp; p);
itn main() {
	person p; // выделяется на стеке, удалится после }
	f(person(&quot;Ivan&quot;, &quot;Sorokin&quot;));	// temporary объект, удалится после ;
}
</code></pre>
<h3><a class="header" href="#malloc-free" id="malloc-free">malloc, free</a></h3>
<pre><code class="language-c++">void* p = malloc(42); // выделяем 42 байта
free(p); // чистит память, выделенную по указателю p
free(p); // так делать не нужно
p = nullptr;
free(p); // так можно, ничего не произойдет
</code></pre>
<p>Двойной <code>free</code> вызывает UB или даже <a href="https://awakened1712.github.io/hacking/hacking-whatsapp-gif-rce/">уязвимость</a></p>
<h3><a class="header" href="#new-delete" id="new-delete">new, delete</a></h3>
<p>В большинстве реализаций <code>new</code> внутри вызывает <code>malloc</code> и на выделенной памяти вызывается конструктор. <code>delete</code>, соответственно, вызывает деструктор и <code>free</code>.</p>
<pre><code class="language-c++">person* p = new person(&quot;Ivan&quot;, &quot;Sorokin&quot;);
delete p;

person* p = new person[10]; // выделяет память на 10 объектов person и вызывает их дефолтные конструкторы
delete[] p; // если new вызывался с [], то нужно delete[]

new T;   // оставляет неинициализированную память, если trivially constructible
new T(); // вызывает конструктор
</code></pre>
<h2><a class="header" href="#Препроцессор" id="Препроцессор">Препроцессор</a></h2>
<h3><a class="header" href="#define" id="define">#define</a></h3>
<pre><code class="language-c++">#define PI 3.14159265
double circumference(double r) {
    return 2 * PI * r;
}
</code></pre>
<p>Здесь директива <code>#define</code> определяет макрос с именем <code>PI</code>. Текст, который идет после имени макроса, называется <em>replacement</em>. Replacement отделяется от имени макроса пробелом и распространяется до конца строки. Все вхождения идентификатора <code>PI</code> ниже этой директивы будут заменены на <em>replacement</em>. При этом препроцессор смотрит целиком токены и не будет заменять, например, часть названия переменной.  Результатом препроцессирования примера выше является следующий текст:</p>
<pre><code class="language-c++">double circumference(double r) {
    return 2 * 3.14159265 * r;
}
</code></pre>
<p>Приведенная выше форма директивы <code>#define</code> называется <em>object-like</em>. Существует вторая форма этой директивы, называемая <em>function-like</em>:</p>
<pre><code class="language-c++">#define MIN(x, y) x &lt; y ? x : y
printf(&quot;%d&quot;, MIN(4, 5));
</code></pre>
<p>Результатом препроцессирования этого фрагмента кода является:</p>
<pre><code class="language-c++">printf(&quot;%d&quot;, 4 &lt; 5 ? 4 : 5);
</code></pre>
<p>Важно понимать, что препроцессор, выполняя подстановки макросов, ничего не знает про приоритет арифметических операций и синтаксическую структуру программы. Рассмотрим следующую программу:</p>
<pre><code class="language-c++">#define MIN(x, y) x &lt; y ? x : y
int main()
{
    printf(&quot;%d&quot;, 10 + MIN(4, 5));
}
</code></pre>
<p>Данная программа выводит <code>5</code>, тогда как скорее всего программист ожидал вывода <code>14</code>. Дело в том, что после раскрытия макроса возникает выражение <code>10 + 4 &lt; 5 ? 4 : 5</code>. Поскольку бинарный <code>+</code> имеет приоритет выше, чем у тернарного оператора, данное выражение разбирается транслятором как <code>(10 + 4) &lt; 5 ? 4 : 5</code>, а не <code>10 + (4 &lt; 5 ? 4 : 5)</code>, как мог ожидать программист, использующий макрос. Чтобы избегать подобных проблем, у <em>function-like</em> макросов, которые раскрываются в выражение, <em>replacement</em> следует брать в скобки. По той же причине имена параметров макроса в <em>replacement</em>, следует брать в скобки. Корректный макрос <code>MIN</code> мог бы выглядеть следующим образом:</p>
<pre><code class="language-c++">#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))
</code></pre>
<p>Директива <code>#define</code> позволяет определять макросы повторно, при этом, в каждой точке программы силу имеет последний <code>#define</code> данного макроса:</p>
<pre><code class="language-c++">X
#define X foo
X
#define X bar
X
</code></pre>
<p>раскрывается в:</p>
<pre><code class="language-c++">X
foo
bar
</code></pre>
<p><em>Replacement</em> макроса не препроцессируется при определении макроса, но результат раскрытия макроса препроцессируется повторно:</p>
<pre><code class="language-c++">#define Y foo
#define X Y
#define Y bar
X                   // раскрывается в bar
</code></pre>
<p>Что произойдет если replacement макроса <code>M</code> будет содержать использование макроса <code>M</code>? В этом случае возникает рекурсия. По спецификации препроцессор никогда не должен раскрывать макрос <code>M</code> изнутри самого себя, а оставлять вложенный идентификатор как есть:</p>
<pre><code class="language-c++">#define M { M }
M                   // раскрывается в { M } один раз, второй раз M не раскрывается
</code></pre>
<p>Ещё пример:</p>
<pre><code class="language-c++">#define A a{ B }
#define B b{ C }
#define C c{ A }
A
B
C
</code></pre>
<p>Результат препроцессирования:</p>
<pre><code class="language-c++">a{ b{ c{ A } } }
b{ c{ a{ B } } }
c{ a{ b{ C } } }
</code></pre>
<h3><a class="header" href="#undef" id="undef">#undef</a></h3>
<p>Директива <code>#undef</code> позволяет разопределить макрос, определенный ранее с помощью директивы <code>#define</code>. Пример:</p>
<pre><code class="language-c++">#define X foo
X
#undef X
X
</code></pre>
<p>Результат препроцессирования:</p>
<pre><code class="language-c++">foo
X
</code></pre>
<h3><a class="header" href="#if" id="if">#if</a></h3>
<p>Директивы <code>#ifdef</code>, <code>#ifndef</code>, <code>#if</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> позволяют отпрепроцессировать часть файла, лишь при определенном условии. Директивы <code>#ifdef</code>, <code>#ifndef</code> проверяют определен ли указанный макрос. Например, они полезны для разной компиляции:</p>
<pre><code class="language-c++">#ifdef __x64_64__
typedef unsigned long uint64_t;
#else
typedef unsigned long long uint64_t;
#endif
</code></pre>
<p>Директива <code>if</code> позволяет проверить произвольное арифметическое выражение.</p>
<pre><code class="language-c++">#define TWO 2
#if TWO + TWO == 4
// ...
#endif
</code></pre>
<p>Директива <code>#if</code> препроцессирует свой аргумент, а затем парсит то, что получилось как арифметическое выражение. Если после препроцессирования в аргументе <code>#if</code> остаются идентификаторы, то они заменяются на 0, кроме идентификатора <code>true</code>, который заменяется на 1.</p>
<p>Одно из применений <code>#if</code> - это <code>include guard</code>, которые уже обсуждались <a href="https://github.com/lejabque/cpp-notes/blob/master/src/05_compilation.md#headers">ранее</a>.</p>
<h3><a class="header" href="#Проблемы-макросов" id="Проблемы-макросов">Проблемы макросов</a></h3>
<p>Основной сложностью <a href="http://www.stroustrup.com/bs_faq2.html#macro">см. также FAQ Бьярна Страуструпа на тему, почему макросы это плохо.</a> при использовании макросов препроцессора является то, что препроцессор оперирует на уровне токенов, не зная ничего про контекст где макрос раскрывается. Предположим, что определен макрос <code>errno</code>, а где-то ниже программист пытается определить локальную переменную <code>errno</code>.</p>
<pre><code class="language-c++">#define errno (*errno_location())
int process() {
    int errno = 0;
}
</code></pre>
<p>Результатом препроцессирования этого фрагмента будет:</p>
<pre><code class="language-c++">int process() {
    int (*errno_location()) = 0;
}
</code></pre>
<p>Как мы видим получившийся в результате препроцессирования фрагмент не объявляет переменную <code>errno</code>. Этот фрагмент не объявляет вообще никакую переменную. В данном конкретном случае программист получит ошибку трансляции:</p>
<pre><code class="language-c++">errno.cpp:5:17: error: function ‘int* errno_location()’ is initialized like a variable
     int errno = 0;
                 ^
</code></pre>
<p>Сообщение об ошибке ссылается на некоторую функцию <code>int* errno_location()</code>, которая в пользовательском коде не упоминается. Такие ошибки могут быть запутывающими. При использовании библиотек, которые определяют много макросов с короткими именами это может доставлять неудобство, поскольку эти имена становится невозможно использовать ни под что другое. Чтобы смягчить такие проблемы, стоит избегать коротких имён макросов: <code>GTK_MAJOR_VERSION</code> - пример хорошего имени макроса. <code>min</code>, <code>check</code>, <code>tmp</code>, <code>out</code> - примеры плохих имен.</p>
<p>Второй проблемой при использовании пропроцессора является то, что отладчик ничего не знает про раскрытые макросы. Независимо от того, сколько кода пришло из макроса, отладчик будет работать как будто весь этот код написан в одной строке. Поэтому, как правило, в коде активно использующем макросы, сложно работать с отладчиком.</p>
<h3><a class="header" href="#Альтернативы-макросам" id="Альтернативы-макросам">Альтернативы макросам</a></h3>
<p>В связи с расширение языка, сейчас возможно использовать обычные языковые конструкции, там где раньше использовался препроцессор. Например, изначально препроцессор использовался для того, чтобы определять константы:</p>
<pre><code class="language-c++">#define BUFF_SIZE 10240
</code></pre>
<p>Без использования препроцессора эту константу возможно объявить как:</p>
<pre><code class="language-c++">size_t const BUFF_SIZE = 10240;
</code></pre>
<p>Аналогично function-like макросы часто можно заменить на inline-функции:</p>
<pre><code class="language-c++">#define STREQ(s1, s2) (strcmp((s1), (s2)) == 0)

inline bool streq(char const* s1, char const* s2) {
    return strcmp(s1, s2) == 0;
}
</code></pre>
<p>В случае когда типы аргументов могут быть различными возможно использование шаблонов:</p>
<pre><code class="language-c++">#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))

template &lt;class T&gt;
T const&amp; min(T const&amp; x, T const&amp; y) {
    return x &lt; y ? x : y;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="06_classes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="08_inheritance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="06_classes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="08_inheritance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
