<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Шаблоны (templates), tag-dispatching, SFINAE - C++ course notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li class="chapter-item expanded "><a href="07_inheritance.html"><strong aria-hidden="true">8.</strong> Наследование (в т.ч. виртуальное), виртуальные функции</a></li><li class="chapter-item expanded "><a href="08_exceptions.html"><strong aria-hidden="true">9.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li class="chapter-item expanded "><a href="09_allocations_optimizations.html"><strong aria-hidden="true">10.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации</a></li><li class="chapter-item expanded "><a href="10_libraries.html"><strong aria-hidden="true">11.</strong> Статические и динамические библиотеки</a></li><li class="chapter-item expanded "><a href="11_undefined_behaviour.html"><strong aria-hidden="true">12.</strong> Undefined behaviour: примеры и способы его понимать</a></li><li class="chapter-item expanded "><a href="12_validation.html"><strong aria-hidden="true">13.</strong> Способы валидации программы</a></li><li class="chapter-item expanded "><a href="13_tools.html"><strong aria-hidden="true">14.</strong> Полезные инструменты, которые пригодятся вам в жизни</a></li><li class="chapter-item expanded "><a href="14_templates.html" class="active"><strong aria-hidden="true">15.</strong> Шаблоны (templates), tag-dispatching, SFINAE</a></li><li class="chapter-item expanded "><a href="15_stl.html"><strong aria-hidden="true">16.</strong> Обзор STL</a></li><li class="chapter-item expanded "><a href="16_namespaces_using_adl.html"><strong aria-hidden="true">17.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li class="chapter-item expanded "><a href="17_move_rvalue.html"><strong aria-hidden="true">18.</strong> Move-семантика, rvalue-ссылки</a></li><li class="chapter-item expanded "><a href="18_intrusive_containers.html"><strong aria-hidden="true">19.</strong> Интрузивные контейнеры</a></li><li class="chapter-item expanded "><a href="19_smart_pointers.html"><strong aria-hidden="true">20.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li class="chapter-item expanded "><a href="20_perfect_forwarding.html"><strong aria-hidden="true">21.</strong> Perfect forwarding, variadic templates</a></li><li class="chapter-item expanded "><a href="21_decltype_auto_nullptr.html"><strong aria-hidden="true">22.</strong> Decltype, declval, auto, nullptr</a></li><li class="chapter-item expanded "><a href="22_lambdas_type_erasure.html"><strong aria-hidden="true">23.</strong> Анонимные функции, type erasure, std::function</a></li><li class="chapter-item expanded "><a href="23_signals_reetrancy_errors.html"><strong aria-hidden="true">24.</strong> Сигналы, reetrancy, обработки ошибок</a></li><li class="chapter-item expanded "><a href="24_optional_variant_tuple_stringview.html"><strong aria-hidden="true">25.</strong> Optional, variant, tuple, string_view</a></li><li class="chapter-item expanded "><a href="25_constexpr.html"><strong aria-hidden="true">26.</strong> Статическая и динамическая инициализация, constexpr</a></li><li class="chapter-item expanded "><a href="26_multithreading.html"><strong aria-hidden="true">27.</strong> Многопоточность</a></li><li class="chapter-item expanded "><a href="27_qt.html"><strong aria-hidden="true">28.</strong> Qt</a></li><li class="chapter-item expanded "><a href="28_concepts.html"><strong aria-hidden="true">29.</strong> Концепты</a></li><li class="chapter-item expanded "><a href="29_ranges.html"><strong aria-hidden="true">30.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="30_encoding.html"><strong aria-hidden="true">31.</strong> Кодировки</a></li><li class="chapter-item expanded "><a href="31_coroutines.html"><strong aria-hidden="true">32.</strong> Корутины</a></li><li class="chapter-item expanded "><a href="32_modules.html"><strong aria-hidden="true">33.</strong> Модули</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">C++ course notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/cpp-kt/cpp-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Шаблоны" id="Шаблоны">Шаблоны.</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=AXl4_eZ1eis">Запись лекции №1</a></li>
<li><a href="https://www.youtube.com/watch?v=DwDbH7pxzRA">Запись лекции №2</a></li>
<li><a href="https://www.youtube.com/watch?v=CY7vxMSBork">Практика</a></li>
<li><a href="https://www.youtube.com/watch?v=HQdf43h3B2o">Запись ещё одной лекции</a></li>
</ul>
<hr />
<h2><a class="header" href="#Мотивация" id="Мотивация">Мотивация.</a></h2>
<p>Часто очень хочется делать типизированный класс - например, какую-то структуру данных для разных типов. Здесь и применяются шаблоны.</p>
<h2><a class="header" href="#Способы-жить-без-шаблонов" id="Способы-жить-без-шаблонов">Способы жить без шаблонов.</a></h2>
<p>В C шаблонов не было и было два способа жить без них</p>
<h3><a class="header" href="#void" id="void"><code>void*</code>.</a></h3>
<p>В C есть <code>void*</code> — тип указателя, который (в C, не C++) неявно преобразуется куда угодно и откуда угодно. И тогда всё выглядело бы так:</p>
<pre><code class="language-c++">struct vector {
	void push_back(void*);
	void*&amp; operator[](size_t index);
	const void*&amp; operator[](size_t index) const;
};

int main() {
	point* p;
	vector v;
	v.push_back(p);
	static_cast&lt;point*&gt;(v[0]);
}
</code></pre>
<p>У этого есть следующие проблемы:</p>
<ul>
<li>Это не типобезопасно. Мы можем достать из вектора не то, что туда положили. И компилятор ничего не скажет. А если мы можем выявить ошибку на этапе компиляции, сто́ит это делать.</li>
<li>Количество аллокаций. Если мы хотим хранить целые числа, а не указатели, в <code>std::vector&lt;int&gt;</code> мы тупо выделяем большой блок памяти, а в нашем <code>vector</code>'е мы сначала выделяем большой блок под указатели, а потом выделяем память под каждый. К тому же подобную штуку не получится prefetch'ить, потому что память под каждый объект выделена в разных местах, а значит лишний indirection.</li>
<li>Следующий код не exception-safe.</li>
</ul>
<pre><code class="language-c++">	vector u;
	u.push_back(new point());
</code></pre>
<h3><a class="header" href="#Макросы" id="Макросы">Макросы.</a></h3>
<pre><code class="language-c++">#define DEFINE_VECTOR(vector_name, type)                       \          
struct vector_name {                                              \
	void push_back(type) { /*...*/ }                          \
	type operator[](size_t index) const{ /*...*/ }            \
};
</code></pre>
<p>Тут уже явно лучше, можно написать это типобезопасно, без проблем с памятью, но тоже имеются проблемы. Например, вот:</p>
<pre><code class="language-c++">
DEFINE_VECTOR(vector_int, int);
DEFINE_VECTOR(vector_int32_t, int32_t);
int main() {
	vector_int v;
	vector_int32_t u;
}
</code></pre>
<p>И теперь мы имеем две одинаковые структуры, а хотелось бы иметь одну там, где <code>int</code> 32-битный.</p>
<p>Второе — когда мы имеем <code>DEFINE_VECTOR(int)</code> в двух разных местах. Потому что вам и какому-то человеку из Австралии понадобилось одно и то же. А потом кто-то подключает и то, и другое, и он проиграл.</p>
<h2><a class="header" href="#Базовый-синтаксис" id="Базовый-синтаксис">Базовый синтаксис.</a></h2>
<pre><code class="language-c++">template &lt;typename T&gt;
// template &lt;class T&gt; — это то же самое
struct vector {
	void push_back(T const &amp;) { /*...*/ }
	T const&amp; operator[](size_t index) const { /*...*/ }
};
</code></pre>
<p>После этого пишем <code>vector&lt;int&gt;</code>, и не получаем ни одну из проблем двух способов выше. Шаблоны можно навесить не только на класс, но и <a href="https://en.cppreference.com/w/cpp/language/variable_template">на переменную</a> (since C++14) или функцию:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void swap(T&amp; a, T&amp; b) {
	T tmp = a;
	a = b;
	b = tmp;
}
</code></pre>
<p>При этом для функций вы не обязаны писать <code>swap&lt;int&gt;(a, b)</code>, а можете написать просто <code>swap(a, b)</code>, если переменные <code>a</code> и <code>b</code> уже имеют тип <code>int</code>. При этом если вы подставите в эту функцию <code>long long</code> и <code>int</code>, вам явно напишут, что нельзя так. Более того:</p>
<pre><code class="language-c++">template &lt;typename Dst, typename Src&gt;
Dst my_cast(Src s) {
	return static_cast&lt;Dst&gt;(s);
}
int main() {
	int x = 42;
	my_cast(x);        // Непонятно, чему равно `Dst`, ошибка.
	my_cast&lt;float&gt;(x); // `Dst` указан явно, `Src` можно вывести, зная тип `x`.
}
</code></pre>
<h2><a class="header" href="#Специализации" id="Специализации">Специализации.</a></h2>
<p>Иногда для каких-то типов хочется сделать отдельную реализацию. Например, <code>vector&lt;bool&gt;</code>. Это называется <em>специализацией</em> и делается так:</p>
<pre><code class="language-c++">template &lt;&gt;
struct vector&lt;bool&gt; {
	// ...
};
</code></pre>
<p>И у вас для всех типов, кроме <code>bool</code> будет то, что вы написали изначально, а для <code>bool</code> — специализация. При этом <strong>когда вы пишете специализацию, вы пишете целиком новый класс</strong>.</p>
<p><code>vector&lt;T&gt;</code> называется <em>primary template</em>, <code>vector&lt;bool&gt;</code> — <em>explicit (или full) specialization</em>. А ещё есть
<em>partial specialization</em> — специализировать не обязательно все параметры. И ещё можно особым образом специализировать. Например, мы решили, что мы можем каким-то особым образом хранить указатели:</p>
<pre><code class="language-c++">template &lt;typename U&gt;
struct vector&lt;U*&gt; {
	// ...
};
</code></pre>
<p>(То что тут параметр называется <code>U</code>, а не тоже <code>T</code>, ничего не значит.)</p>
<p>То есть <strong><em>partial specialization</em> — это специализация, сама являющаяся шаблоном</strong>. Теперь, когда вы напишете <code>vector&lt;int*&gt;</code>, вам дадут специализацию <code>vector&lt;U*&gt;</code>.</p>
<p>Примечание: <strong>в шаблоны вы можете передавать всё что угодно</strong> (хоть <code>void</code>, хоть <code>int(int, int)</code> (функцию, даже не указатель на неё), хоть <code>char[]</code>). <strong>Но не любой класс обязан корректно работать с любым классом.</strong> Так <code>std::vector</code> не компилируется, если дать ему не перемещаемый тип, и не работает вполне корректно, если дать ему, ну, например, тип, который кидает исключение в деструкторе.</p>
<p>Впрочем, у вас есть возможность явно указать, какие типы вы принимать не хотите. Двумя способами: <a href="#sfinae">SFINAE</a> и <a href="./28_concepts.html">концепты</a>.</p>
<h3><a class="header" href="#Выбор-специализации" id="Выбор-специализации">Выбор специализации.</a></h3>
<pre><code class="language-c++">template &lt;typename A, template B&gt;
struct my_type {};         // 1
template &lt;typename A&gt;
struct my_type&lt;A, int&gt; {}; // 2
template &lt;typename B&gt;
struct my_type&lt;int, B&gt; {}; // 3

int main() {
	my_type&lt;float, double&gt; fd; // Выбирается 1.
	my_type&lt;float, int&gt;    fi; // Выбирается 2.
	my_type&lt;int,   double&gt; id; // Выбирается 3.
	my_type&lt;int,   int&gt;    ii; // Компилятор не может выбрать между 2 и 3. Не компилируется.
}
</code></pre>
<p>Хм-м-м-м, тут возникает резонный вопрос: видимо, компилятор как-то выбирает «самую хорошую» специализацию, но непонятно, как определяет, какая лучше. А давайте вот на такой пример посмотрим:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct bar {}; // Произвольный тип.

template &lt;typename U&gt;
struct bar&lt;U*&gt; {}; // Указатель на что-то.

template &lt;typename R, typename A, typename B&gt;
struct my_type&lt;R (*)(A, B)&gt; {}; // Указатель на функцию.
</code></pre>
<p>Здесь есть «указатель на что-то» и «указатель на функцию». Кажется, что второе более специализированно. Но как бы это формализовать? Да легко! Является ли произвольный указатель на функцию указателем? Да. А является ли произвольный указатель указателем на функцию? Нет. То есть <strong>если мы всегда можем корректно подставить одну специализацию в другую, но не наоборот, то первая более специализированна</strong>.</p>
<p>Вопрос: что делать, если шаблон от нескольких параметров зависит? Тут <strong>первая специализация более специализированна, чем вторая, если хотя бы по одному параметру она строго более специализированна, а по остальным — не менее</strong>.</p>
<h3><a class="header" href="#Специализация-функций" id="Специализация-функций">Специализация функций.</a></h3>
<p>Во-первых, <strong>у функций нет partial-специализаций</strong>. Во-вторых, есть перегрузки, и непонятно, как они со специализациями взаимодействуют.</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void baz(T*) {}

#if ENABLE_TEMPLATE
template &lt;&gt;
void baz&lt;int&gt;(int*) {}
#else
void baz(int*) {}
#endif
</code></pre>
<p>Чем отличаются две последних функции? Например, на таком коде:</p>
<pre><code class="language-c++">int main() {
	foo(nullptr);
}
</code></pre>
<p>Давайте подумаем, работает ли это, если мы включим <code>ENABLE_TEMPLATE</code>. А вот не работает, потому что непонятно, чему равно <code>T</code>. А вот с перегрузкой всё работает (выбирается перегрузка). Почему это так работает, хочется спросить?</p>
<p>Есть перегрузки функции. Мы их проходили, и одну видим тут: <code>void baz(int*)</code>. Так вот, <strong>шаблон (весь целиком) считается ещё одной перегрузкой</strong>. При этом, когда вы вызываете функцию, происходит вот что:</p>
<ol>
<li>Выбирается перегрузка.</li>
<li>Если выбрана шаблонная перегрузка, выбирается специализация.</li>
</ol>
<p>Подробнее про <em>Template argument deduction</em> на <a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">cppreference</a>.</p>
<p>Поэтому когда мы подставляем <code>nullptr</code>, то из него нельзя понять, на какой тип он указывает, поэтому <em>deduction</em> провалится, и мы получаем ошибку. Если же есть <code>void foo(int*)</code>, то выбирается он, как единственный подходящий.</p>
<p>Кстати, можно немного изменить работу с перегрузками. Можно вызывать функции не как <code>foo(...)</code>, а как <code>foo&lt;&gt;(...)</code>. В таком случае вы явно отбросите всё, что не является шаблоном, а значит выбирать будете только из специализаций.</p>
<h2><a class="header" href="#non-type-template-parameter" id="non-type-template-parameter">Non-type template parameter.</a></h2>
<p>Помимо типов в параметры шаблона можно пихать чиселки. Или любой другой примитивный тип либо <code>enum</code>. Простым примером является <code>std::array</code> — обёртка над C-шным массивом, который принимает два шаблонных параметра: тип, что хранить, и количество, сколько хранить:</p>
<pre><code class="language-c++">template &lt;typename T, size_t N&gt;
struct array {
private:
	T data[N];
public:
	// ...
};
</code></pre>
<p>Всё также можно писать специализации:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct array&lt;T, 0&gt; { /*...*/ };

array&lt;int, 10&gt; a;
array&lt;int, 0&gt; a;
</code></pre>
<p>То же самое можно написать и для функций:</p>
<pre><code class="language-c++">template &lt;typename T, size_t N&gt;
size_t size(T (&amp;arr)[N]) {
	return N;
}
</code></pre>
<p>Важный момент в non-type параметрах шаблона: <strong>всё, что вы подставляете в шаблон, должно быть известно на этапе компиляции</strong>. Потому что только на этапе компиляции существуют типы, в частности, шаблонные типы.</p>
<h2><a class="header" href="#template-template-parameter" id="template-template-parameter">Template template parameter.</a></h2>
<p>Хочется обёртку над контейнером. Зачем-то.</p>
<pre><code class="language-c++">template &lt;/* container */ V&gt;
struct container_wrapper {
	V&lt;int&gt; container;
};

container_wrapper&lt;vector&gt; wrapper;
</code></pre>
<p>Это пишется вот так:</p>
<pre><code class="language-c++">template &lt;template &lt;typename&gt; class V&gt;
struct container_wrapper {
	V&lt;int&gt; container;
};
</code></pre>
<p>Используется эта штука очень редко. Правила работы с ней те же самые, что и обычно.</p>
<h3><a class="header" href="#Параметры-по-умолчанию" id="Параметры-по-умолчанию">Параметры по умолчанию.</a></h3>
<p>Шаблонные параметры могут иметь дефолтные значения, они работают как и у функций:</p>
<pre><code class="language-c++">struct default_comparer { /*...*/ }; // Вообще он называется `std::less`.
template &lt;typename T, typename C = default_comparer&gt;
struct set { /*...*/ };

set&lt;int&gt; a; // `C` = `default_comparer`.
</code></pre>
<h2><a class="header" href="#Зависимые-имена" id="Зависимые-имена">Зависимые имена.</a></h2>
<p>Начнём немного издалека: если вы видели шаблонный код, то вам может показаться, что в случайных местах по нему раскиданы слова <code>typename</code> и <code>template</code>. Например, вот в таких
примерах:</p>
<pre><code class="language-c++">	typename std::vector&lt;T&gt;::iterator it;
	// Вместо std::vector&lt;T&gt;::iterator it;
	typename foo&lt;T&gt;::template bar&lt;int&gt; y;
	// Вместо foo&lt;T&gt;::bar&lt;int&gt; y;
</code></pre>
<p>Зачем это? А давайте рассмотрим некоторые строки в вакууме:</p>
<ul>
<li><code>(a)-b</code>.</li>
<li><code>int b(a)</code>.</li>
<li><code>a &lt; b &amp;&amp; c &gt; d</code>.</li>
</ul>
<p>Что в них написано? А вот непонятно. В зависимости от того, что такое <code>a</code>, есть варианты:</p>
<ul>
<li><code>(a)-b</code>.
<ul>
<li>Вычитание <code>b</code> из <code>(a)</code>.</li>
<li>Приведение <code>-b</code> к типу <code>a</code>.</li>
</ul>
</li>
<li><code>int b(a)</code>.
<ul>
<li>Определение переменный <code>b</code> типа <code>int</code> с конструктором от <code>a</code>.</li>
<li>Объявление функции <code>b</code>, которая принимает тип <code>a</code> и возвращает <code>int</code>.</li>
</ul>
</li>
<li><code>a &lt; b &amp;&amp; c &gt; d</code>.
<ul>
<li>Логическое выражение <code>(a &lt; b) &amp;&amp; (c &gt; d)</code>.</li>
<li>Определение переменной <code>d</code> типа <code>a&lt;b &amp;&amp; c&gt;</code> (шаблон с non-type параметром типа <code>bool</code>).</li>
</ul>
</li>
</ul>
<p>Если <code>a</code> — это тип, то одно, если не тип — то другое. И обычно компилятор это знает. Проблема в том, что в шаблонах мы можем сделать что-то такое:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void foo(int x) {
	(T::nested) - x;
}
</code></pre>
<p>Вы не узнаете, что такое <code>T::nested</code> до подстановки. А очень хотите это знать, чтобы отлавливать ошибки раньше, чем подстановка (например, написав <code>(T::nested) - y</code>, вы получили бы ошибку о том, что не существует <code>y</code>, сразу). Поэтому вы должны явно указать, что происходит:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void foo(int x) {
	(T::nested) - x;        // Вычитание.
	(typename T::nested)-x; // Каст.
}
</code></pre>
<p>Аналогично с двумя другими примерами:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void foo(int x) {
	int b(T::nested);          // Конструктор переменной.
	int b(typename T::nested); // Объявление функции.
}
</code></pre>
<pre><code class="language-c++">template &lt;typename T&gt;
void foo(int x) {
	T::nested &lt; b &amp;&amp; c &gt; d;       // Логическое выражение.
	T::template nested&lt;b &amp;&amp; c&gt; d; // Переменная шаблонного типа.
}
</code></pre>
<p>При этом <strong>когда у вас есть что-то, что не зависит от шаблона (и имеет в себе <code>nested</code>), компилятор сам определит, тип ли это</strong>, писать <code>template</code> и <code>typename</code> не обязательно. То, что зависит от шаблона, называется <em>dependent</em>. И вот <strong>в dependent-штуках обязательно писать <code>typename</code>'ы и <code>template</code>'ы, а non-dependent — нет</strong>.</p>
<p>MSVC, кстати, долгое время делал не так (а полностью разбирал шаблонную функцию при подстановке), за что его загнобили, и больше он так не делает, а делает как все: разбирает dependent выражения при подстановке, а non-dependent — сразу. Это называется «<a href="http://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html"><em>two-phase name lookup</em></a>».</p>
<h3><a class="header" href="#Зависимые-имена-в-базовых-классах" id="Зависимые-имена-в-базовых-классах">Зависимые имена в базовых классах.</a></h3>
<pre><code class="language-c++">struct arg1 {
    struct type {}; // Нельзя складывать.
};

template &lt;typename T&gt;
struct base {};

template &lt;typename T&gt;
struct derived : base&lt;T&gt; {
    void f() {
        typename T::type() + 1; // Ошибка компиляции про подстановке (dependent).
        arg1::type() + 1;       // Ошибка компиляции при разборе (non-dependent).

        x = 5;                  // Непонятно.
    }
};
</code></pre>
<p>Почему непонятно? Потому что мы можем создать специализацию <code>base</code>, у которой будет <code>x</code>, и будет корректно. А ещё этот <code>x</code> может быть глобальной переменной. Поэтому тут происходит что-то непонятное.., хотелось бы сказать, но нет.</p>
<p>По стандарту <strong>компилятор ищет имя, игнорируя базовые классы</strong> (иначе он не мог бы откидывать любые неизвестные имена). Если хотим ссылаться на <code>x</code> из базового класса, нужно писать явно <code>base&lt;T&gt;::x</code> или <code>this-&gt;x</code>. Тогда он, очевидно, будет dependent в обоих случаях.</p>
<p><strong>В dependent-именах компилятор откладывает разбор на момент инстанцирования, даже если раньше очевидно, что есть ошибка</strong>:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct derived : base&lt;T&gt; {
	void* x;
	void f() {
		this-&gt;x = 5;
	}
};
</code></pre>
<h2><a class="header" href="#Как-это-устроено-внутри" id="Как-это-устроено-внутри">Как это устроено внутри?</a></h2>
<p>На лекции очень много <a href="https://godbolt.org">godbolt</a>, поэтому посмотрите <a href="https://youtube.com/watch?v=DwDbH7pxzRA">запись</a> или сами покомпилируйте.</p>
<p>Начнём с шаблонных функций:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void swap(T&amp; a, T&amp; b) {
	T tmp = a;
	a = b;
	b = tmp;
}
auto p = &amp;swap&lt;int&gt;; 
auto q = &amp;swap&lt;char&gt;; 
</code></pre>
<p>Для каждого типа код функции генерируется отдельно. При этом, например, чтобы сделать <code>sizeof(swap(a, b))</code>, компилятору не обязательно подставлять тело функции.</p>
<h3><a class="header" href="#Немного-про-разные-единицы-трансляции" id="Немного-про-разные-единицы-трансляции">Немного про разные единицы трансляции.</a></h3>
<pre><code class="language-c++">// swap.h.
template&lt;typename T&gt;
int swap(T&amp; a, T&amp; b);
</code></pre>
<pre><code class="language-c++">// swap.cpp.
template &lt;typename T&gt;
void swap(T&amp; a, T&amp; b) {
	T tmp = a;
	a = b;
	b = tmp;
}
</code></pre>
<pre><code class="language-c++">// main.cpp.
#include &quot;swap.h&quot;
int main(){
	int a, b;
	swap(a, b);
}
</code></pre>
<p>Такое не скомпилируется. Почему? Каждая единица трансляции транслируется отдельно, а потом всё линкуется.</p>
<p><strong>Инстанцирование шаблонов (подстановка) происходит до линковки</strong>. По этой причине в <code>swap.cpp</code> мы не можем сгенерить <code>swap&lt;int&gt;</code>, потому что не знаем, что он будет использоваться, а в <code>main.cpp</code> не может сгенерить, потому что нет её тела.</p>
<p>Можно определить тело шаблонной функции прямо в <code>swap.h</code> и инклудить в разные файлы. Казалось бы, получим ошибку из-за нескольких определений, но нет. <strong>Шаблонные функции помечаются компилятором как <code>inline</code></strong> и не выдаёт ошибку, считая, что они все одинаковые.</p>
<p>В стандарте прописано, что инстанцирование происходит только когда необходимо. При этом компилятор может делать это в конце единицы трансляции:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct foo {
	T* bar;
	void baz(){
		T qux;
	}
};
int main() {
	foo&lt;void&gt; a; // Так скомпилируется.
	a.baz();     // Так нет, ошибка из-за `void qux;`.
}
</code></pre>
<p>В примере выше видно, что если в коде нет вызова функции <code>baz</code>, то всё компилируется, так как она не инстанцируется.</p>
<p>С классами работает аналогично: <strong>полное тело класса не подставляется, если не требуется</strong>:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct foo {
	T bar;
};
int main() {
	foo&lt;void&gt;* a; // Так скомпилируется.
	a-&gt;bar;       // Так нет, опять ошибка из-за `void bar;`.
}
</code></pre>
<h4><a class="header" href="#incomplete-type" id="incomplete-type">Incomplete type.</a></h4>
<p>Помните <em>incomplete type</em>? Его упоминали в конце <a href="./05_compilation.html#forward-%D0%B4%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%86%D0%B8%D0%B8">раздела про forward-декларации</a>. Так вот, почему важно понимать то, что написано выше? Ну, например, мы не можем использовать <code>std::unique_ptr</code> на incomplete типе. Точнее, можем, но получим ошибку, если в коде есть вызов деструктора или другие обращение к объекту.</p>
<pre><code class="language-c++">// mytype.h
#include &lt;memory&gt;

struct object;

struct mytype {
	std::unique_ptr&lt;object&gt; obj;
};
</code></pre>
<pre><code class="language-c++">// mytype.cpp
#include &quot;mytype.h&quot;

struct object {
	object(int, int, int) {};
};
mytype::mytype() : obj(new object(1, 2, 3)) {}
</code></pre>
<pre><code class="language-c++">// main.cpp
#include &quot;mytype.h&quot;
int main(){
	mytype a;
	return 0;
}
</code></pre>
<p>Без <em>main.cpp</em> компилируется, так как у <code>a</code> не вызывался деструктор, поэтому он не инстанцировался. С <em>main.cpp</em> компилятор генерирует деструктор, который вызывает деструкторы всех членов класса, а там <code>unigue_ptr&lt;object&gt;</code>, у которого при компиляции будет инстанцироваться деструктор. В <code>unique_ptr</code> есть специальная проверка, что если удаляется incomplete type (а у нас <code>object</code> именно таковой), то это ошибка.<br />
Как решить проблему? Сделать объявление деструктора в <em>mytype.h</em>, а определить его там, где <code>object</code> — complete тип (то есть в <em>mytype.cpp</em>).</p>
<p>Ещё пример:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct base {
	typename T::mytype a;
};

template &lt;typename T&gt;
struct derived : base&lt;derived&lt;T&gt;&gt; {
	typedef T mytype;
};

derived&lt;int&gt; a;
</code></pre>
<p>Почему это не скомпилируется? Посмотрим на пример попроще:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct base {
	typename T::mytype a;
};
struct derived : base&lt;derived&gt; {
	typedef int mytype;
};
</code></pre>
<p>Тоже не скомпилируется с ошибкой про incomplete type <code>derived</code>. Почему? Ну потому что <code>derived</code> является incomplete типом, когда инстанцируется <code>base&lt;derived&gt;</code>.</p>
<p>В предыдущем примере тот же самый эффект: так как <code>derived</code> шаблонный, то он не инстанцируется сразу, но когда мы инстанцируем <code>derived</code>, то он создаётся как incomplete (complete он станет после подстановки базовых классов), происходит подстановка base и получаем ошибку.</p>
<p>В конексте обсуждённого выше может быть интересно прочитать про идиому <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a>.</p>
<h3><a class="header" href="#Явное-инстанцирование-шаблонов" id="Явное-инстанцирование-шаблонов">Явное инстанцирование шаблонов.</a></h3>
<p>Есть у нас стандартный нерабочий пример:</p>
<pre><code class="language-c++">// string.h
template &lt;class CharT&gt;
struct basic_string {
	// ...
	const CharT* c_str();
	// ...
};
</code></pre>
<pre><code class="language-c++">// string.cpp
#include &quot;string.h&quot;

// ...
template &lt;class CharT&gt;
const CharT* basic_string&lt;T&gt;::c_str() { /*...*/ }
// ...
</code></pre>
<pre><code class="language-c++">// main.cpp
#include &quot;string.h&quot;

int main() {
	basic_string&lt;char&gt; str(&quot;abacaba&quot;);
	const char* c_str = str.c_str();
}
</code></pre>
<p>Мы уже знаем, что этот пример не скомпилируется, и знаем, почему. Но не знаем пока, как его можно поправить. А поправить его можно так:</p>
<pre><code class="language-c++">// string.cpp
#include &quot;string.h&quot;

template const char* basic_string&lt;char&gt;::c_str();

// ...
template &lt;class CharT&gt;
const CharT* basic_string&lt;T&gt;::c_str() { /*...*/ }
// ...
</code></pre>
<p>Это <em>явное инстанцирование шаблона</em>, и является оно командой «прямо тут мне инстанцируйте то, что я попросил».</p>
<h4><a class="header" href="#Подавление-инстанцирования-since-c11" id="Подавление-инстанцирования-since-c11">Подавление инстанцирования (since C++11).</a></h4>
<p>Подавление явного инстанцирования, если знаем, что функции уже где-то инстанцированы и мы не хотим лишних:</p>
<pre><code class="language-c++">extern template void foo&lt;int&gt;(int); 
extern template void foo&lt;float&gt;(float);
</code></pre>
<p>&quot;Выдаём тело наружу и говорим, что уже проинстанцировано, <code>main</code> не будет пытаться инстанцировать функцию, так как увидит <code>extern</code> и будет работать соответствующе.&quot;</p>
<h1><a class="header" href="#type-based-dispatch" id="type-based-dispatch">Type-based dispatch.</a></h1>
<p>Иногда необходимо узнавать какое-то свойство у типа. Если мы пишем обобщённое возведение в степень, нужно спрашивать, что считается единицей. Или если мы пишем операции с числами, хочется взять максимум данного типа. Очень много из такого делает стандартная библиотека: например, есть <code>std::advance</code> — функция, которая делает итератору <code>+=</code>, даже если он так не умеет, а умеет только <code>++</code>. И тут мы либо делаем <code>+=</code>, либо <code>++</code> много раз, в зависимости от типа. Надо спросить, умеет ли итератор в <code>+=</code>.</p>
<h2><a class="header" href="#numeric_limits" id="numeric_limits"><code>&lt;numeric_limits&gt;</code></a></h2>
<p>Самые простые свойства типов — <code>std::numeric_limits</code>. Это шаблонный класс, в который вы даёте численный тип, а он содержит миллион статических полей, которые для данного типа дают информацию о минимуме, максимуме или чём-то ещё.</p>
<h2><a class="header" href="#type_traits" id="type_traits"><code>&lt;type_traits&gt;</code>.</a></h2>
<p>Более сложные запросы к типу можно найти в заголовочном файле <code>&lt;type_traits&gt;</code>, где есть бесконечное количество шаблонных констант: <code>is_trivially_destructible_v</code>, <code>is_empty_v</code>, и прочих других. Какие-то из встроены в компилятор, какие-то вы можете реализовать сами (<code>is_signed_v</code>, например, можете запросто). </p>
<p>Как работают штуки из <code>type_traits</code>? И почему оканчиваются на <code>_v</code>? Дело в том, что до C++14 у вас не было шаблонных переменных (а по сути <code>is_empty_v</code> — шаблонная переменная и есть). Поэтому создали шаблонный класс <code>is_empty</code> со статическим полем <code>value</code>, в котором то, что вам нужно. А когда в С++14 такое появилось, вы смогли писать <code>is_empty_v</code>, и это уже реальная <code>bool</code>'евая константа, которую можно использовать.</p>
<h2><a class="header" href="#Наивный-способ-делать-type-based-dispatch-if-constexpr" id="Наивный-способ-делать-type-based-dispatch-if-constexpr">Наивный способ делать type-based dispatch. <code>if constexpr</code>.</a></h2>
<p>Пример использования <code>&lt;type_traits&gt;</code>: хотим мы вызвать деструкторы всех элементов на отрезке:</p>
<pre><code class="language-c++">#include &lt;type_traits&gt;

template &lt;class T&gt;
void destroy(T* first, T* last) {
	if (!std::is_trivially_destructible_v&lt;T&gt;)
		for (T* p = first, p != last; p++)
			p-&gt;~T();
}
</code></pre>
<p>Работает! Компилятор поймёт, что <code>if</code> можно на этапе компиляции посчитать, и посчитает. Но такое, увы, работает не всегда. Напишем свой <code>std::advance</code>:</p>
<pre><code class="language-c++">#include &lt;type_traits&gt;
#include &lt;iterator_traits&gt;

template &lt;class It&gt;
void advance(It&amp; it, ptrdiff_t n) {
	using category = typename std::iterator_traits&lt;It&gt;::iterator_category;

	// Если итератор — RandomAccess, сделаем ему +=.
	if (std::is_base_of_v&lt;std::random_access_iterator_tag, category&gt;) {
		it += n;
	} else {
	// Если не RandomAccess, сделаем ++ или -- несколько раз.
		while (n &gt; 0) {
			--n;
			++it;
		}
		while (n &lt; 0) {
			++n;
			--it;
		}
	}
}
</code></pre>
<p>Проблема тут очевидная — компилируются всё равно обе ветки, и первая не компилируется для <code>std::list&lt;T&gt;::iterator</code>, потому что он не умеет в <code>+=</code>. В C++17 есть простое решение этой проблемы: <strong><code>if constexpr</code> — работает как <code>if</code>, но только с compile-time константами, и при этом компилируется только нужная ветка</strong>. Но так сделать у вас есть возможность не всегда.</p>
<h2><a class="header" href="#iterator-dispatch" id="iterator-dispatch">Iterator dispatch.</a></h2>
<p>А давайте вот как схитрим:</p>
<pre><code class="language-c++">#include &lt;iterator_traits&gt;

template &lt;class It&gt;
void advance_impl(It&amp; it, ptrdiff_t n, std::random_access_iterator_tag) {
	it += n;
}

template &lt;class It&gt;
void advance_impl(It&amp; it, ptrdiff_t n, std::input_iterator_tag) {
	while (n &gt; 0) {
		--n;
		++it;
	}
	while (n &lt; 0) {
		++n;
		--it;
	}
}

template &lt;class It&gt;
void advance(It&amp; it, ptrdiff_t n) {
	using category = typename std::iterator_traits&lt;It&gt;::iterator_category;
	advance_impl(it, n, category());
}
</code></pre>
<p>То есть мы передаём лишний параметр — одну их двух пустых структур, в зависимости от которой выбирается правильная перегрузка. Это называется <em>iterator dispatch</em>, и работает также хорошо, как и <code>if constexpr</code>, несмотря на передачу
лишнего параметра (поскольку параметр — пустая структура, его в реальной жизни никто никуда не передаёт).</p>
<h3><a class="header" href="#tag-dispatch" id="tag-dispatch">Tag dispatch.</a></h3>
<p>Хорошо, что у итераторов есть теги. А что делать, если тегов нет (например, в массовом деструкторе)? Тогда их можно разве что самим создать:</p>
<pre><code class="language-c++">struct trivially_destructible_tag {};
struct not_trivially_destructible_tag {};

template &lt;class T&gt;
void destroy_impl(T* first, T* last, trivially_destructible_tag) {}
template &lt;class T&gt;
void destroy_impl(T* first, T* last, not_trivially_destructible_tag) {
	if (!std::is_trivially_destructible_v&lt;T&gt;)
		for (T* p = first; p != last; p++)
			p-&gt;~T();
}

template &lt;class T&gt;
void destroy(T* first, T* last) {
	// Хочется как-то выбрать одну структуру-тег из двух на этапе компиляции.
}
</code></pre>
<p>Как выбрать одну структуру из двух на этапе компиляции? Да тривиально вообще:</p>
<pre><code class="language-c++">template &lt;bool Cond, typename IfTrue, typename IfFalse&gt;
struct conditional {
	using type = IfFalse;
};
template &lt;typename IfTrue, typename IfFalse&gt;
struct conditional&lt;true, IfTrue, IfFalse&gt; {
	using type = IfTrue;
};

template &lt;class T&gt;
void destroy(T* first, T* last) {
	using tag = typename conditional&lt;is_trivially_destructible_v&lt;T&gt;,
		                            trivially_destructible_tag,
		                            not_trivially_destructible_tag&gt;::type;

	destroy_impl(first, last, tag());
}
</code></pre>
<p>такое уже есть, и называется <code>std::conditional</code>. А <code>typename std::conditional&lt;/*...*/&gt;::type</code> также сокращается до <code>std::conditional_t</code>. . Итого наш пример выглядит так:</p>
<pre><code class="language-c++">#include &lt;type_traits&gt;

struct trivially_destructible_tag {};
struct not_trivially_destructible_tag {};

template &lt;class T&gt;
void destroy_impl(T* first, T* last, trivially_destructible_tag) {}
template &lt;class T&gt;
void destroy_impl(T* first, T* last, not_trivially_destructible_tag) {
	if (!std::is_trivially_destructible_v&lt;T&gt;)
		for (T* p = first; p != last; p++)
			p-&gt;~T();
}

template &lt;class T&gt;
void destroy(T* first, T* last) {
	using tag = std::conditional_t&lt;is_trivially_destructible_v&lt;T&gt;,
	                               trivially_destructible_tag,
	                               not_trivially_destructible_tag&gt;;

	destroy_impl(first, last, tag());
}
</code></pre>
<p>Такая техника называется <em>tag-dispatching</em>, и она, несомненно, работает. Но есть у неё крупная проблема: когда у нас функции были как перегрузки, мы могли свободно добавлять в список перегрузок новые классы с новыми свойствами. А когда мы делаем это <code>if</code>'ами (хоть <code>if constexpr</code>, хоть <code>std::conditional_t</code>), новые классы с новыми свойствами не добавить.</p>
<h2><a class="header" href="#sfinae" id="sfinae">SFINAE.</a></h2>
<p>Есть другой способ сделать похожее, основанный на поведении компилятора при выведении шаблона:</p>
<pre><code class="language-c++">template &lt;typename C&gt;
void foo(C&amp;, typename C::iterator); // 1.

template &lt;typename T, size_t N&gt;
void foo(T (&amp;)[N], T*);             // 2.

int main() {
  std::vector&lt;int&gt; v;
  foo(v, v.begin());
  
  int w[10];
  foo(w, w + 2);
}
</code></pre>
<p>С виду всё хорошо, но давайте разберём, как работает компилятор на таком коде. Сначала производится вывод параметра, а потом — подстановка. В коде выше он видит, что <code>v</code> - это <code>vector&amp;</code>, а параметр - <code>C&amp;</code>, поэтому <code>C</code> — это <code>vector</code>. Он как бы декомпозирует типы и запускается от частей, а когда доходит до шаблонных параметров, понимает, какой тип здесь имелся в виду.</p>
<p>Из dependent имён выводить не можем:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct mytype {
  typedef T type;
};
template &lt;&gt;
struct mytype&lt;int&gt; {
  typedef char type;
};
template &lt;typename T&gt;
void bar(typename mytype&lt;T&gt;::type);
</code></pre>
<p>Сложность возникла из-за специализаций. Если приходит <code>char</code>, то из такого не понятно, откуда он пришёл (могло из <code>mytype&lt;int&gt;</code>, а могло из <code>mytype&lt;char&gt;</code>), поэтому <em>deduction</em> не пытается выводить.</p>
<p>Вернёмся к первому примеру. У нас есть два вызова: от <code>std::vector</code> и от C-шного массива. Рассмотрим, что с ними делает компилятор.</p>
<ol>
<li>Когда мы подставляем <code>vector</code>, первый шаблон не имеет проблем, а во втором даже параметры шаблона вывести не получается.</li>
<li>Когда мы подставляем <code>int[10]</code>, в первом шаблоне вывести <code>C</code> получается (<code>C</code> равно <code>int[10]</code>), но возникает ошибка при подстановке — нельзя сделать <code>int[10]::iterator</code>.</li>
</ol>
<p>Но в обоих случаях мы не получаем ошибку компиляции, и дело тут в принципе <em>SFINAE</em> — <em>substitution failure is not an error</em>: <strong>если в процессе вывода или подстановки шаблона произошла ошибка, это не ошибка компиляции, просто данный шаблон не подходит</strong>.</p>
<h3><a class="header" href="#stdenable_if" id="stdenable_if"><code>std::enable_if</code>.</a></h3>
<p>Теперь, вооружившись SFINAE, сделаем так, чтобы наш <code>destroy</code> работал без <code>if</code>'ов:</p>
<pre><code class="language-c++">template &lt;bool&gt;
struct enable_if {};
template &lt;&gt;
struct enable_if&lt;true&gt; {
	using type = void;
};

template &lt;class T&gt;
typename enable_if&lt;std::is_trivially_destructible_v&lt;T&gt;&gt;::type // Это возвращаемое значение.
destroy(T* first, T* last) {}
template &lt;class T&gt;
typename enable_if&lt;!std::is_trivially_destructible_v&lt;T&gt;&gt;::type
destroy(T* first, T* last) {
	if (!std::is_trivially_destructible_v&lt;T&gt;)
		for (T* p = first, p != last; p++)
			p-&gt;~T();
}
</code></pre>
<p>Опять же, подобная штука в стандартной библиотеке есть, и называется <code>std::enable_if</code>. Для <code>typename enable_if&lt;/*...*/&gt;::type</code> также создана короткая версия: <code>std::enable_if_t</code>.</p>
<p>На практике SFINAE применимо где-нибудь в таком месте:</p>
<pre><code class="language-c++">template &lt;class T&gt;
struct vector {
	void assign(size_t count, T const&amp; value);

	template &lt;class InputIt&gt;
	void assign(InputIt first, InputIt last);
};

int main() {
	vector&lt;size_t&gt; v;
	v.assign(10, 0); // Выбирается шаблонная перегрузка.
}
</code></pre>
<p>Исправляется вот так:</p>
<pre><code class="language-c++">#include &lt;iterator_traits&gt;
#include &lt;type_traits&gt;

template &lt;class T&gt;
struct vector {
	void assign(size_t count, T const&amp; value);

	template &lt;class InputIt&gt;
	std::enable_if_t&lt;
		std::is_base_of_v&lt;
			std::input_iterator_tag,
			std::iterator_traits&lt;InputIt&gt;::category
		&gt;
	&gt; assign(InputIt first, InputIt last);
};

int main() {
	vector&lt;size_t&gt; v;
	v.assign(10, 0);
}
</code></pre>
<h2><a class="header" href="#Пара-слов-о-концептах" id="Пара-слов-о-концептах">Пара слов о концептах.</a></h2>
<p>SFINAE — это длинно и неудобно, как можно было заметить. И если вам очень не нравится, в C++20 есть <a href="./28_concepts.html">концепты</a>. Пример выше с их использованием вообще пишется на ура:</p>
<pre><code class="language-c++">#include &lt;iterator&gt;
template &lt;class T&gt;
struct vector {
	void assign(size_t count, T const&amp; value);

	template &lt;std::input_iterator InputIt&gt;
	void assign(InputIt first, InputIt last);

	/* Также можно вот так:
	template &lt;class InputIt&gt;
		requires std::input_iterator&lt;InputIt&gt;
	void assign(InputIt first, InputIt last);

	После requires можно и что-то более сложное писать. */
};

int main() {
	vector&lt;size_t&gt; v;
	v.assign(10, 0);
}
</code></pre>
<p>У концептов есть ещё одно преимущество, помимо размера. Когда мы пользуемся SFINAE, нам необходимо перебрать все случаи перегрузок. Если вы в <code>destroy</code> написали перегрузку под <code>std::trivially_destructible</code>, напишите под <code>!std::trivially_destructible</code>. А если вы хотите расширять, будьте добры изменить предикаты. А <strong>концепты умеют понимать, что один концепт расширяет другой</strong>, как с шаблонами. И выбирать наиболее специализированный вариант.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="13_tools.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="15_stl.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="13_tools.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="15_stl.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
