<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Наследование (в т.ч. виртуальное), виртуальные функции - C++ course notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li class="chapter-item expanded "><a href="07_inheritance.html" class="active"><strong aria-hidden="true">8.</strong> Наследование (в т.ч. виртуальное), виртуальные функции</a></li><li class="chapter-item expanded "><a href="08_exceptions.html"><strong aria-hidden="true">9.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li class="chapter-item expanded "><a href="09_allocations_optimizations.html"><strong aria-hidden="true">10.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации</a></li><li class="chapter-item expanded "><a href="10_libraries.html"><strong aria-hidden="true">11.</strong> Статические и динамические библиотеки</a></li><li class="chapter-item expanded "><a href="11_undefined_behaviour.html"><strong aria-hidden="true">12.</strong> Undefined behaviour: примеры и способы его понимать</a></li><li class="chapter-item expanded "><a href="12_validation.html"><strong aria-hidden="true">13.</strong> Способы валидации программы</a></li><li class="chapter-item expanded "><a href="13_tools.html"><strong aria-hidden="true">14.</strong> Полезные инструменты, которые пригодятся вам в жизни</a></li><li class="chapter-item expanded "><a href="14_templates.html"><strong aria-hidden="true">15.</strong> Шаблоны (templates), tag-dispatching, SFINAE</a></li><li class="chapter-item expanded "><a href="15_stl.html"><strong aria-hidden="true">16.</strong> Обзор STL</a></li><li class="chapter-item expanded "><a href="16_namespaces_using_adl.html"><strong aria-hidden="true">17.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li class="chapter-item expanded "><a href="17_move_rvalue.html"><strong aria-hidden="true">18.</strong> Move-семантика, rvalue-ссылки</a></li><li class="chapter-item expanded "><a href="18_intrusive_containers.html"><strong aria-hidden="true">19.</strong> Интрузивные контейнеры</a></li><li class="chapter-item expanded "><a href="19_smart_pointers.html"><strong aria-hidden="true">20.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li class="chapter-item expanded "><a href="20_perfect_forwarding.html"><strong aria-hidden="true">21.</strong> Perfect forwarding, variadic templates</a></li><li class="chapter-item expanded "><a href="21_decltype_auto_nullptr.html"><strong aria-hidden="true">22.</strong> Decltype, declval, auto, nullptr</a></li><li class="chapter-item expanded "><a href="22_lambdas_type_erasure.html"><strong aria-hidden="true">23.</strong> Анонимные функции, type erasure, std::function</a></li><li class="chapter-item expanded "><a href="23_signals_reetrancy_errors.html"><strong aria-hidden="true">24.</strong> Сигналы, reetrancy, обработки ошибок</a></li><li class="chapter-item expanded "><a href="24_optional_variant_tuple_stringview.html"><strong aria-hidden="true">25.</strong> Optional, variant, tuple, string_view</a></li><li class="chapter-item expanded "><a href="25_constexpr.html"><strong aria-hidden="true">26.</strong> Статическая и динамическая инициализация, constexpr</a></li><li class="chapter-item expanded "><a href="26_multithreading.html"><strong aria-hidden="true">27.</strong> Многопоточность</a></li><li class="chapter-item expanded "><a href="27_qt.html"><strong aria-hidden="true">28.</strong> Qt</a></li><li class="chapter-item expanded "><a href="28_concepts.html"><strong aria-hidden="true">29.</strong> Концепты</a></li><li class="chapter-item expanded "><a href="29_ranges.html"><strong aria-hidden="true">30.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="30_encoding.html"><strong aria-hidden="true">31.</strong> Кодировки</a></li><li class="chapter-item expanded "><a href="31_coroutines.html"><strong aria-hidden="true">32.</strong> Корутины</a></li><li class="chapter-item expanded "><a href="32_modules.html"><strong aria-hidden="true">33.</strong> Модули</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">C++ course notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/cpp-kt/cpp-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Дисклеймер" id="Дисклеймер">Дисклеймер.</a></h1>
<p>Год от года темы этого раздела тасуются как попало. Я попытался их разбить логически (так, чтобы всё, имеющее отношение к виртуальным функциям, не было разделено на части, например), так что не удивляйтесь, если в вашем курсе темы будут в другом порядке разложены.</p>
<h1><a class="header" href="#Наследование-и-виртуальные-функции" id="Наследование-и-виртуальные-функции">Наследование и виртуальные функции</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=IcAaaX888xc">Запись лекции №1</a></li>
<li><a href="https://www.youtube.com/watch?v=11MKhMYAmnE">Запись лекции №2</a></li>
<li><a href="https://www.youtube.com/watch?v=oMkF60mU8ig">Запись лекции №3</a></li>
<li><a href="https://www.youtube.com/watch?v=0-92_jC7YMU">Запись лекции №4</a></li>
</ul>
<hr />
<p>В курсе предполагается, что что-то о наследовании вы знаете и примерно представляете, что это такое. Оно было в курсе Java, и это первая причина, почему мы не будем обсуждать всё в мельчайших деталях. Вторая — потому что в книжках оно обсасывается очень подробно.</p>
<p>Про наследование сложно говорить в том же ключе, в котором мы говорили/будем говорить об исключениях, шаблонах и т.п. Исключения и шаблоны решают конкретные задачи, а для наследования таковой нет. Поэтому на эту тему мы будем смотреть иначе: есть механизм, а на кой он нужен?</p>
<h2><a class="header" href="#lore" id="lore">Lore.</a></h2>
<p>Немного введения. Откуда идёт наследование? Если мы решаем задачу о моделировании дорожной сети, то первый порыв души — сопоставить объектам предметной области объекты нашей программы. Таким образом у нас очень естественно получается полиморфизм — у нас есть произвольные транспортные средства, которые очень похожи, а есть автобусы, трамваи и подобное, то есть более специализированные штуки.</p>
<p>Это не столько способ организации программы, сколько образ мысли. Причём полезный: мы можем начать декомпозировать задачу, даже не зная её решения. И, кстати, совсем необязательно объекту реальности сопоставлять объект программы, это может быть неэффективно — если мы решаем задачу о минимизации чего-то (за минимальные деньги перестроить дорогу так что...), то совершенно необязательно у вас будут такие же объекты.</p>
<p>А ещё бывает ситуация, когда вы придумываете движок регулярных выражений — никакие структуры из внешнего мира не приходят, вы делаете что-то, не имеющее отношения к реальности. И реальные программы где-то посередине: часть из реального мира, часть к нему не имеет отношения.</p>
<h2><a class="header" href="#Итак-наследование" id="Итак-наследование">Итак, наследование.</a></h2>
<pre><code class="language-c++">struct vehicle {
	std::string registration_number;
};
struct bus : vehicle {	// Наследуется от `vehicle`.
	int32_t route_number;
	std::string next_stop() const;
};
struct truck : vehicle {
	double cargo_mass;
};
int main() {
	bus b;
	vehicle&amp; v = b;                // Можно делать так.
	v.registration_number = &quot;123&quot;; // Обращение к полям базового класса.
}
</code></pre>
<!--
void f(vehicle& v){
	v.print_name(); // выведет vehicle, так как статический тип vehicle и при компиляции f подставляется вызов print_name от базового класса
}
Об этом чуть позже. есть.
-->
<p><code>bus</code> содержит и <code>route_number</code>, и <code>registration_number</code>.
Когда вы обращаетесь к какому-то полю или методу, компилятор сначала ищет его внутри вашего класса, а если не находит — идёт в базовый. Поэтому если у базового и наследуемого класса есть поле с одним именем, обращение к нему вернём поле последнего. Если наследоваться от двух классов (в C++ есть множественное наследование), и в двух базовых есть поле/метод с одинаковым названием, а в наследнике нет, то будет ошибка компиляции при обращении от объекта наследника.</p>
<p>Если поля классов совпадают в названии, то обратиться к полю другого можно так:</p>
<pre><code class="language-c++">struct base {
	int xyz; // 1.
};
struct derived : base {
	int xyz; // 2.
};
int main() {
	derived d;
	d.xyz = 123; // Изменяется 2.
	((base&amp;)d).xyz = 123; // Изменяется 1.
	d.base::xyz = 123; // Специальный синтаксис для изменения 1.
}
</code></pre>
<p>Как можно видеть из примера, класс можно приводить к любому его базовому по ссылке. Указатель на наследуемый класс можно приводить к указателю на базовый.</p>
<p>С методами в наследовании работают точно так же, как и с полями:</p>
<pre><code class="language-c++">struct base {
	void g() {} // 1.
};
struct derived : base {
	void g() {} // 2.
};
int main() {
	derived d;
	d.g();       // Запуск 2.
	d.base::g(); // Запуск 1.
}
</code></pre>
<p>При создании объектов класса-наследника вызывается конструктор базового класса по умолчанию (в котором, если тот тоже от кого-то наследуется, вызывается конструктор его базы). Если нужно вызывать другой конструктор, используйте списки инициализации:</p>
<pre><code class="language-c++">struct bus : vehicle {
	bus(std::string const&amp; registration_number, std::string const&amp; next_stop_name) 
		: vehicle(registration_number), next_stop_name(next_stop_name){}
};
</code></pre>
<p>При этом стандарт определяет следующий порядок инициализации (<a href="https://en.cppreference.com/w/cpp/language/constructor">перевод с cppreference</a>):</p>
<ul>
<li>Инициализируются виртуальные базовые классы (про них будет <a href="#%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">потом</a>) в порядке обхода в глубину. Внутри одного класса инициализация баз происходит в том порядке, в котором вы их написали (слева направо).</li>
<li>Инициализируются прямые базовые классы тоже слева направо.<br />
То есть если вы написали <code>class C : B, A</code>, то сначала инициализируется <code>B</code>, а потом — <code>A</code>.</li>
<li>Инициализируются нестатические члены класса в порядке их объявления.</li>
</ul>
<h2><a class="header" href="#worst-practices" id="worst-practices">Worst practices.</a></h2>
<p>Во-первых, <strong>не надо наследоваться, если вам нужно только расширить класс</strong>. Если вы хотите добавить новый функционал в <code>std::string</code>, не нужно от него наследоваться, а то ваш коллега тоже захочет по-другому её расширить, и вы получите два новых типа, а потом не сможете вызывать функции друг друга. Лучше создайте обычную функцию. Обычные функции — это хорошо, не надо писать всё классами.</p>
<p>Во-вторых, <strong>не надо создавать отдельный класс под одну операцию</strong>:</p>
<pre><code class="language-c++">struct string_printer {
private:
	std::string msg;
public:
	string_printer(const std::string&amp; msg)
		: msg(msg) {
	}
	void print() {
		std::cout &lt;&lt; msg;
	}
};
</code></pre>
<p>Помимо того, что этот код и так выглядит как странное дизайнерское решение, у него есть вторая проблема — вот сделали вы <code>string_printer(&quot;Hello, world&quot;).print()</code>. А что если вы не сделаете <code>print</code>, или сделаете дважды? Потому что напечатать-то вы можете и в конструкторе, зачем вам метод? Не интуитивно.</p>
<p>Мораль: не заводите класс, если вам нужно сделать действие. Исключение — какие-нибудь компараторы, которые в общем случае могут быть полноценными классами, но вообще могут являться и обёрткой вокруг функции. И вот тут ничего не поделаешь, <code>std::map</code> принимает класс, а не функцию.</p>
<h2><a class="header" href="#slicing" id="slicing">Slicing.</a></h2>
<p>Рассмотрим пример.</p>
<pre><code class="language-с++">struct base
{
	virtual std::string get_name() const
	{
		return &quot;base&quot;;
	}
};

struct derived : base
{
	std::string get_name() const override
	{
		return &quot;derived&quot;;
	}
};

int main()
{
	derived d;
	base&amp; b = d;
	b.get_name(); // --&gt; &quot;derived&quot;
}
</code></pre>
<p>Тут всё хорошо. А теперь представим, что в <code>main</code>'е забыли поставить <code>&amp;</code>:</p>
<pre><code class="language-с++">int main()
{
	derived d;
	base b = d;
	b.get_name(); // --&gt; &quot;base&quot; !!!
}
</code></pre>
<p>Что это всё значит?</p>
<p>Заметим, что эти два примера совсем разные: в первом создаётся ровно один объект и этот объект имеет тип <code>derived</code>.
Во втором же случае у нас два разных объекта. Один типа <code>derived</code>, а другой типа <code>base</code>. Причём у второго объекта <code>base</code> — это и статический, и динамический тип. Так что логично, что выводится &quot;base&quot;.</p>
<p>А почему <code>base b = d;</code> — не ошибка компиляции?</p>
<p>На самом деле внутри <code>base</code> компилятор сгенерировал конструктор копирования.
И на самом деле у нас написано такое:</p>
<p><code>base b(static_cast&lt;base const&amp;&gt;(d));</code></p>
<p>Так что тут у нас просто скопировались мемберы <code>base</code>'а, а мемберы <code>derived</code>'а потерялись.
Это называется <strong>Object slicing</strong>.
Как избежать непреднамеренного <em>slicing</em>'а?</p>
<p>Если для класса копирование не имеет смысла, то это стоит явно запретить:</p>
<pre><code class="language-с++">base(base const&amp; other) = delete;
base&amp; operator=(base const&amp; other) = delete;
</code></pre>
<p>Тогда случайного <em>slicing</em>'а не случится.</p>
<p>Кстати, у <code>derived</code>'а удалять эти функции уже не обязательно, они не сгенерятся, если у <code>base</code>'а удалены.</p>
<p>Вообще, часто копирование базового типа действительно не имеет смысла: в примере с <code>vehicle</code>, <code>car</code> и <code>bus</code> не совсем понятно, что мы хотим сделать, копируя <code>vehicle</code>. Мы скопировали какой-то абстрактый <code>vehicle</code>, зачем нам это?</p>
<h2><a class="header" href="#Виртуальные-функции" id="Виртуальные-функции">Виртуальные функции.</a></h2>
<!--
Когда без наследования не обойтись? Чаще всего его используют вместе с такими конструкциями, как виртуальные функции.

Честно говоря, обойтись, виртуальные функции не так и сложно руками пишутся.
-->
<!--
Реализованы они через так называемую таблицу виртуальных функций.

Воу-воу, спойлеры. Это потом.
-->
<p>Виртуальные функции — главное (если не единственное), для чего вам нужно наследование.</p>
<p>Мы уже рассматривали код</p>
<pre><code class="language-c++">struct vehicle {
	void print() {
		std::cout &lt;&lt; &quot;vehicle&quot; &lt;&lt; std::endl;
	}
};
struct bus : vehicle {
	void print() {
		std::cout &lt;&lt; &quot;bus&quot; &lt;&lt; std::endl;
	}
};
struct truck : vehicle {};

int main() {
	vehicle v;
	v.print(); // &quot;vehicle&quot;.
	bus b;
	b.print(); // &quot;bus&quot;.
	truck t;
	t.print(); // &quot;vehicle&quot;.
}
</code></pre>
<p>При этом если мы напишем функцию</p>
<pre><code class="language-c++">void foo(vehicle&amp; v) {
	v.print();
}
</code></pre>
<p>То даже если передать в неё <code>bus</code>, она выведет <code>&quot;vehicle&quot;</code>. Думаю, никому не надо объяснять, почему. Потому введём пару определений, а после поясним, как поправить код.</p>
<p><em>Статический тип</em> — это тип объекта, который в программе написан. И у всего, что приходит в функцию <code>foo</code> статический тип <code>vehicle</code> (вообще <code>vehicle&amp;</code>, но не суть).<br />
<em>Динамический тип</em> — то, чем ваш объект был создан и по сути является. Так, ваш <code>vehicle</code> может являться <code>bus</code>'ом или <code>truck</code>'ом.</p>
<p>Так вот, <strong>виртуальные функции позволяют выбирать метод исходя из динамического типа</strong>, а не статического:</p>
<pre><code class="language-c++">struct vehicle {
	virtual void print() {
		std::cout &lt;&lt; &quot;vehicle&quot; &lt;&lt; std::endl;
	}
};
struct bus : vehicle {
	void print() {
		std::cout &lt;&lt; &quot;bus&quot; &lt;&lt; std::endl;
	}
};
struct truck : vehicle {};

int main() {
	vehicle v;
	foo(v); // &quot;vehicle&quot;
	bus b;
	foo(b); // &quot;bus&quot;
	truck t;
	foo(t); // &quot;vehicle&quot;
}
</code></pre>
<p>Кстати, если у базового класса, функция виртуальная, то у производных тоже <code>virtual</code>.</p>
<p>Когда вы подобным образом подменяете виртуальную функцию, говорят, что <code>bus::print</code> <em>override</em>'ит <code>vehicle::print</code>.</p>
<h3><a class="header" href="#Виртуальный-деструктор" id="Виртуальный-деструктор">Виртуальный деструктор.</a></h3>
<pre><code class="language-c++">int main() {
	bus* b = new bus();
	vehicle* v = b;
	v-&gt;print();
	delete v;
}
</code></pre>
<p>Тут вызывается <code>v-&gt;~vehicle</code>. А если <code>bus</code> имеет какой-то нетривиальный деструктор, он не вызовется. Поэтому тут вам всё так же надо вызывать деструктор в зависимости от динамического типа, а не статического.</p>
<pre><code class="language-c++">struct vehicle {
	virtual ~vehicle() {}
};
</code></pre>
<p>С точки зрения языка, <strong>вы не имеете права делать <code>delete</code> у базового класса, есть создали наследуемый и не пометили деструктор базового как <code>virtual</code></strong>. Если будете так делать — UB. <a href="#%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"><strong>Даже если все деструкторы тривиальные.</strong></a></p>
<h3><a class="header" href="#Виртуальные-функции-и-параметры-по-умолчанию" id="Виртуальные-функции-и-параметры-по-умолчанию">Виртуальные функции и параметры по умолчанию.</a></h3>
<p><strong>Параметры по умолчанию являются частью декларации, поэтому соответствуют статическому типу</strong>, даже если указать другие в наследнике:</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;iostream&gt;

struct vehicle {
	virtual void print_name(std::string prefix = &quot;Base: &quot;){
		std::cout &lt;&lt; prefix &lt;&lt; &quot;vehicle&quot; &lt;&lt; std::endl;
	}
};
struct bus : vehicle {
	void print_name(std::string prefix = &quot;Derived: &quot;){
		std::cout &lt;&lt; prefix &lt;&lt; &quot;bus&quot; &lt;&lt; std::endl;
	}
};
void foo(vehicle&amp; t){
	t.print_name();
}
int main() {
	bus b;
	b.print_name(); // Derived: bus
	foo(b);	// Base: bus
}
</code></pre>
<h3><a class="header" href="#Как-полиморфизм-устроен-изнутри" id="Как-полиморфизм-устроен-изнутри">Как полиморфизм устроен изнутри.</a></h3>
<p>Как бы мы сделали полиморфизм руками, если бы у нас его не было? Ну, через указатели на функции. По-другому не получится, потому что мы не знаем список всех наших
наследников:</p>
<pre><code class="language-c++">struct base {
	base();
	void (*foo)(base*);
	void (*bar)(base*, int);
	void (*baz)(base*, double);
};
void foo_base(base* self) {
	// ...
}
void bar_base(base* self, int x) {
	// ...
}
void baz_base(base* self, double y) {
	// ...
}
base::base()
	: foo(foo_base), bar(bar_base), baz(baz_base) {}

struct derived : base {
	derived();
};
void foo_derived(base* self) {
	derived* derived_self = static_cast&lt;derived*&gt;(self);
	// ...
}
void bar_derived(base* self, int x) {
	derived* derived_self = static_cast&lt;derived*&gt;(self);
	// ...
}
void baz_derived(base* self, double y) {
	derived* derived_self = static_cast&lt;derived*&gt;(self);
	// ...
}
derived::derived()
	: foo(foo_derived), bar(bar_derived), baz(baz_derived) {}

int main() {
	derived d;
	d.bar(&amp;d, 42);
}
</code></pre>
<p>Так в целом можно, но можно и чуть оптимальнее. У нас наши тройки функций не могут комбинироваться как им вздумается, всегда либо все из <code>base</code>, либо все из <code>derived</code>. И к тому же, нам не хочется с каждой новой функцией увеличивать размер структуры. Поэтому есть такая штука как <em>таблица виртуальных функций</em>. Это мы берём наши 3 указателя и выносим их в особый объект, указатель на который помещается в нашу структуру. А такие структуры создаем под каждый класс глобальными переменными. Это даёт нам ещё один indirection, но сокращает размер структур. И именно так это и работает во всех компиляторах. Во множественном наследовании у класса просто появляются две таблицы, под каждый базовый класс своя.</p>
<h3><a class="header" href="#Абстрактные-методы-и-классы" id="Абстрактные-методы-и-классы">Абстрактные методы (и классы):</a></h3>
<p>Вот создали вы, скажем, устройство вывода. И отнаследовались из него, создав устройство, которое пишет в одно место, в другое место и т.д. Возникает вопрос: а что должно делать базовое устройство? Ну, непонятно. Ничего путного. Для этого есть механизм <em>чисто виртуальных</em> (<em>абстрактных</em>) функций — пометить, что этой функции не существует:</p>
<pre><code class="language-c++">struct output_device {
	virtual void write(void const* data, size_t size) = 0;
};
struct speakers : output_device {};
struct twitch_stream : output_device {};
struct null_output : output_device {};
</code></pre>
<p>Чисто виртуальную функцию нельзя вызвать. И <strong>нельзя создать экземпляр класса, содержащего чисто виртуальную функцию</strong>.</p>
<p>Но есть проблема:</p>
<pre><code class="language-c++">struct base {
	base() {
		foo();
	}
	void foo() {
		bar();
	}
	virtual void bar() = 0;
};
struct derived : base {
	void bar() {};
};
</code></pre>
<p>Тут, когда вы создадите <code>derived</code>, вам на этапе исполнения скажут, что вы вызываете чисто виртуальную функцию. Почему?</p>
<p>А вот смотрите. Когда вы конструируете <code>derived</code>, сначала вызывается конструктор <code>base</code>, а только потом присваивается указатель на таблицу виртуальных функций. То есть <strong>когда вызывается конструктор объекта, он не сразу с правильным динамическим типом, а изменяется по чуть-чуть</strong>: сначала он базовый, а потом нормальный. Когда иерархия больше, динамический тип меняется большее количество раз.
Поэтому в конструкторе <code>base::base</code> <code>bar</code> — это функция без тела. </p>
<p>А ещё этот пример не компилируется без прослойки вида <code>foo</code>. Почему так? А вот смотрите. Никто вам не мешает вызвать виртуальную функцию напрямую (обращения к таблице) так: <code>base::foo</code>. А если вы вызываете функцию в конструкторе и деструкторе, то вы точно знаете, ваш динамический тип. Поэтому, написав код</p>
<pre><code class="language-c++">struct base {
	base() {
		bar();
	}
	virtual void bar() = 0;
};
struct derived : base {
	void bar() {};
};
</code></pre>
<p>Вы получите ошибку компиляции, потому что в <code>base::base</code> происходит вызов <code>base::bar</code>, а не просто <code>bar</code>, а значит мы явно вызываем виртуальную функцию.</p>
<h2><a class="header" href="#Множественное-наследование" id="Множественное-наследование">Множественное наследование.</a></h2>
<p>Начнём с того, почему некорректно делать <code>delete</code> указателю на базовый класс, если все деструкторы тривиальные, но не виртуальные:</p>
<pre><code class="language-c++">struct base1 {
	int x;
};
struct base2 {
	int y;
};
struct derived : base1, base2 {};
int main() {
	derived* d = new derived;
	base2* b2 = d;
	delete b2;
}
</code></pre>
<p>Потому что первый базовый класс лежит по тому же адресу, что и оригинальный класс, а второй — со смещением. Поэтому его удалить нельзя, вы освобождаете память не по тому
указателю. А виртуальный деструктор вас спасёт.</p>
<p>Ещё про множественное наследование нужно сказать вот что:</p>
<pre><code class="language-c++">struct base2;
struct derived;

base2&amp; to_base2(derived&amp; d) {
	return (base2&amp;)d;
}
struct base1 {
	int x;
	base1(int x) : x(x) {}
};
struct base2 {
	int y;
	base2(int y) : y(y) {}
};
struct derived : base1, base2
{
	derived(int x, int y)
		: base1(x), base2(y) {}
};

int main() {
	derived d(1, 2);
	std::cout &lt;&lt; to_base2(d).y &lt;&lt; std::endl; // Выводится 1.
}
</code></pre>
<p>Почему? А вот почему. Когда мы пишем <code>to_base2</code>, мы ещё не знаем, что один класс наследуется от другого, причём так, что ещё и указатели надо двигать. Он будет их двигать, если написать <code>to_base2</code> после классов, а так нет. Поэтому в C++ не надо использовать каст из C, вместо него есть 4 новых.</p>
<h2><a class="header" href="#Приведение-типов-cast" id="Приведение-типов-cast">Приведение типов (cast).</a></h2>
<p>Пример выше правится так:</p>
<pre><code class="language-c++">base2&amp; to_base2(derived&amp; d) {
	return static_cast&lt;base2&amp;&gt;(d);
}
</code></pre>
<p>Если это будет написано в том же месте, то словим ошибку компиляции, а если после определения <code>derived</code>, то проблем не будет.</p>
<p>Итак, <code>cast</code>'ы:</p>
<ul>
<li>
<p><code>static_cast</code> — то, что нам нужно в $99%$ случаев. Кастует</p>
<ul>
<li>Числа друг в друга.</li>
<li>Ссылки и указатели по иерархии наследования в любую сторону.</li>
<li><code>void*</code> в любой указатель и обратно.</li>
</ul>
<p>При этом, понятно, кастовать <code>void*</code> куда-то корректно можно, если там изначально было то, куда вы кастуете.</p>
<p>Аналогично, <em>вниз по иерархии</em> (от базового к наследуемому) можно кастовать только тогда, когда совпадает динамический тип. Иначе UB.</p>
</li>
<li>
<p><code>reinterpret_cast</code> — всё зашкварное из C-style cast'а. Перевод указателей несвязанных друг с другом типов, указателей в число и обратно. Простой и эффективный способ получить UB. В стандарте так и написано, это implementation-defined cast. Обратитесь к поставщику вашего компилятора, чтобы понять, как у вас работает <code>reinterpret_cast</code>.</p>
</li>
<li>
<p><code>const_cast</code>. Снимает модификаторы <code>const</code> и <code>volatile</code>. Чаще всего это делать не надо, но иногда бывает нужно всё-таки. В стародавние времена, когда <code>const</code>'ов не было, были функции, принимавшие указатель. Неконстантный, хотя не меняли его содержимое. И вот если вы хотите использовать эту функцию, вы можете снять <code>const</code> с указателя. А вообще правило вот какое: <strong>если изначальный объект был <code>const</code>, снимать с него <code>const</code> ни в коем случае нельзя (UB). Если изначальный объект константным не был, а потом вы сначала навесили <code>const</code>, а потом сняли, то всё хорошо</strong>.</p>
</li>
<li>
<p><code>dynamic_cast</code>. Немного другое, нежели все остальные касты. Работает для указателей и ссылок <strong>на полиморфные (хотя бы одна виртуальная функция) типы</strong>. Кастует по иерархии вниз (это, напомню, от базового к наследуемому), но, в отличие от <code>static_cast</code>'а, проверяет, что преобразование корректно. Если некорректно, возвращает <code>nullptr</code> в случае
указателей, кидает <a href="./08_exceptions.html">исключение</a> <code>std::bad_cast</code> в случае ссылок. Работает это при помощи RTTI:</p>
</li>
</ul>
<h3><a class="header" href="#rtti-typeid" id="rtti-typeid">RTTI. <code>typeid</code>.</a></h3>
<p>В таблицах виртуальных функций может храниться нечто другое, не только указатели на функции. В частности, в них хранится такая штука как <em>RTTI</em> — <em>runtime type information</em>. Это какая-то информация, которую компилятор вставляет в таблицу, чтобы понимать динамический тип. И к ней даже можно доступ получить. Для этого есть ключевое слово <code>typeid</code>. Вы даёте ему объект, а он возвращает вам <code>std::type_info const&amp;</code>, который по сути и является RTTI.</p>
<p>Кстати, в большинстве компиляторов можно выключать RTTI (в GCC — ключ <em>-fno-rtti</em>), чтобы не тратить место в бинарном файле. И в каких-то кодовых базах можно увидеть код без <code>dynamic_cast</code>'ов и <code>typeid</code>.</p>
<!--
*В коде редко используют `dynamic_cast`, потому что чаще всего можно обойтись без него и ещё это может быть дорого*

Я бы не был так категоричен. В 2021–22 это было сказано в формулировке выше: *существуют кодовые базы*.
-->
<h2><a class="header" href="#Парочка-полезных-ключевых-слов" id="Парочка-полезных-ключевых-слов">Парочка полезных ключевых слов.</a></h2>
<h3><a class="header" href="#final" id="final"><code>final</code>.</a></h3>
<p><code>final</code> — нельзя наследовать. Либо нельзя наследовать класс, либо нельзя больше override'ить виртуальную функцию. Пишется так:</p>
<pre><code class="language-c++">struct inderriveable final {
	// ...
};
struct error1 : inderriveable {} // A `final` class cannot be used as a base class.

struct base {
	virtual void foo() {}
};
struct derived : base {
	void foo() final {}
};
struct error2 : derived {
	void foo() {} // Cannot override `final` function `derived::foo`.
}
</code></pre>
<h3><a class="header" href="#override" id="override"><code>override</code>.</a></h3>
<p>Явно указать, что вы override'ите виртуальную функцию, а не пишете что-то своё. Очень советуется это писать. Если кто-то изменит базовый класс, вы хотите явно видеть, что все функции
поломаются. Пишется в том же месте, где и <code>final</code>.</p>
<h3><a class="header" href="#protected" id="protected"><code>protected</code>.</a></h3>
<p>Представим, что мы пишем виджет на основе QT. Там есть базовый виджет, у которого есть операции, что делать в случае нажатия мышки, в случае перемещения колёсика и прочее подобное. Вам всё это нужно переопределить. В таком случае в базовом виджете используется ключевое слово <code>protected</code>. Оно для похожих случаев и было создано, лол. Это модификатор доступа, дающий доступ только дочерним классам и себе.</p>
<p>С ним, правда, есть вопрос. Если метод не ломает инвариант, почему он не <code>public</code>, а если ломает, то хотим ли мы давать доступ дочерним классам. Тем не менее эти вопросы не риторические, если вы нашли на них ответ — делайте <code>protected</code>.</p>
<h2><a class="header" href="#Ещё-best-practices" id="Ещё-best-practices">Ещё best practices.</a></h2>
<p>Давайте дополним наш пример с виджетами выше. Вот есть у нас виджет, который знает, как его красить. И это виртуальная функция. Мы наследуемся, меняем функцию, всё хорошо. Но есть же второй вариант — <strong>создать отдельный класс, который отвечает за покраску, наследовать только его, и передавать этот объект в конструктор виджета</strong>. Это может быть очень полезно, если мы хотим, например, одинаково красить разные классы в разных местах. Более того, мы можем <strong>собирать наш виджет из кусочков</strong>. В QT, например, используется оба подхода. Реакция на мышку, на клавиатуру, перекраска и некоторые другие штуки обычно очень сильно связаны с самим классом, а какая-нибудь стилизация — уже что-то внешнее.</p>
<p>Однако надо понимать, что комбинируя кусочки, можно зайти так далеко, что вы будете складывать $2+2$, получая двойку из какого-то <code>data_provider</code>'а, складывая каким-нибудь классом <code>adder</code> и подобное. Не надо плодить фабрики непонятных классов. Когда вы делаете точку настройки, вы делаете ставку на то, что будете менять. Тут надо сильно думать. Более того, <strong>если вы сделали какие-то точки настройки, а расширять надо в другую сторону, то ваши точки настройки будут вам во вред</strong>, потому что вам надо будет их с новыми согласовывать.</p>
<p>Мораль: <strong>когда вы делаете фабрики/точки настройки/всё остальное, думайте, для чего вы это делаете</strong>.</p>
<h3><a class="header" href="#Мем-про-квадрат-и-прямоугольник" id="Мем-про-квадрат-и-прямоугольник">Мем про квадрат и прямоугольник.</a></h3>
<p>Как правильно наследоваться: квадрат от прямоугольника или прямоугольника от квадрата? (Для более детального понимания проблемы — смотрите <a href="https://youtube.com/watch?v=RYuUybAh0SI&amp;t=1772">лекцию по Java</a>.)</p>
<p>Это зависит от того, что требуется от интерфейса. Давайте посмотрим, что требуется от этих фигур:</p>
<table><thead><tr><th align="center">Квадрат</th><th align="center">Прямоугольник</th><th align="center">Оба</th></tr></thead><tbody>
<tr><td align="center"><code>get_side</code></td><td align="center"><code>set_width</code></td><td align="center"><code>get_width</code></td></tr>
<tr><td align="center"></td><td align="center"><code>set_height</code></td><td align="center"><code>get_height</code></td></tr>
<tr><td align="center"></td><td align="center"></td><td align="center"><code>set_side</code></td></tr>
</tbody></table>
<p>Если нам нужно всё из этого, то отнаследовать какую-либо фигуру от другой не получится. Но если у нас нет <code>set_*</code>, то методы, специфичные для прямоугольника, резко пропадают, а значит его можно отнаследовать от квадрата.</p>
<h2><a class="header" href="#Наследование-против-unionа" id="Наследование-против-unionа">Наследование против <code>union</code>'а.</a></h2>
<p>Мы же можем использовать наследование для той же цели, что и <code>union</code>/<code>std::variant</code> — выбирать из альтернативы. В случае с <code>std::variant</code> мы даже можем проверять корректность обращения. Что же лучше?</p>
<table><thead><tr><th align="center">Преимущества наследования</th><th align="center">Преимущества <code>union</code>'а</th></tr></thead><tbody>
<tr><td align="center">Если альтернативы разного размера, то <code>union</code> жрёт много памяти.</td><td align="center">Наследование работает по указателю, а это даёт лишнюю индирекцию.</td></tr>
<tr><td align="center">Можно легко добавить новую альтернативу.</td><td align="center">Можно легко добавить новую операцию.</td></tr>
</tbody></table>
<h2><a class="header" href="#Модификаторы-доступа-наследования" id="Модификаторы-доступа-наследования">Модификаторы доступа наследования.</a></h2>
<p>Как и у полей, у базовых классов можно указывать такие штуки как <code>class A : public B</code>. Причём в случае приватного наследования, вы не только поля из <code>B</code> не будете видеть в <code>A</code> извне, у вас даже <code>static_cast</code> не сработает. То есть <strong>наследование с модификаторами доступа скрывает/показывает сам факт наследования</strong>.</p>
<p>С какой целью это можно использовать — смотрите далее.</p>
<!--
```c++
struct output_device {
	virtual void write(void const* data, size_t size) = 0;
	virtual void set_volume(double val) = 0;
	virtual void write(void const* data, size_t size) = 0;
};
struct volume_data : output_device {
	void set_volume(double val) override {
		volume = val;
	}
	double get_volume() override {
		return volume;
	}
private:
	double volume;
}
struct file : volume_data {};
struct speakers : volume_data {};
```

В коде выше можно приводить `file` и `speakers` к `volume_data` или использовать указатели на них как указатели на `volume_data`, чего мы не хотим.

Какой-то очень сомнительный пример, слушайте. Почему не хотим?
-->
<h2><a class="header" href="#Виртуальное-наследование" id="Виртуальное-наследование">Виртуальное наследование.</a></h2>
<pre><code class="language-c++">struct A {
	int x;
};
struct B : A {};
struct C : A {};
struct D : B, C {};

int main() {
	D d;
	d.x = 7; // Не работает, x is ambiguous.
	d.B::x = 7; // Работает.
	d.C::x = 7; // Работает.
}
</code></pre>
<p>Если две копии <code>A</code> (а, следовательно, <code>x</code>) — это то, что вы хотите, то хорошо. А иначе есть виртуальное наследование:</p>
<pre><code class="language-c++">struct A {
	int x;
};
struct B : virtual A {};
struct C : virtual A {};
struct D : B, C {};

int main() {
	D d;
	d.x = 7;
}
</code></pre>
<p>Если базовый класс помечен <code>virtual</code>, то это значит, что он шарится с другими такими же виртуальными классами в иерархии. Для иерархии все <code>virtual</code> базы склеиваются в один <em>подобъект</em> (<em>subobject</em>).</p>
<p>С методами это, кстати, работает точно также. Казалось бы, в чём проблема тут:</p>
<pre><code class="language-c++">struct A {
	void foo();
};
struct B : A {};
struct C : A {};
struct D : B, C {};
</code></pre>
<p>Ведь метод и вас по-любому один, зачем тут виртуальное наследование? А нифига, в этот метод надо передать <code>this</code> типа <code>A* const</code>, а таких у вас два, непонятно, какой брать. Поэтому тут тоже нужно виртуальное наследование.</p>
<p>Теперь посмотрим на вот такой пример:</p>
<pre><code class="language-c++">struct A {
	virtual void foo() = 0;
};
struct B : A {
	void foo() override {}
};
struct C : A {};
struct D : B, C {};
int main() {
	D d;
}
</code></pre>
<p>Тут понятно, в чём проблема. У <code>D</code> есть два подобъекта типа <code>A</code>, в одном из которых никто не за'override'ил <code>foo</code>. Значит <code>D</code> виртуальный класс. Значит его нельзя создать.</p>
<p>Это правится так:</p>
<pre><code class="language-c++">struct A {
	virtual void foo() = 0;
};
struct B : A {
	void foo() override {}
};
struct C : A {
	void foo() override {}
};
struct D : B, C {};
int main() {
D d;
}
</code></pre>
<p>И так тоже правится:</p>
<pre><code class="language-c++">struct A {
	virtual void foo() = 0;
};
struct B : virtual A {
	void foo() override {}
};
struct C : virtual A {};
struct D : B, C {};
</code></pre>
<p>Подобъект типа <code>A</code> у нас один, и его чисто виртуальная функция переопределена. Значит всё хорошо.</p>
<pre><code class="language-c++">struct A {
	virtual void foo() = 0;
};
struct B : virtual A {
	void foo() override {}
};
struct C : virtual A {
	void foo() override {}
};
struct D : B, C {};
int main() {
	D d;
	d.foo();
}
</code></pre>
<p>А так, понятно, нельзя, потому что у одного подобъекта мы два раза за'override'или одну и ту же функцию. И фиг знает, что использовать. Только если вы за'override'иде эту же функцию прямо в <code>D</code>, то будет понятно, что использовать, и компилироваться исправно будет.</p>
<p>Описанным выше образом, кстати, работают вообще любые объекты одного имени. Т.е. переменные и обычные методы взаимодействуют с виртуальным наследованием также:</p>
<pre><code class="language-c++">struct A {
	int x;
};
struct B : virtual A {
	int x;
};
struct C : virtual A {};
struct D : B, C {};
</code></pre>
<p>У вас будет две переменных <code>x</code>, в <code>D</code> по умолчанию будет использоваться <code>B::x</code>.</p>
<h3><a class="header" href="#Применение-виртуального-наследования" id="Применение-виртуального-наследования">Применение виртуального наследования.</a></h3>
<p>С помощью виртуального наследования можно реализовывать интерфейсы по чуть-чуть. У нас есть абстрактный базовый класс, который умеет, там, рендериться, изменяться, что-то ещё делать, и мы можем override'ить одну его часть в одном классе, другую — в другом. А для сборки этих штук в одну придётся использовать виртуальное наследование:</p>
<pre><code class="language-c++">struct game_object {
	virtual void render() = 0;
	virtual void update() = 0;
};
struct billbord_object : virtual game_object {
	void render() override {/* ... */};
};
struct static_object : virtual game_object {
	void update() override {/* ... */};
};
struct static_billboard : billbord_object, static_object
{};
</code></pre>
<p>Но это ещё цветочки, на самом деле. Представьте, что у вас есть какой-то публичный базовый класс (например, <code>widget_painter</code>), и вы создаёте несколько <strong>похожих</strong> его наследников. А потом видите, что наследники похожи, их можно обобщить, и получить какую-то такую иерархию:</p>
<pre><code class="language-c++">// Somewhere.h
struct widget_painter {
	virtual void paint() {/* ... */}
};
</code></pre>
<pre><code class="language-c++">// Your_file.h
struct my_base_painter : widget_painter {
	void paint() override {/* ... */}
};
struct my_painter1 : my_base_painter {};
struct my_painter2 : my_base_painter {};
</code></pre>
<p>Но мы не хотим, чтобы кто-то приводил наши классы <code>my_painter*</code> к <code>my_base_painter</code>, это деталь реализации. Поэтому хочется написать</p>
<pre><code class="language-c++">struct my_painter1 : private my_base_painter {};
</code></pre>
<p>Но это не сработает, потому что тогда никто снаружи и наследование от <code>widget_painter</code> видеть не будет. Поэтому вот как надо:</p>
<pre><code class="language-c++">//  Вот сюда смотреть:   vvvvvvv
struct my_base_painter : virtual widget_painter {
	void paint() override {/* ... */}
};
//  И сюда смотреть: vvvvvvv                  vvvvvvv
struct my_painter1 : private my_base_painter, virtual widget_painter {};
struct my_painter2 : private my_base_painter, virtual widget_painter {};
</code></pre>
<p>Мораль: <strong>не надо бояться виртуального наследования и пренебрегать им</strong>.</p>
<h3><a class="header" href="#Виртуальное-наследование-изнутри" id="Виртуальное-наследование-изнутри">Виртуальное наследование изнутри.</a></h3>
<p>Во что бы мы оттранслировали виртуальное наследование? Давайте вместо того, чтобы внутри объекта B хранить объект A, хранить указатель на него. Но если у нас много виртуальных баз, то хочется табличку. А табличку указателей на базы нельзя, у всех объектов типа <code>D</code> эти указатели свои, в отличие от виртуальных методов.</p>
<p>Давайте хранить не указатель, а смещение до нужной виртуальной базы. И тогда в каждом объекте всё одинаковое, а значит можно объединить в табличку — табличку виртуальных баз.</p>
<p><img src="./images/07-inheritance/Vitrual-inheritance.svg" alt="Виртуальное наследование" /></p>
<p>А теперь <del>пример</del> мемы:</p>
<pre><code class="language-c++">struct base {};
struct derived : virtual base {};
derived&amp; test(base&amp; b) {
	return static_cast&lt;derived&amp;&gt;(b);
}
</code></pre>
<p>Так вот это не компилируется, потому что мы совершенно не шарим, откуда в объекте <code>b</code> взять смещение, которое хранится в <code>derived</code>. Но зато можно так:</p>
<pre><code class="language-c++">struct base {
	virtual ~base() {}
};
struct derived : virtual base {};
derived&amp; test(base&amp; b) {
	return dynamic_cast&lt;derived&amp;&gt;(b);
}
</code></pre>
<p>Это, как ни странно, компилируется, потому что вы можете взять RTTI из <code>b</code>, понять, что это <code>derived</code>, и украсть смещение из таблицы виртуальных баз для него. Более того, с <code>dynamic_cast</code> есть ещё больший мем:</p>
<pre><code class="language-c++">struct A {
virtual void foo() {}
};
struct B {};
B&amp; test(A&amp; a) {
	return dynamic_cast&lt;B&amp;&gt;(a);
}
</code></pre>
<p>Как ни странно, это компилируется, более того, даже может быть корректно, если вы создадите класс
<code>C</code> и отнаследуете его и от <code>A</code>, и от <code>B</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="06_classes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="08_exceptions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="06_classes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="08_exceptions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
