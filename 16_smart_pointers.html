<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Smart pointers: unique_ptr, shared_ptr, weak_ptr - C++ course notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li class="chapter-item expanded "><a href="07_classes_memory_preprocessor.html"><strong aria-hidden="true">8.</strong> Ещё про классы, выделение памяти, препроцессор</a></li><li class="chapter-item expanded "><a href="08_inheritance.html"><strong aria-hidden="true">9.</strong> Наследование, виртуальные функции</a></li><li class="chapter-item expanded "><a href="09_exceptions.html"><strong aria-hidden="true">10.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li class="chapter-item expanded "><a href="10_memory_allocation.html"><strong aria-hidden="true">11.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации, статические и динамические библиотеки</a></li><li class="chapter-item expanded "><a href="11_templates.html"><strong aria-hidden="true">12.</strong> Шаблоны (templates)</a></li><li class="chapter-item expanded "><a href="12_stl_sfinae.html"><strong aria-hidden="true">13.</strong> Обзор STL, tag-dispatching, SFINAE, пространства имён</a></li><li class="chapter-item expanded "><a href="13_namespaces_using_adl.html"><strong aria-hidden="true">14.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li class="chapter-item expanded "><a href="14_move_rvalue.html"><strong aria-hidden="true">15.</strong> Move-семантика, rvalue-ссылки</a></li><li class="chapter-item expanded "><a href="15_intrusive_containers.html"><strong aria-hidden="true">16.</strong> Интрузивные контейнеры</a></li><li class="chapter-item expanded "><a href="16_smart_pointers.html" class="active"><strong aria-hidden="true">17.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li class="chapter-item expanded "><a href="17_perfect_forwarding.html"><strong aria-hidden="true">18.</strong> Perfect forwarding, variadic templates</a></li><li class="chapter-item expanded "><a href="18_decltype_auto_nullptr.html"><strong aria-hidden="true">19.</strong> Decltype, declval, auto, nullptr</a></li><li class="chapter-item expanded "><a href="19_lambdas_type_erasure.html"><strong aria-hidden="true">20.</strong> Анонимные функции, type erasure, std::function</a></li><li class="chapter-item expanded "><a href="20_signals_reetrancy_errors.html"><strong aria-hidden="true">21.</strong> Сигналы, reetrancy, обработки ошибок</a></li><li class="chapter-item expanded "><a href="21_optional_variant_tuple_stringview.html"><strong aria-hidden="true">22.</strong> Optional, variant, tuple, string_view</a></li><li class="chapter-item expanded "><a href="22_constexpr.html"><strong aria-hidden="true">23.</strong> Статическая и динамическая инициализация, constexpr</a></li><li class="chapter-item expanded "><a href="23_multithreading.html"><strong aria-hidden="true">24.</strong> Многопоточность</a></li><li class="chapter-item expanded "><a href="24_qt.html"><strong aria-hidden="true">25.</strong> Qt</a></li><li class="chapter-item expanded "><a href="25_concepts.html"><strong aria-hidden="true">26.</strong> Концепты</a></li><li class="chapter-item expanded "><a href="26_ranges.html"><strong aria-hidden="true">27.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="27_encoding.html"><strong aria-hidden="true">28.</strong> Кодировки</a></li><li class="chapter-item expanded "><a href="28_coroutines.html"><strong aria-hidden="true">29.</strong> Корутины</a></li><li class="chapter-item expanded "><a href="29_modules.html"><strong aria-hidden="true">30.</strong> Модули</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">C++ course notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/lejabque/cpp-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Умные-указатели" id="Умные-указатели">Умные указатели</a></h1>
<ul>
<li><a href="slides/shared_ptr.pdf">Слайды с лекции</a></li>
<li><a href="https://github.com/sorokin/cpp-notes/blob/master/smart-pointers.tex">Оригинальный конспект от Вани</a></li>
<li><a href="https://www.youtube.com/watch?v=L9ohcGR0yFE">Запись лекции №1</a></li>
<li><a href="https://www.youtube.com/watch?v=M9h0_xBM7_8">Запись лекции №2</a></li>
</ul>
<hr />
<h2><a class="header" href="#stdunique_ptr" id="stdunique_ptr">std::unique_ptr</a></h2>
<h3><a class="header" href="#Мотивирующий-пример" id="Мотивирующий-пример">Мотивирующий пример</a></h3>
<p>Когда мы писали контейнеры, часто мы встречали такой код:</p>
<pre><code class="language-c++">container* create_container() {
    container* c = new container();
    try {
        fill(*c);
    } catch (...) {
        delete c;
        throw;
    }
    return c;
}
</code></pre>
<p>Если функция <code>fill</code> бросала исключение, нам нужно было удалить память, выделенную по указателю, и пробросить исключение. Проблема такого кода, что он трудно масштабируется на несколько объектов, которые требуется удалять.</p>
<p>Для решения этой проблемы в C++11 появились умные указатели, которые являются RAII-обёртками над обычными указателями. Деструкторы таких указателей удаляют объект, на который они ссылаются. Например, с <code>std::unique_ptr</code> код выглядел бы так:</p>
<pre><code class="language-c++">std::unique_ptr&lt;container&gt; create_container() {
    std::unique_ptr&lt;container&gt; c(new container());
    fill(*c);
    return c;
}
</code></pre>
<h3><a class="header" href="#Реализация" id="Реализация">Реализация</a></h3>
<p><code>unique_ptr</code> - самый простой из умных указателей. Внутри он хранит указатель <code>T* ptr</code> и вызывает <code>delete</code> от него в деструкторе.</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct unique_ptr {
    unique_ptr()
        : ptr(nullptr) {}
    unique_ptr(T* ptr)
        : ptr(ptr) {}
    ~unique_ptr() {
        delete ptr;
    }
  private:
    T* ptr;
}
</code></pre>
<p><code>unique_ptr</code> имеет операторы <code>*</code> и <code>-&gt;</code>, поэтому им можно пользоваться как обычным указателем. </p>
<pre><code class="language-c++">T&amp; operator*() const {
	return *ptr;
}
T* operator-&gt;() const noexcept {
	return ptr;
}
</code></pre>
<p>Помимо этого, у него есть функция <code>get()</code>, возвращающая указатель, который лежит в нём.</p>
<pre><code class="language-c++">T* get() const {
	return ptr;
}
</code></pre>
<p>Так же есть <code>release()</code> - зануляет <code>ptr</code>, хранящийся внутри, а старое значение возвращает наружу. <code>release()</code> обычно используется, если в некоторую функцию нужно передать указатель, который хранит <code>unique_ptr</code>, при этом известно, что функция самостоятельно удалит объект.</p>
<pre><code class="language-c++">T* release() {
	T* tmp = ptr;
	ptr = nullptr;
    return tmp;
}
</code></pre>
<p><code>reset(p)</code> - заменяет указатель <code>ptr</code> на <code>p</code> и делает <code>delete</code> от старого указателя.</p>
<pre><code class="language-c++">void reset(T* p) {
	delete ptr;
	ptr = p;
}
</code></pre>
<p>В названии <code>unique_ptr</code> заключается его основное свойство - он хранит &quot;уникальный&quot; указатель на объект (а точнее, он единственный ответственен за его удаление). Поэтому оператор присваивания и конструктор копирования у него запрещены, но есть <code>move constructor</code> и <code>move assignment</code>:</p>
<pre><code class="language-c++">unique_ptr(unique_ptr const&amp; other) = delete;
unique_ptr&amp; operator=(unique_ptr const&amp; other) = delete;
unique_ptr&amp; operator=(unique_ptr&amp;&amp; other) noexcept {
	reset(other.release());
	return *this;
}
unique_ptr(unique_ptr&amp;&amp; other) noexcept 
	: ptr(other.release()) {}
</code></pre>
<h3><a class="header" href="#Неявные-приведения" id="Неявные-приведения">Неявные приведения</a></h3>
<p>Для <code>unique_ptr</code> реализована логика приведений аналогичная той, что есть у обычных указателей. <code>unique_ptr&lt;D&gt;</code> можно привести к <code>unique_ptr&lt;B&gt;</code> тогда и только тогда, когда разрешено приведение <code>D*</code> к <code>B*</code>.</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct unique_ptr {
    template &lt;typename U, typename = typename std::enable_if_t&lt;is_convertible_v&lt;U*, T*&gt;&gt;&gt;
    unique_ptr(unique_ptr&lt;U&gt;&amp;&amp; other);
};
</code></pre>
<h3><a class="header" href="#Настраиваемый-deleter" id="Настраиваемый-deleter">Настраиваемый deleter</a></h3>
<p>До этого мы говорили, что деструктор у <code>unique_ptr</code> вызывает <code>delete</code> от указателя. В общем случае это не всегда верно. Например, память под объект могла быть выделена кастомным аллокатором или <code>malloc</code>, <code>new[]</code>. Для такого использования <code>std::unique_ptr</code> поддерживает пользовательский <code>deleter</code>. По умолчанию в качестве <code>deleter</code> используется класс <code>std::default_delete</code>, который вызывает <code>delete</code> на указателе. </p>
<p>Реализация <code>unique_ptr</code> с <code>deleter</code> могла бы выглядеть так:</p>
<pre><code class="language-c++">template&lt;typename T, typename D = default_delete&lt;T&gt;&gt;
struct unique_ptr {
    using pointer = typename D::pointer;
    unique_ptr(pointer);
    unique_ptr(pointer, D);
    ~unique_ptr() {
        deleter(ptr);
    }
  private:
    pointer ptr;
    D deleter;
}
</code></pre>
<p>К сожалению, в реальности реализация сложнее из-за следующих причин:</p>
<ul>
<li>Шаблонный параметр <code>D</code> может быть не только самим <code>deleter</code>, но и ссылкой на него, поэтому ссылку с <code>D</code> нужно снимать.</li>
<li><code>Deleter</code> не обязан содержать <code>typedef pointer</code>. Если он отсутствует, <code>unique_ptr</code> должен использовать <code>T*</code> вместо него. Это можно сделать SFINAE-проверкой.</li>
<li>Часто <code>deleter</code> это пустой объект, поэтому, чтобы не увеличивать размер <code>unique_ptr</code>, пользуются empty-base оптимизацией.</li>
</ul>
<p>При перемещении <code>unique_ptr</code>, перемещается и его <code>deleter</code>. Отдельный случай - это неявные приведения, так как <code>unique_ptr</code> от разных типов могут иметь разные <code>deleter</code>. При использовании кастомных <code>deleter</code>, <code>unique_ptr&lt;T1, D1&gt;</code> приводится к <code>unique_ptr&lt;T2, D2&gt;</code>, если выполнено одно из двух условий:</p>
<ul>
<li><code>D2</code> - ссылка, <code>D1</code> совпадает с <code>D2</code></li>
<li><code>D2</code> - не ссылка, <code>D1</code> приводится к <code>D2</code></li>
</ul>
<h4><a class="header" href="#unique_ptr-для-массивов" id="unique_ptr-для-массивов">unique_ptr для массивов</a></h4>
<p>Для массивов у <code>unique_ptr</code> есть отдельная специализация:</p>
<pre><code class="language-c++">template &lt;typename T, typename D = default_delete&lt;T&gt;&gt;
struct unique_ptr;

template &lt;typename E, typename D&gt;
struct unique_ptr&lt;E[], D&gt; {
    E&amp; operator[](size_t index) const;
};
</code></pre>
<p>Отличается она следующим:</p>
<ul>
<li>
<p>Наличием <code>operator[]</code></p>
</li>
<li>
<p>Хранит внутри <code>E*</code>, а не <code>T*</code></p>
</li>
<li>
<p>Использует более сильные правила для неявных преобразований, так как приведение указателей на массивы зависит не только от типов, но и от размеров массивов.</p>
</li>
</ul>
<p><code>default_delete</code> можно использовать и для массивов, так как у него тоже есть специализация, которая делает <code>delete[]</code> вместо <code>delete</code>.</p>
<h2><a class="header" href="#stdshared_ptr" id="stdshared_ptr">std::shared_ptr</a></h2>
<h3><a class="header" href="#Термин-владение" id="Термин-владение">Термин &quot;владение&quot;</a></h3>
<p>Владением называют ответственность за удаление объекта. Например, <code>unique_ptr</code> ответственен за удаление объекта, на который он ссылается, соответственно говорят, что <code>unique_ptr</code> владеет объектом, на который он ссылается. Функция <code>reset(p)</code> передаёт владение объектом, а функция <code>release()</code> наоборот, забирает владение объектом.</p>
<p>В некоторых случаях у объекта может быть несколько владельцев. Это называется разделяемым владением и работает следующим образом: за удаление объекта ответственен последний владелец. Для умных указателей существует два способа реализации такого владения: подсчёт ссылок и провязка всех владельцев в двусвязный список. <code>std::shared_ptr</code> использует подсчёт ссылок. Указатель, использующий провязку владельцев в двусвязный список, в стандартной библиотеке отсутствует, но часто его называют <code>linked_ptr</code>.</p>
<h3><a class="header" href="#Пример-применения" id="Пример-применения">Пример применения</a></h3>
<p><code>shared_ptr</code> очень похож на логику, которая нужна для реализации оптимизации Copy-on-Write.</p>
<p><code>shared_ptr&lt;data const&gt;</code>можно использовать, если не нужно модифицировать значение.</p>
<h3><a class="header" href="#Реализация-1" id="Реализация-1">Реализация</a></h3>
<pre><code class="language-c++">template&lt;typename T&gt;
struct shared_ptr {
    shared_ptr();
    explicit shared_ptr(T* ptr);
    shared_ptr(shared_ptr const&amp; other);
    shared_ptr&amp; operator=(shared_ptr const&amp; other);
};
</code></pre>
<p>Как и <code>unique_ptr</code>, <code>shared_ptr</code> поддерживает операции <code>operator*</code>, <code>operator-&gt;</code>, <code>reset</code>, <code>get</code>. Операции <code>release</code> у <code>shared_ptr</code> нет, потому что могут быть другие <code>shared_ptr</code>, ссылающиеся на этот объект.</p>
<p><code>shared_ptr</code> внутри себя хранит указатель на ссылаемый объект и указатель на счётчик ссылок. Поскольку счётчик ссылок у всех <code>shared_ptr</code>, ссылающихся на один и тот же объект, общий, то память под него аллоцируется динамически.</p>
<pre><code class="language-c++">template&lt;typename T&gt;
struct shared_ptr {
    shared_ptr()
      : ptr(nullptr),
    	ref_counter(nullptr) {}
    shared_ptr(T* ptr)
	  : ptr(ptr) {
    	if (ptr == nullptr) {
			return;
		}
		try {
			ref_counter = new size_t(1);
		} catch (...) {
			delete ptr;
			throw;
		}
     }
    shared_ptr(shared_ptr const&amp; other)
      : ptr(other.ptr),
    	ref_counter(other.ref_counter) {
		if (ptr == nullptr) {
			return;
		}
		++ref_counter;
	}
    ~shared_ptr() {
        if (ptr == nullptr) {
            return;
        }
        if (--*ref_counter == 0) {
            delete ref_counter;
            delete ptr;
        }
    }
  private:
    T* ptr;
    size_t* ref_counter;
}
</code></pre>
<p>Если <code>shared_ptr</code> не ссылается ни на один объект, то <code>ptr == nullptr</code>, <code>ref_counter == nullptr</code>.</p>
<p>Если <code>shared_ptr</code> ссылается на некоторый объект, то <code>ptr != nullptr</code>, <code>ref_counter != nullptr</code>, <code>*ref_counter</code> равен числу <code>shared_ptr</code>, ссылающихся на объект <code>*ptr</code>.</p>
<h3><a class="header" href="#Проблема-разделения-счётчика-ссылок" id="Проблема-разделения-счётчика-ссылок">Проблема разделения счётчика ссылок</a></h3>
<p>Посмотрим на следующий код:</p>
<pre><code class="language-c++">T* p = new T();
std::shared_ptr&lt;T&gt; p1(p);
std::shared_ptr&lt;T&gt; p2(p);
</code></pre>
<p>Такой код некорректен, так как у <code>p1</code> и <code>p2</code> разные счётчики ссылок, поэтому объект <code>*p</code> удалится дважды. Такая ситуация называется разделением (<em>split</em>) счётчика ссылок. Разделение счётчика ссылок - ошибка, поэтому в корректных программах оно возникать не должно.</p>
<p>Чтобы не происходило разделение счётчика ссылок, не нужно оборачивать один сырой указатель в <code>shared_ptr</code> дважды. Использование <code>std::make_shared</code> или использование <code>std::enable_shared_from_this</code> также позволяет избежать разделения счётчика ссылок.</p>
<h3><a class="header" href="#Настраиваемый-deleter-1" id="Настраиваемый-deleter-1">Настраиваемый deleter</a></h3>
<p>Если в <code>shared_ptr</code>, например, похранить массив (или любой объект, созданный не с помощью <code>new</code>), то, по аналогии с <code>unique_ptr</code>, нам нужен <code>deleter</code>. Он может храниться, например, в памяти рядом с счётчиком ссылок.</p>
<p><img src="images/09.17_shared_ptr.png" alt="shared_ptr" /></p>
<h3><a class="header" href="#aliasing-constructor" id="aliasing-constructor">Aliasing constructor</a></h3>
<p>Иногда возникает желание ссылаться с помощью <code>shared_ptr</code> на объект и его мемберов.</p>
<p>Наивное решение такого:</p>
<pre><code class="language-c++">struct wheel {};
struct vehicle {
    std::array&lt;std::shared_ptr&lt;wheel&gt;, 4&gt; wheels;
};
</code></pre>
<p>Проблема такого подхода в том, что при удалении <code>vehicle</code>, <code>wheel</code> остаются живы, пока на них кто-то ссылается.</p>
<p>Можем захотеть такое поведение: пока кто-то ссылается на составную часть объекта, основной объект жив. Для этого можно хранить для них общий счётчик ссылок.</p>
<pre><code class="language-c++">struct vehicle {
    std::array&lt;wheel, 4&gt; wheels;
}
std::shared_ptr&lt;vehicle&gt; v(new vehicle);
std::shared_ptr&lt;wheel&gt; w(v, &amp;v-&gt;wheels[2]);
</code></pre>
<p>В таком случае оба указателя отвечают за удаление объекта <code>vehicle</code> (в зависимости от того, какой из указатель раньше будет разрушен), поэтому <code>deleter</code> у них общий, кроме того в управляющем блоке хранится <code>ptr</code> на исходный объект, чтобы передать его в <code>deleter</code>.</p>
<p><img src="images/09.17_aliasing.png" alt="shared_ptr" /></p>
<p>Одно из применений такого конструктора - указатели в дереве. Пока будет существовать хотя бы один указатель на элемент дерева, всё дерево будет продолжать существовать.</p>
<h3><a class="header" href="#stdmake_shared" id="stdmake_shared">std::make_shared</a></h3>
<p>Рассмотрим следующий пример кода:</p>
<pre><code class="language-c++">shared_ptr&lt;mytype&gt; sp(new mytype(1, 2, 3));
</code></pre>
<p>Такой код аллоцирует два объекта в куче - один при создании <code>new mytype</code>, другой - счётчик ссылок внутри <code>shared_ptr</code>. Таким образом, такое использование удваивает количество аллокаций, что не очень хорошо.</p>
<p>Для решения этой проблемы существует специальная функция <code>make_shared</code>:</p>
<pre><code class="language-c++">template&lt;typename T, typename... Args&gt;
shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
</code></pre>
<p><code>make_shared</code> создаёт объект типа <code>T</code> и возвращает <code>shared_ptr</code> на него. При этом <code>make_shared</code> делает одну аллокацию памяти, то есть и объект, и счётчик ссылок выделяются в одном блоке.</p>
<p><img src="images/09.17_make_shared.png" alt="make_shared" /></p>
<p>Кроме экономии аллокаций, <code>make_shared</code> избавляет нас от необходимости следить за исключениями в <code>new</code>. Пример кода:</p>
<pre><code class="language-c++">bar(std::shared_ptr&lt;mytype&gt;(new mytype(1, 2, 3)),
   std::shared_ptr&lt;mytype&gt;(new mytype(4, 5, 6)));
</code></pre>
<p>Так как порядок выполнения не задан, сначала может вызваться первый <code>new</code>, затем второй, а потом только конструкторы <code>shared_ptr</code>. В таком случае, если второй <code>new</code> кинет исключение, то первый объект не удалится. <code>make_shared</code> позволяет такое избежать.</p>
<h2><a class="header" href="#stdweak_ptr" id="stdweak_ptr">std::weak_ptr</a></h2>
<p><code>weak_ptr</code> - парный указатель к <code>shared_ptr</code>.  Он нужен, чтобы ссылаться на объект, но не мешать ему удаляться. Один из способов его реализации - хранить отдельно счётчики сильных и слабых ссылок. Для удобства в проверках счётчик слабых ссылок не нулевой, если есть хотя бы одна сильная ссылка (например, можно для каждой сильной ссылки увеличивать счётчик слабых).</p>
<p>Пример применения <code>weak_ptr</code> - кэши.</p>
<pre><code class="language-c++">shared_ptr&lt;widget&gt; get_widget(int id) {
    static map&lt;int, weak_ptr&lt;widget&gt;&gt; cache;
    auto sp = cache[id].lock();
    if (!sp) {
        cache[id] = sp = load_widget(id);
    }
    return sp;
}
</code></pre>
<p>В этом примере <code>weak_ptr</code> не мешают удаляться виджетам. Метод<code>lock</code> у <code>weak_ptr</code> создаёт новый <code>shared_ptr</code> на объект, если объект ещё не удалён, иначе возвращает пустой <code>shared_ptr</code>.</p>
<p>Проблема примера выше в том, что из <code>cache</code> никогда не удаляются вхождения, даже если объекты удалены. При этом, так как у нас будут висеть <code>weak_ptr</code>, не будут удаляться <code>control_block</code>'и (счётчики ссылок в памяти). </p>
<p>Это можно решить, например, <a href="https://gist.github.com/sorokin/7f23a639b3a8733f10ab77b06da28e44">кастомным делитером</a>, который будет удалять из мапы. Проблема реализации, приведённой по ссылке, в том, что там не применяется <code>make_shared</code>, так как у объекта кастомный <code>deleter</code>. Это можно решить с помощью <a href="https://gist.github.com/sorokin/811648e5e305ab1d62e7a750e2b53d27">обёртки над объектом</a>, деструктор которой будет удалять объект из мапы. Тогда можно применить <em>aliasing constructor</em>, чтобы получать указатели не на обёртку, а на сам объект - member обёртки.</p>
<p>Так же стоит упомянуть, что использование <code>make_shared</code> с <code>weak_ptr</code> может быть неэффективным. Так как <code>make_shared</code> создаёт объект и счётчик ссылок одним блоком памяти, то даже когда счётчик сильных ссылок обнулится, <code>control_block</code> продолжит существовать, пока жив хотя бы один <code>weak_ptr</code>. Таким образом память, выделенная под объект, не будет освобождена до удаления <code>control block</code> (хотя деструктор объекта вызовется).</p>
<h3><a class="header" href="#stdenable_shared_from_this" id="stdenable_shared_from_this">std::enable_shared_from_this</a></h3>
<p>Если хотим вернуть <code>shared_ptr</code> от <code>this</code>, то нельзя сделать это просто как <code>std::shared_ptr(this)</code>, так как на каждый <code>shared_ptr</code> будут разные <code>control_block</code>'и. В стандартной библиотеке для этого есть класс <code>std::enable_shared_from_this</code>:</p>
<pre><code class="language-c++">struct mytype : std::enable_shared_from_this&lt;mytype&gt; {
    std::shared_ptr&lt;mytype&gt; bar() {
        return shared_from_this();
    }
}
</code></pre>
<p>Реализация <code>enable_shared_from_this</code> хранит внутри <code>weak_ptr</code>, от которого создаётся <code>shared_ptr</code> при вызове <code>shared_from_this()</code>.</p>
<p>Конструктор <code>shared_ptr(T*)</code> использует SFINAE-проверки для определения наследования от <code>enable_shared_from_this</code>, поэтому наследоваться нужно публично.</p>
<p><code>shared_from_this()</code> можно вызывать только от previously shared объектов, поэтому нельзя вызывать её внутри конструктора и деструктора. Конструктор обычного <code>shared_ptr</code> для объектов, которые наследуются от <code>enable_shared_from_this</code>, &quot;включает&quot; возможность создавать shared_from_this. При вызове <code>std::shared_ptr(U*)</code> для указателя на тип U, у которого есть unambiguos and accessible базовый класс, который является специализацией <code>std::enable_shared_from_this</code>, выполняется следующее:</p>
<pre><code class="language-c++">if (ptr != nullptr &amp;&amp; ptr-&gt;weak_this.expired())
  ptr-&gt;weak_this = std::shared_ptr&lt;std::remove_cv_t&lt;U&gt;&gt;(*this,
                                  const_cast&lt;std::remove_cv_t&lt;U&gt;*&gt;(ptr));
</code></pre>
<p>Поэтому, если от объекта не создавался <code>shared_ptr</code>, вызов функции <code>shared_from_this()</code>  начиная с C++17 бросит исключение <code>std::bad_weak_ptr</code>, а до C++17 ведёт к UB.</p>
<p>При этом, даже если объект наследуется от <code>enable_shared_from_this</code>, создание нескольких <code>shared_ptr</code> от указателя на один объект не гарантирует, что это будет эквивалентно вызовам <code>shared_from_this()</code> и является UB.</p>
<h3><a class="header" href="#Приведения-shared_ptr-к-указателям" id="Приведения-shared_ptr-к-указателям">Приведения shared_ptr к указателям</a></h3>
<p>В стандартной библиотеке <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast">реализованы</a> все 4 вида кастов (<code>static</code>, <code>dynamic</code>, <code>const</code>, <code>reinterpret</code>) для <code>shared_ptr</code> - они создают новый инстант <code>shared_ptr</code>, который хранит указатель приведённый соответствующим кастом и разделяет владение (счётчик ссылок) с исходным <code>shared_ptr</code>.</p>
<p>Внутри это выглядит так (на примере <code>static_cast</code>):</p>
<pre><code class="language-c++">template &lt;class T, class U&gt; 
std::shared_ptr&lt;T&gt; static_pointer_cast( const std::shared_ptr&lt;U&gt;&amp; r ) noexcept {
    auto p = static_cast&lt;typename std::shared_ptr&lt;T&gt;::element_type*&gt;(r.get());
    return std::shared_ptr&lt;T&gt;(r, p);
}
</code></pre>
<p><code>dynamic_cast</code> выглядит немного иначе - в случае &quot;неудачного каста&quot; (который возвращает <code>nullptr</code>) создаётся пустой <code>shared_ptr</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="15_intrusive_containers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="17_perfect_forwarding.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="15_intrusive_containers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="17_perfect_forwarding.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
