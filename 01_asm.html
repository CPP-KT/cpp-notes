<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Введение в ассемблер - C++ course notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html" class="active"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li class="chapter-item expanded "><a href="07_inheritance.html"><strong aria-hidden="true">8.</strong> Наследование (в т.ч. виртуальное), виртуальные функции</a></li><li class="chapter-item expanded "><a href="08_exceptions.html"><strong aria-hidden="true">9.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li class="chapter-item expanded "><a href="09_allocations_optimizations.html"><strong aria-hidden="true">10.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации</a></li><li class="chapter-item expanded "><a href="10_libraries.html"><strong aria-hidden="true">11.</strong> Статические и динамические библиотеки</a></li><li class="chapter-item expanded "><a href="11_undefined_behaviour.html"><strong aria-hidden="true">12.</strong> Undefined behaviour: примеры и способы его понимать</a></li><li class="chapter-item expanded "><a href="12_validation.html"><strong aria-hidden="true">13.</strong> Способы валидации программы</a></li><li class="chapter-item expanded "><a href="13_tools.html"><strong aria-hidden="true">14.</strong> Полезные инструменты, которые пригодятся вам в жизни</a></li><li class="chapter-item expanded "><a href="14_templates.html"><strong aria-hidden="true">15.</strong> Шаблоны (templates), tag-dispatching, SFINAE</a></li><li class="chapter-item expanded "><a href="15_stl.html"><strong aria-hidden="true">16.</strong> Обзор STL</a></li><li class="chapter-item expanded "><a href="16_namespaces_using_adl.html"><strong aria-hidden="true">17.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li class="chapter-item expanded "><a href="17_move_rvalue.html"><strong aria-hidden="true">18.</strong> Move-семантика, rvalue-ссылки</a></li><li class="chapter-item expanded "><a href="18_intrusive_containers.html"><strong aria-hidden="true">19.</strong> Интрузивные контейнеры</a></li><li class="chapter-item expanded "><a href="19_smart_pointers.html"><strong aria-hidden="true">20.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li class="chapter-item expanded "><a href="20_perfect_forwarding.html"><strong aria-hidden="true">21.</strong> Perfect forwarding, variadic templates</a></li><li class="chapter-item expanded "><a href="21_decltype_auto_nullptr.html"><strong aria-hidden="true">22.</strong> Decltype, declval, auto, nullptr</a></li><li class="chapter-item expanded "><a href="22_lambdas_type_erasure.html"><strong aria-hidden="true">23.</strong> Анонимные функции, type erasure, std::function</a></li><li class="chapter-item expanded "><a href="23_signals_reetrancy_errors.html"><strong aria-hidden="true">24.</strong> Сигналы, reetrancy, обработки ошибок</a></li><li class="chapter-item expanded "><a href="24_optional_variant_tuple_stringview.html"><strong aria-hidden="true">25.</strong> Optional, variant, tuple, string_view</a></li><li class="chapter-item expanded "><a href="25_constexpr.html"><strong aria-hidden="true">26.</strong> Статическая и динамическая инициализация, constexpr</a></li><li class="chapter-item expanded "><a href="26_multithreading.html"><strong aria-hidden="true">27.</strong> Многопоточность</a></li><li class="chapter-item expanded "><a href="27_qt.html"><strong aria-hidden="true">28.</strong> Qt</a></li><li class="chapter-item expanded "><a href="28_concepts.html"><strong aria-hidden="true">29.</strong> Концепты</a></li><li class="chapter-item expanded "><a href="29_ranges.html"><strong aria-hidden="true">30.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="30_encoding.html"><strong aria-hidden="true">31.</strong> Кодировки</a></li><li class="chapter-item expanded "><a href="31_coroutines.html"><strong aria-hidden="true">32.</strong> Корутины</a></li><li class="chapter-item expanded "><a href="32_modules.html"><strong aria-hidden="true">33.</strong> Модули</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">C++ course notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/cpp-kt/cpp-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Введение-в-ассемблер" id="Введение-в-ассемблер">Введение в ассемблер</a></h1>
<ul>
<li><a href="slides/lecture-1j.pdf">Слайды с лекции №1</a></li>
<li><a href="slides/lecture-2d.pdf">Слайды с лекции №2</a></li>
<li><a href="https://www.youtube.com/watch?v=bTgtesThdSg">Запись лекции №1</a></li>
<li><a href="https://www.youtube.com/watch?v=XY8xN1Ug1_k">Запись лекции №2</a></li>
</ul>
<hr />
<h2><a class="header" href="#Мотивация" id="Мотивация">Мотивация.</a></h2>
<p>На кой мы изучаем ассемблер и работу процессора в курсе по C++? А вот тому есть сразу несколько причин:</p>
<ol>
<li>Когда мы будем говорить про языковые конструкции, мы обсудим не только то, как они работают, но ещё и почему именно так. Почему, например, лямбды без списка захвата приводятся к указателю на функцию, а со списком — нет? Без изучения основ архитектуры компьютера, мы не сможем ответить на этот вопрос, а с этим изучением просто не сможем представить себе, как может быть иначе.</li>
<li>Есть более практический аспект: если вы что-то желаете ускорить, то высокоуровневые оптимизации (убрать ненужное действие, не считать что-то дважды) — это легко, а более низкоуровневые вообще нельзя сделать без знаний того, как внутри компьютер работает.</li>
<li>Ещё основы архитектуры компьютера пригодятся при отладке. Если программа работает не так, то для понимания, где же именно ошибка, нам требуется понимать, что внутри процессора происходит.</li>
<li>И наконец есть более философская полезность: если вы чем-то пользуетесь, то чем лучше вы разбираетесь, как оно работает, тем грамотнее можете этим пользоваться. То же самое с библиотеками, например (если библиотека что-то умеет, а вы не знаете об этом, вы начинаете городить костыли). Например, в x86 есть специальная инструкция с длинной арифметикой, и лучше бы писать такой код, чтобы компилятор догадался пользоваться ей.</li>
</ol>
<h2><a class="header" href="#Базовое-представление-об-устройстве-оперативной-памяти" id="Базовое-представление-об-устройстве-оперативной-памяти">Базовое представление об устройстве оперативной памяти.</a></h2>
<p>В нашем курсе мы построим некоторую простую модель компьютера, а потом будет её изучать и уточнять по необходимости. В нашей простой модели оперативная память — массив чисел в диапазоне $[0:255]$. Вы умеете обращаться к этому массиву по индексу. Этот индекс называется <em>адресом в памяти</em>. <strong>Обращаться к конкретному биту вы не умеете</strong>, и притом даже не знаете, какой бит у числа в начале, а какой — в конце.</p>
<p>Как в этой модели исполняется программа? Следующим образом: у процессора есть регистр <code>IP</code> (instruction pointer), где записан адрес той инструкции, которую надо исполнять. При её исполнении значение в регистре увеличивается, тем самым начиная указывать на следующую инструкцию.</p>
<h2><a class="header" href="#Ассемблер" id="Ассемблер">Ассемблер.</a></h2>
<p>Помимо регистра <code>IP</code>, процессор имеет ещё 8 регистров, которые, в отличие от <code>IP</code> являются регистрами общего назначения (т.е. пользоваться ими вы можете как вам хочется). Эти регистры имеют название... Стоп, а зачем регистрам название? А потому что вам иногда надо прописывать процессорные инструкции руками, а запоминать последовательности байтов вы не хотите. И для этого были придуманы системы человеко-читаемых мнемоник, называемых <em>ассемблером</em>. При этом <strong>мнемоники различаются в зависимости от инструмента, которым вы пользуетесь</strong>, а не только в зависимости от системы. Впрочем, на одной архитектуре мнемоники в любом случае достаточно схожи.</p>
<h3><a class="header" href="#Полезные-инструменты" id="Полезные-инструменты">Полезные инструменты.</a></h3>
<p>Чтобы увидеть, во что ваш компилятор превращает ваш код, пишите <code>g++ -S -masm=intel ...</code>, после чего вам создадут <code>.s</code> файл с ассемблерными командами. Или можно использовать https://godbolt.org, куда можно запихнуть разные компиляторы, параметры оптимизации и прочее, и сразу увидеть результат (причём понятнее, чем в <code>g++</code>). Ещё, кстати, на https://godbolt.org можно навести на команду и узнать информацию по ней. Если нужно больше информации об ассемблерной инструкции — зайдите на https://felixcloutier.com/x86/.</p>
<h2><a class="header" href="#Регистры" id="Регистры">Регистры.</a></h2>
<p>Итак, помимо регистра <code>IP</code>, процессор имеет ещё 8 регистров, которые, в отличие от <code>IP</code> <strong>являются регистрами общего назначения (т.е. пользоваться ими вы можете как вам хочется)</strong>. Эти регистры имеют название <code>AX</code>, <code>CX</code>, <code>DX</code>, <code>BX</code>, <code>SP</code>, <code>BP</code>, <code>SI</code>, <code>DI</code>. Каждый из них имеет 16 битную разрядность, а последние 4 ещё и некий особый смысл, к которому скоро перейдём. Помимо них также есть следующее:</p>
<ul>
<li><strong>8-битные версии регистров</strong>: <code>AL</code>, <code>AH</code>, <code>BL</code>, <code>BH</code>, <code>CL</code>, <code>CH</code>, <code>DL</code>, <code>DH</code>, <code>SPL</code>, <code>BPL</code>, <code>DIL</code>, <code>SIL</code>. Для регистров <code>*X</code> его старшие 8 бит называются <code>*H</code>, а младшие — <code>*L</code>. У оставшихся четырёх есть только младшие, получаемые дописыванием <code>L</code> к названию регистра.</li>
<li><strong>32-битные версии регистров</strong> (since 1985): <code>EAX</code>, <code>EBX</code>, ..., <code>EDI</code>. (Приставка &quot;<code>E</code>&quot; обозначает &quot;<em>extended</em>&quot;.) Оригинальные 16-битные регистры являются младшей частью расширенных.</li>
<li><strong>64-битные версии регистров</strong> (since 2003): <code>RAX</code>, <code>RBX</code>, ..., <code>RDI</code>. (Приставка &quot;<code>R</code>&quot; обозначает &quot;<em>re-extended</em>&quot;.) &quot;Расширенные&quot; 32-битные регистры являются младшей частью пере-расширенных.</li>
<li><strong>Дополнительный набор регистров</strong> (x86-64): <code>R8</code>, <code>R9</code>, ..., <code>R15</code>, <code>R8D</code>, <code>R9D</code>, ..., <code>R15D</code>, <code>R8W</code>, <code>R9W</code>, ..., <code>R15W</code>, <code>R8B</code>, <code>R9B</code>, ..., <code>R15B</code>. Регистры <code>R*</code> имеют 64-битную ширину, <code>R*D</code> (от слова &quot;<em>dword</em>&quot;) — младшие 32 бита соответствующего регистра, <code>R*W</code> (от слова &quot;<em>word</em>&quot;) — младшие 16, <code>R*B</code> (от слова &quot;<em>byte</em>&quot;) — младшие 8.</li>
</ul>
<p><img src="./images/01-asm/Registers.svg" alt="Схема устройства регистров" /></p>
<h2><a class="header" href="#Команда-mov" id="Команда-mov">Команда <code>mov</code>.</a></h2>
<p><code>mov dst, src</code> является простым присваиванием <code>dst = src</code>. В качестве её аргументов могут выступать регистры, константы или даже места в памяти. По поводу последнего: если вы хотите положить в регистр <code>AX</code> число десять, это пишется так: <code>mov AX, 10</code>, а если значение в десятой ячейке памяти, то адрес берётся в квадратные скобки: <code>mov AX, [10]</code>. Также в квадратные скобки можно брать регистр.</p>
<p>Все эти разные типы аргументов команды <code>mov</code> на самом деле даже по-разному кодируются. Как пример, присваивание числа в регистр и регистра в регистр занимают 2 и 5 байтов соответственно:</p>
<pre><code class="language-nasm">89 C2         		mov		edx, eax	; EDX = EAX
B8 05 00 00 00		mov		eax, 5		; EAX = 5
</code></pre>
<p>Некоторые сочетания закодировать нельзя никак (например, <code>mov [AX], [BX]</code>). А если детальнее, то возможны вот такие комбинации регистров (<code>reg</code>) и чисел (<code>imm</code>):</p>
<ul>
<li><code>mov reg, reg</code></li>
<li><code>mov reg, imm</code></li>
<li><code>mov reg, [reg]</code></li>
<li><code>mov reg, [imm]</code></li>
<li><code>mov [reg], reg</code></li>
<li><code>mov [imm], reg</code></li>
<li><code>mov [reg], imm</code></li>
<li><code>mov [imm], imm</code></li>
</ul>
<p>Возникает вопрос. Регистр <code>AX</code> шестнадцати-битный, а адрес указывает на байт. Значит при выполнении команды <code>mov</code> нужно откуда-то взять ещё 8 бит. А вот <strong>читается не только тот адрес, который запросили, но ещё и следующий</strong>. Но какой из прочитанных байт старший, а какой — младший? В разных архитектурах возможны разные варианты.</p>
<ul>
<li>Если значения в меньшем адресе являются младшими разрядами, то это называется <em>little-endian</em>.</li>
<li>Если значения в большем адресе являются младшими разрядами, то это называется <em>big-endian</em>.</li>
</ul>
<p><u>Пример</u>: Если в ячейке с номером 100 записан байт <code>0x6C</code>, а с номером 101 — <code>0xAA</code>, то в LE при чтении ячейки <code>[100]</code> мы получим число <code>0xAA6C</code>, а в BE — <code>0x6CAA</code>.</p>
<p><strong>В x86 используется только little-endian.</strong></p>
<h2><a class="header" href="#Команды-арифметики" id="Команды-арифметики">Команды арифметики.</a></h2>
<h3><a class="header" href="#Базовые-бинарные-операции" id="Базовые-бинарные-операции">Базовые бинарные операции.</a></h3>
<p>Процессор умеет выполнять базовые бинарные операции, которые в ассемблере называются <code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>xor</code>. Все они работают как комбинация операции и присваивания (т.е. соответственно <code>+=</code>, <code>-=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>). <strong>Совершать операции можно только с числами одинакового размера</strong> (как и с <code>mov</code>). Для бинарных операций возможны такие комбинации регистров и чисел, как и для <code>mov</code> (см. выше).</p>
<h3><a class="header" href="#Унарные-операции" id="Унарные-операции">Унарные операции.</a></h3>
<p>Простые унарные операции <code>inc</code>, <code>dec</code>, <code>not</code>, <code>neg</code> также работают как операция с присваиванием (то есть соответственно, <code>x = x + 1</code>, <code>x = x - 1</code>, <code>x = ~x</code>, <code>x = -x</code>). Понятно, что в случае, когда мы оперируем с ячейками памяти, надо явно уточнить, с числами какого размера производится операция. В ассемблере это пишется, например, так <code>inc byte [addr]</code>. <code>byte</code> подразумевает 8 бит. Вместо него можно написать <code>word</code>, <code>dword</code> или <code>qword</code>, подразумевая соответственно 2, 4 и 8 байтов.</p>
<h3><a class="header" href="#Умножение-и-деление" id="Умножение-и-деление">Умножение и деление.</a></h3>
<p>Умножение принимает один аргумент, умножая его на регистр <code>AL</code>/<code>AX</code>/<code>EAX</code>/<code>RAX</code>. Результат умножения занимает вдвое больше знаков, чем аргумент и записывается либо в регистр <code>AX</code> (для 8-битного), либо в пары регистров <code>DX:AX</code>, <code>EDX:EAX</code>, <code>RDX:RAX</code> (для 16-, 32- и 64-битного соответственно). <code>DX</code> — старшая половина разрядов.</p>
<p>Несложно заметить, что в отличие от сложения и вычитания, умножение и деление разное для знаковых и беззнаковых чисел. Поэтому существуют два разных умножения (<code>mul</code> и <code>imul</code>) и два разных деления (<code>div</code> и <code>idiv</code>). Первое для беззнаковых чисел, второе — для знаковых.</p>
<p>Деление работает схожим образом. Оно принимает делимое из <code>AX</code>/<code>DX:AX</code>/<code>EDX:EAX</code>/<code>RDX:RAX</code>, делитель как аргумент, а частное возвращает в регистр <code>AL</code>/<code>AX</code>/<code>EAX</code>/<code>RAX</code>. Но также деление возвращает остаток, и его оно возвращает в <code>AH</code>/<code>DX</code>/<code>EDX</code>/<code>RDX</code>.</p>
<p>Вопрос: как поделить друг на друга числа одинакового размера? Ну, нужно преобразовать, например, 16-битное число в 32-битное. В случае, если числа беззнаковые, надо просто обнулить <code>DX</code> (<strong>обычно регистр обнуляется при помощи <code>xor DX, DX</code>, потому что эта инструкция занимает меньше памяти, нежели <code>mov DX, 0</code></strong>). Те, кто знают, как работает дополнение до 2, также знают, что нужно делать в знаковом случае. Нужно заполнить <code>DX</code> знаковым битом <code>AX</code>. Для этого в x86 есть специальная инструкция <code>cwd</code>. Для того чтобы сделать то же самое с <code>EDX</code> и <code>RDX</code>, есть инструкции <code>cdq</code> и <code>cqo</code> соответственно.</p>
<p>Хорошо, про деление мы знаем уже почти всё, кроме того, что будет, если мы поделим на 0. Или если результат в нужные регистры не поместится. Обе эти ситуации приводят к системным прерываниям, которые работают следующим образом: процессор имеет массив IDTR (<strong>Interrupt Descriptor Table Register</strong>), в котором для каждого типа прерывания сказано, что с ним делать. Этот массив при запуске подготавливает операционная система.</p>
<h3><a class="header" href="#Сдвиги" id="Сдвиги">Сдвиги.</a></h3>
<p>Ещё в x86 есть</p>
<ul>
<li><strong><code>SHL</code>/<code>SAL</code> — сдвиг влево</strong></li>
<li><strong><code>SHR</code> — логический сдвиг вправо (оставляет на пустых местах нули)</strong></li>
<li><strong><code>SAR</code> — арифметический сдвиг справа (на пустые места пихает знаковый бит)</strong>.</li>
</ul>
<p>В C++ для беззнаковых используется <code>SHL</code> и <code>SHR</code>, а для знаковых — <code>SAL</code> и <code>SAR</code>.</p>
<h2><a class="header" href="#Оптимизации-компилятора" id="Оптимизации-компилятора">Оптимизации компилятора.</a></h2>
<p>Давайте забьём в https://godbolt.org следующий код:</p>
<pre><code class="language-c++">int foo(int a, int b) {
    return a + b;
}
int bar(int a, int b) {
    return a - b;
}
</code></pre>
<p>В результате увидим нечто неизвестное:</p>
<pre><code class="language-nasm">f(int, int):
    lea     EAX, [RDI+RSI]
    ret
g(int, int):
    mov     EAX, EDI
    sub     EAX, ESI
    ret
</code></pre>
<p>Несложно догадаться, что обе функции получают свои аргументы в регистрах <code>EDI</code> и <code>ESI</code>, а возвращают — в <code>EAX</code>. Но непонятно, что такое <code>LEA</code>.</p>
<h3><a class="header" href="#Команда-lea" id="Команда-lea">Команда <code>LEA</code>.</a></h3>
<p><code>LEA</code> расшифровывается как &quot;<em>load effective address</em>&quot; и вторым её аргументом всегда является адрес памяти. Именно этот адрес присваивается в первый аргумент инструкции. Здесь она используется как альтернатива <code>ADD</code>+<code>MOV</code>.</p>
<p>Как несложно заметить, в качестве адреса можно писать сумму значений в регистрах. А что ещё можно? А вот что: <strong><code>[reg+i*reg+const]</code> где <code>i</code> равно <code>1</code>, <code>2</code>, <code>4</code> или <code>8</code></strong>.</p>
<p><strong>Еще <code>LEA</code> не трогает флаги, в отличие от <code>ADD</code>.</strong> Что такое флаги — смотри дальше. Детальнее про <code>LEA</code> можно почитать <a href="https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction">здесь</a> (первые 2 ответа).</p>
<h3><a class="header" href="#Как-delизбегаетсяdel-оптимизируется-деление" id="Как-delизбегаетсяdel-оптимизируется-деление">Как <del>избегается</del> оптимизируется деление:</a></h3>
<p>Деление занимает много больше тактов, чем другие арифметические операции, а во время его вычисления весь конвейер стоит. Компиляторы стараются избегать операции деления, если это возможно. Например, мы знаем, что <strong>беззнаковое</strong> деление или умножение на $2^k$ можно легко заменить на сдвиг на $k$. Поэтому следующий код на C++:</p>
<pre><code class="language-c++">unsigned foo(unsigned a) // беззнаковый тип
{
    return a / 2;
}
</code></pre>
<p>Может быть оптимизирован компилятором до</p>
<pre><code class="language-nasm">foo(unsigned int):
    mov     EAX, EDI
    shr     EAX
    ret
</code></pre>
<p>А вот просто сдвинуть знаковое число вместо деления нельзя, потому что у этих двух операций округления в разные стороны. Поэтому тот же код, но с сигнатурой <code>int foo(int a)</code> скомпилируется так:</p>
<pre><code class="language-nasm">foo(int):
	mov     EAX, EDI
	shr     EAX, 31  ; Оставляем от числа только старший (знаковый) бит.
	add     EAX, EDI ; Если число отрицательное, то добавляем 1 (чтобы при a = -1 всё работало).
	sar     EAX      ; Арифметический сдвиг вправо на 1 бит.
ret
</code></pre>
<p>А что будет с беззнаковым делением на 3? А тут есть другие хаки:</p>
<pre><code class="language-nasm">foo(unsigned int):
    mov     EAX, EDI
    mov     EDX, 2863311531 ; 0xAAAAAAAB или 2^33/3
    imul    RDX
    shr     RAX, 33
    ret
</code></pre>
<p>Почему это лучше? Как мы уже обсудили, деление дорогое, а константу можем посчитать при компиляции, получая выигрыш в эффективности.</p>
<p>Почему это работает? Потому что при арифметике с переполнением деление на константу можно выполнить через умножение:
$$\frac a3=\frac{a\cdot(2^{33}/3)}{2^{33}} = (a\cdot2863311531) \gg 33$$
А в общем случае компиляторы пытаются подобрать $n$ (равное тут $33$), чтобы такая замена работала как требуется. Больше подобного рода трюков можно почитать в книжке Hacker's Delight.</p>
<h2><a class="header" href="#control-flow" id="control-flow">Control-flow.</a></h2>
<p>Мы уже понимаем, что компилятор делает с арифметическими выражениями, а значит линейный код мы уже можем перевести на ассемблер руками. А вот ветвления и циклы — пока нет. Как они идейно работают? У процессора есть команды, которые называются branch’ами. Самая простая из них — <code>jmp</code> (своего рода <code>goto</code>). Её аргументом является число, которое нужно прибавить к <code>IP</code>, чтобы перейти на адрес новой инструкции. В ассемблере, однако, это вместо этого пишется метка, по которой и осуществляется переход.</p>
<pre><code class="language-nasm">.loop: ; метка
    inc     AX
    jmp     .loop
</code></pre>
<p>Помимо <code>jmp</code> есть <em>conditional branch</em> (то есть переход, если выполнено какое-то условие). Осуществляются они комбинацией команды <code>cmp</code> и какой-то из команд <code>je</code>, <code>jg</code>, <code>jl</code> или подобной. Первая команда (пока непонятным нам образом) сравнивает два регистра, а потом вторая получает результат этого сравнения и совершает переход только в определённом случае. В таблице ниже перечислены условия
для каждой из команд:</p>
<!-- https://www.tablesgenerator.com/markdown_tables -->
<table><thead><tr><th align="center">Команда</th><th align="center">Эквивалент</th><th align="center">Расшифровка</th></tr></thead><tbody>
<tr><td align="center"><code>je</code></td><td align="center"><code>left == right</code></td><td align="center">jump if equal</td></tr>
<tr><td align="center"><code>jg</code></td><td align="center"><code>(signed)left &gt; (signed)right</code></td><td align="center">jump if greater</td></tr>
<tr><td align="center"><code>jl</code></td><td align="center"><code>(signed)left &lt; (signed)right</code></td><td align="center">jump if less</td></tr>
<tr><td align="center"><code>ja</code></td><td align="center"><code>(unsigned)left &gt; (unsigned)right</code></td><td align="center">jump if above</td></tr>
<tr><td align="center"><code>jb</code></td><td align="center"><code>(unsigned)left &lt; (unsigned)right</code></td><td align="center">jump if below</td></tr>
<tr><td align="center"><code>jne</code></td><td align="center"><code>left != right</code></td><td align="center">jump if not equal</td></tr>
<tr><td align="center"><code>jng</code></td><td align="center"><code>(signed)left &lt;= (signed)right</code></td><td align="center">jump if not greater</td></tr>
<tr><td align="center"><code>jnl</code></td><td align="center"><code>(signed)left &gt;= (signed)right</code></td><td align="center">jump if not less</td></tr>
<tr><td align="center"><code>jna</code></td><td align="center"><code>(unsigned)left &lt;= (unsigned)right</code></td><td align="center">jump if not above</td></tr>
<tr><td align="center"><code>jnb</code></td><td align="center"><code>(unsigned)left &gt;= (unsigned)right</code></td><td align="center">jump if not below</td></tr>
</tbody></table>
<h3><a class="header" href="#Регистры-флагов-flags-registers" id="Регистры-флагов-flags-registers">Регистры флагов (FLAGS Registers).</a></h3>
<p>Теперь давайте всё же поговорим, как работает <code>cmp</code>? Для этого нам нужно поговорить о такой штуке как регистр флагов. Он содержит, собственно, битовые флаги. Из их большого набора нас интересуют</p>
<ul>
<li>CF — carry flag.</li>
<li>ZF — zero flag.</li>
<li>SF — sign flag.</li>
<li>OF — overflow flag.</li>
</ul>
<p>В процессе своей работы разные инструкции устанавливают различные флаги (какие-то инструкции на определённые флаги не влияют, у каких-то инструкций эти флаги имеют свое значение, поэтому читайте документацию). А мы рассмотрим, как
с ними работают инструкции <code>add</code> и <code>sub</code>. Они выставляют:</p>
<ul>
<li>ZF — если результат равен 0.</li>
<li>SF — если результат отрицательный.</li>
<li>CF — если произошёл перенос в сложении/заимствование в вычитании беззнаковых чисел.</li>
<li>OF — если знаковая операция вызвала переполнение.</li>
</ul>
<p>С флагами можно взаимодействовать не только при помощи уже обсуждённых инструкций условного перехода, но и, например, при помощи команды <code>adc</code>, которая выполняет сложение, но также добавляет к результату CF.</p>
<p>Или есть ещё <strong>команды перехода, основанные на флагах</strong>:</p>
<ul>
<li><code>jz</code> — jump if ZF.</li>
<li><code>js</code> — jump if SF.</li>
<li><code>jc</code> — jump if CF.</li>
<li><code>jo</code> — jump if OF.</li>
<li><code>jnz</code> — jump if not ZF.</li>
<li><code>jns</code> — jump if not SF.</li>
<li><code>jnc</code> — jump if not CF.</li>
<li><code>jno</code> — jump if not OF.</li>
</ul>
<h3><a class="header" href="#Как-работают-арифметические-условные-переходы" id="Как-работают-арифметические-условные-переходы">Как работают арифметические условные переходы.</a></h3>
<p><code>cmp</code> устанавливает флаги так же, как это делает вычитание. Отсюда посмотрим, какие флаги проверяются какими условными переходами.</p>
<p>Про <code>je</code>, <code>jb</code> и <code>ja</code> всё понятно. <code>je</code> выполняется при ZF, <code>jb</code> — при CF, <code>ja</code> — если ZF и CF оба ложны. А что с <code>jl</code> и <code>jg</code>, сейчас обсудим.</p>
<p>Давайте рассмотрим числа из 3 бит простоты и наглядности ради, и пометим цветом те места, где <code>CMP</code> задаёт определённые флаги. ZF — очевидно.</p>
<p><img src="./images/01-asm/CMP-ZF.svg" alt="CMP-ZF" /></p>
<p>Теперь посмотрим на SF. Если мы вычитаем из маленького числа число чуть побольше, то результат будет отрицательным. Но если мы, например, из $-8$ вычитаем что-то, то происходит переполнение, и результат получается положительным. Аналогично если мы из положительного числа вычитаем большое отрицательное, может произойти переполнение в обратную сторону, и результат станет отрицательным. Учитывая это, имеем, что SF задан в этой области:</p>
<p><img src="./images/01-asm/CMP-SF.svg" alt="CMP-SF" /></p>
<p>А ещё мы уже обсудили переполнение, и можем сказать, где задан OF:</p>
<p><img src="./images/01-asm/CMP-OF.svg" alt="CMP-OF" /></p>
<table><thead><tr><th align="center">Ветвление</th><th align="center">Условие</th></tr></thead><tbody>
<tr><td align="center"><code>je</code></td><td align="center"><code>ZF</code></td></tr>
<tr><td align="center"><code>jg</code></td><td align="center"><code>(SF == OF) &amp;&amp; !ZF</code></td></tr>
<tr><td align="center"><code>jl</code></td><td align="center"><code>SF != OF</code></td></tr>
<tr><td align="center"><code>ja</code></td><td align="center"><code>!CF &amp;&amp; !ZF</code></td></tr>
<tr><td align="center"><code>jb</code></td><td align="center"><code>CF</code></td></tr>
</tbody></table>
<p>Кстати, несмотря на то, что в ассемблере есть <code>je</code> и <code>jz</code>, по сути они делают одно и то же, и даже одинаковым набором байт обозначаются (поэтому <strong>если вы будете ассемблировать-дизассемблировать код, учтите, что в коде ASM <code>je</code> может замениться на <code>jz</code> или наоборот</strong>).</p>
<p>Помимо <code>cmp</code> есть ещё одна инструкция, которая не делает ничего, кроме расстановки флагов — <code>test</code>. Она делает побитовое &quot;И&quot; аргументам и ставит:</p>
<ul>
<li>ZF, если результат равен нулю.</li>
<li>SF, если результат отрицательный.</li>
<li>CF, никогда (всегда ставится в <code>false</code>).</li>
<li>OF, никогда (всегда ставится в <code>false</code>).</li>
</ul>
<p><u>Пример</u>:</p>
<pre><code class="language-nasm">	test	AX, AX ; проверка на 0
	jz		label
</code></pre>
<p>Иногда ни <code>test</code>, ни <code>cmp</code> не нужны, потому что многие инструкции ставят флаги, и иногда так, как вам нужно.
<u>Пример</u>:</p>
<pre><code class="language-nasm">.loop:
	mov		DX, AX
	add		AX, BX
	mov		BX, DX
	dec		CX
	jnz		.loop
</code></pre>
<h2><a class="header" href="#Работа-с-функциями" id="Работа-с-функциями">Работа с функциями.</a></h2>
<h3><a class="header" href="#Основы-работы-со-стеком" id="Основы-работы-со-стеком">Основы работы со стеком.</a></h3>
<p>Вопрос на засыпку: как реализовать рекурсию? Да и в принципе, вызов функций? Мы выходим только из той функции, в которую зашли последней. Это, барабанная дробь, <em>стек</em>. Стек — это кусочек памяти, <strong>его вершина имеет меньший адрес</strong>, а дно — больший. На вершину стека указывает регистр <code>SP</code>, название которого так и расшифровывается — <em>stack pointer</em>.</p>
<p>Процессор предоставляет две базовые функции работы со стеком — <code>push</code> и <code>pop</code>. Несложно догадаться, что <code>push src</code> равносильно</p>
<pre><code class="language-nasm">    sub     RSP, 8
	mov     [RSP], src
</code></pre>
<p>А <code>pop dst</code> — </p>
<pre><code class="language-nasm">    mov     dst, [RSP]
    add     RSP, 8
</code></pre>
<p>Ещё есть две &quot;более высокоуровневые&quot; инструкции — <code>call</code> и <code>ret</code>. Первая принимает своим единственным аргументом метку (адрес функции, которую нужно вызвать), кладёт на стек адрес следующей инструкции и делает переход по метке. Вторая берёт со стека адрес и переходит по нему. Несложно заметить, что именно так функции и работают. Честно написать, чему эти инструкции равносильны, невозможно, потому что нельзя лёгким образом получить доступ к <code>IP</code>.</p>
<h3><a class="header" href="#Передача-параметров-в-функцию" id="Передача-параметров-в-функцию">Передача параметров в функцию.</a></h3>
<p>Быстрее и проще всего положить параметры в регистры (например, <code>EDI</code> и <code>ESI</code>). Но регистров у нас конечное число, поэтому если параметров много, то может не хватить. В таком случае параметры можно передавать через стек. И чтобы получить их, мы делаем <code>mov RAX, [RSP+8]</code> или <code>mov RAX [RSP+16]</code>. Но после возвращения из функции, у нас параметры всё ещё на стеке, надо, чтобы кто-то его почистил. Можем
сделать так, чтобы вызывающая функция почистила стек, прибавляя константу к <code>RSP</code> каждый раз после вызова. Но не лучше ли запихнуть это в вызываемую функцию? Ну, идейно да, но надо куда-то сохранить возвращаемое значение... В x86 вообще есть <code>ret n</code>, который берёт значение, сдвигает <code>RSP</code> на <code>n</code> и возвращается. Это называется «вызываемая функция чистит стек». Осталось понять, что делать с локальными переменными? А, их можно положить выше на стек после адреса возврата.</p>
<h3><a class="header" href="#abi" id="abi">ABI</a></h3>
<p>Хорошо, а кто определяет, как передавать параметры? А этим занимается <em>ABI</em> - application binary interface. ABI содержит вообще всю информацию, необходимую для взаимодействия, например, вас с операционной системой.</p>
<ul>
<li>Выравнивание и размеры типов данных.</li>
<li>Соглашение о передаче параметров, о том, кто чистит стек, о том, в каком порядке параметры на стек кладутся.</li>
<li>Как выполняются системные вызовы.</li>
<li>Наличие <code>red zone</code> (например, она есть на 64-битных линуксах)</li>
</ul>
<p>Что такое <code>red zone</code>? Это кусок памяти ниже указателя стека, который никто, кроме нас, не имеет права использовать. На 64-битных линуксах размер этого куска — 128 байт. То есть можно безопасно использовать 128 байт ниже стека, никто ничего с ними не сделает при системном прерывании.</p>
<p>Заметим, что на x86 Windows <code>red zone</code>'ы нет.</p>
<p>А почему нельзя использовать память ниже стека, если нет <code>red zone</code>? Потому что не гарантируется, что память ниже стека никто не будет использовать. Например, обработчик прерываний использует стек, кладёт туда свои данные.</p>
<p>Всё это — ABI. Обычно он привязан к ОС.</p>
<p>Windows из данного правила является исключением: в нём есть <a href="https://docs.microsoft.com/en-gb/cpp/cpp/argument-passing-and-naming-conventions">целая табличка</a> о том, какой из миллиона (<code>cdecl</code>, <code>stdcall</code>, <code>thiscall</code>, <code>fastcall</code>, ...) способов передавать параметры, что делает. И можно в коде прямо на функции явно написать, какой способ использовать. Даже свой собственный можете сделать.</p>
<p>А кто, кстати, обычно чистит стек? Вызывающая функция. Почему так, это же, вроде как, неудобно? Потому что существуют variadic-функции. Когда вы делаете <code>printf</code>, компилятор просто пихает параметры на стек, а вызываемая функция не знает, сколько их. Поэтому чистит вызывающая, которая знает.</p>
<h4><a class="header" href="#Системные-вызовы" id="Системные-вызовы">Системные вызовы.</a></h4>
<p><code>syscall</code> - интерфейс взаимодействия процесса программы с ядром ОС. Например, это чтение/запись в файл/терминал, завершение программы с кодом ошибки и т.д.</p>
<h3><a class="header" href="#Стековый-фрейм" id="Стековый-фрейм">Стековый фрейм.</a></h3>
<p>Можно заметить, что под GCC код</p>
<pre><code class="language-c++">int foo(char const*);

int bar()
{
    char arr[40];
    return foo(arr) + 1;
}
</code></pre>
<p>с флагами <code>-O2 -fno-omit-frame-pointer</code> компилируется во что-то такое:</p>
<pre><code class="language-nasm">bar():
	push	RBP
	mov		RBP, RSP
	sub		RSP, 48

    lea     RDI, [RBP-48]
    call    foo(char const*)

	mov		RSP, RBP
	pop		RBP
	ret
</code></pre>
<p>Нам интересна обёртка <code>push RBP</code>, <code>mov RBP, RSP</code>, ..., <code>pop RBP</code>. Зачем это? Посмотрим, что делает этот код. Он сохраняет старое значение <code>RBP</code> на стек. А при вызове рекурсивной функции в <code>RBP</code> будет <code>RSP</code>. То есть во внутренней функции мы запихаем на стек адрес первой. И так далее. То есть на стеке есть односвязный список значений <code>RBP</code> от нового к старому. Поэтому пойдя по <code>RBP</code>, можем напечатать весь стек (это называется <em>unwind</em> — <em>раскрутка</em> стека). Буквально так очень давно работали отладчики. В наше время этот режим менее актуален, поэтому генерировать эти инструкции избыточно. Вместо этого компиляторы вместе с кодом генерируют отладочную информацию как раз о том, какие команды каким строкам кода соответствуют, как раскручивать стек и подобное. gcc генерирует стековый фрейм только с некоторым ключом. MSVC генерирует его по умолчанию. Возможно, это потому, что рандомная опубликованная exe'шка может в отладочных данных содержать секретики. Их вы публиковать не хотите, поэтому только стековые фреймы. К чему это всё для нас? Если вы пользуетесь какими-то инструментами, которые снимают стек (отладчик или профилировщик), убедитесь, что у
вас есть отладочные символы, и отлаживаете вы тоже согласно им. Либо и то, и другое по стековому фрейму.</p>
<h3><a class="header" href="#Выделение-памяти" id="Выделение-памяти">Выделение памяти:</a></h3>
<pre><code class="language-c++">void f(char const*);

void g()
{
    char arr[113];
    f(arr);
}
</code></pre>
<p>Компилируется в:</p>
<pre><code class="language-nasm">g():
    sub     RSP, 136
    mov     RDI, RSP
    call    f(char const*)
    add     RSP, 136
    ret
</code></pre>
<p>К локальным переменным обращаемся через <code>RSP</code>, лежат на стеке. Размер стека - переменная на уровне операционной системы (вроде).</p>
<p>Обратим внимание на то, что если изменить размер массива на <strong>112</strong>, то этот код скомпилируется в:</p>
<pre><code class="language-nasm">g():
    sub     RSP, 120
    mov     RDI, RSP
    call    f(char const*)
    add     RSP, 120
    ret
</code></pre>
<p>Почему <code>136</code> изменилось на <code>120</code>? Этот эффект называется выравниванием (alignment).</p>
<p>В качестве основной единицы работы с памятью используется <em>машинное слово</em>, размер которого обычно составляет несколько байт. Так называемый <em>unaligned access</em> сложен в реализации на аппаратном уровне, поэтому обращения по произвольному адресу либо не поддерживаются (и вызывают исключение процессора), либо поддерживаются, но работают медленно. Обычно компилятор выравнивает данные по границам машинных слов, в нашем случае <code>8 + 16 * k</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="course.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="02_os_cpu.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="course.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="02_os_cpu.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
