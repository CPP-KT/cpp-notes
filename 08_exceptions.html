<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Исключения, гарантии безопасности исключений, RAII - C++ course notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li class="chapter-item expanded "><a href="07_inheritance.html"><strong aria-hidden="true">8.</strong> Наследование (в т.ч. виртуальное), виртуальные функции</a></li><li class="chapter-item expanded "><a href="08_exceptions.html" class="active"><strong aria-hidden="true">9.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li class="chapter-item expanded "><a href="09_allocations_optimizations.html"><strong aria-hidden="true">10.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации</a></li><li class="chapter-item expanded "><a href="10_libraries.html"><strong aria-hidden="true">11.</strong> Статические и динамические библиотеки</a></li><li class="chapter-item expanded "><a href="11_undefined_behaviour.html"><strong aria-hidden="true">12.</strong> Undefined behaviour: примеры и способы его понимать</a></li><li class="chapter-item expanded "><a href="12_validation.html"><strong aria-hidden="true">13.</strong> Способы валидации программы</a></li><li class="chapter-item expanded "><a href="13_tools.html"><strong aria-hidden="true">14.</strong> Полезные инструменты, которые пригодятся вам в жизни</a></li><li class="chapter-item expanded "><a href="14_templates.html"><strong aria-hidden="true">15.</strong> Шаблоны (templates)</a></li><li class="chapter-item expanded "><a href="15_stl.html"><strong aria-hidden="true">16.</strong> Обзор STL, tag-dispatching, SFINAE</a></li><li class="chapter-item expanded "><a href="16_namespaces_using_adl.html"><strong aria-hidden="true">17.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li class="chapter-item expanded "><a href="17_move_rvalue.html"><strong aria-hidden="true">18.</strong> Move-семантика, rvalue-ссылки</a></li><li class="chapter-item expanded "><a href="18_intrusive_containers.html"><strong aria-hidden="true">19.</strong> Интрузивные контейнеры</a></li><li class="chapter-item expanded "><a href="19_smart_pointers.html"><strong aria-hidden="true">20.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li class="chapter-item expanded "><a href="20_perfect_forwarding.html"><strong aria-hidden="true">21.</strong> Perfect forwarding, variadic templates</a></li><li class="chapter-item expanded "><a href="21_decltype_auto_nullptr.html"><strong aria-hidden="true">22.</strong> Decltype, declval, auto, nullptr</a></li><li class="chapter-item expanded "><a href="22_lambdas_type_erasure.html"><strong aria-hidden="true">23.</strong> Анонимные функции, type erasure, std::function</a></li><li class="chapter-item expanded "><a href="23_signals_reetrancy_errors.html"><strong aria-hidden="true">24.</strong> Сигналы, reetrancy, обработки ошибок</a></li><li class="chapter-item expanded "><a href="24_optional_variant_tuple_stringview.html"><strong aria-hidden="true">25.</strong> Optional, variant, tuple, string_view</a></li><li class="chapter-item expanded "><a href="25_constexpr.html"><strong aria-hidden="true">26.</strong> Статическая и динамическая инициализация, constexpr</a></li><li class="chapter-item expanded "><a href="26_multithreading.html"><strong aria-hidden="true">27.</strong> Многопоточность</a></li><li class="chapter-item expanded "><a href="27_qt.html"><strong aria-hidden="true">28.</strong> Qt</a></li><li class="chapter-item expanded "><a href="28_concepts.html"><strong aria-hidden="true">29.</strong> Концепты</a></li><li class="chapter-item expanded "><a href="29_ranges.html"><strong aria-hidden="true">30.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="30_encoding.html"><strong aria-hidden="true">31.</strong> Кодировки</a></li><li class="chapter-item expanded "><a href="31_coroutines.html"><strong aria-hidden="true">32.</strong> Корутины</a></li><li class="chapter-item expanded "><a href="32_modules.html"><strong aria-hidden="true">33.</strong> Модули</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">C++ course notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/cpp-kt/cpp-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Исключения-гарантии-безопасности-исключений-raii" id="Исключения-гарантии-безопасности-исключений-raii">Исключения, гарантии безопасности исключений, RAII</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=R0tVZ1px5-Q">Запись лекции №1</a></li>
<li><a href="https://www.youtube.com/watch?v=8PpW8qS2tEg">Запись лекции №2</a></li>
</ul>
<hr />
<p>Как можно возвращать ошибку? Можно это делать с помощью error-кодов (так делали в C):</p>
<pre><code class="language-c++">// int — код ошибки.
int do_something() {
	FILE* file = fopen(&quot;1.txt&quot;);
	if (!file)
		return FILE_NOT_FOUND_CODE; // Какая-то константа.
	int err = file_interact(file);  // Некоторая функция, которая может завершиться с ошибкой.
	if (err)
		return err;
	// Ещё 100 функций, после каждой из которых проверяем наличие ошибки и возвращаем её, если есть.
	return 0;
}
</code></pre>
<p>Но это не очень удобно и не очень читаемо. А если у нас есть что-то более сложное, чем последовательное выполнение, то было бы ещё более некрасиво и совсем непонятно. Чтобы такого не было, используют механизм исключений. Вообще больше мотивации по исключениям можно посмотреть в лекциях по введению в программирование.</p>
<p>Исключения в C++ пишутся так:</p>
<pre><code class="language-c++">try {
	// Делаем что-то, что может завершиться с ошибкой.
	// ...
	// ...
	// Завершиться с ошибкой --- это вот так:
	throw something;
	// ...
	// ...
} catch (error_type const&amp; e) { // Что делать, если ошибка.
	// Обрабатываем ошибку.
} catch (another_error_type const&amp; e) {
	// Обрабатываем другую ошибку.
}
</code></pre>
<p>Что происходит при бросании исключения:</p>
<ul>
<li>Создаётся копия объекта, переданного в <code>throw</code>. Копия будет существовать, пока исключение не будет обработано.</li>
<li>У всех проинициализированных локальных переменных вызываются деструкторы (если эти деструкторы тоже кидают исключение — происходит <a href="#noexcept-stdterminate"><code>std::terminate</code></a>).</li>
<li>Прерывается исполнение программы.</li>
<li>Выполняется раскрутка стека, пока исключение не будет обработано (поймано), вызываются деструкторы в правильном порядке. Каким конкретно образом — смотри <a href="#%D1%86%D0%B5%D0%BD%D0%B0-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9">далее</a>.</li>
</ul>
<p><em>Обработано</em> — это когда исключение происходит в блоке <code>try</code>, и тогда, в зависимости от типа исключения, происходит переход в соответствующий блок <code>catch</code>. Если такового нет, то <code>try</code>-<code>catch</code> блок игнорируется, и исключение летит дальше вверх по стеку. Ещё есть особый блок <code>catch</code>, который выглядит как <a href="#catch--%D0%B8-throw"><code>catch (...)</code></a>.</p>
<h2><a class="header" href="#Исключения-и-наследование" id="Исключения-и-наследование">Исключения и наследование.</a></h2>
<p>Тут, кстати, как в Java есть наследование исключений, и если вы кидаете исключение наследуемого типа, вы можете поймать его как базового. Причём это работает даже если в них нет в RTTI.</p>
<pre><code class="language-c++">struct base {
	virtual std::string msg() const {
		return &quot;base&quot;;
	}
}
struct derived : base {
	std::string msg() const override {
		return &quot;derived&quot;;
	}
}
int main() {
	try {
		throw derived();
	} catch (base const&amp; e) {
		std::cout &lt;&lt; e.msg() &lt;&lt; std::endl;
	}
}
</code></pre>
<p>Вообще <strong>кидать вы можете всё что угодно — любой копируемый тип</strong>. Но <strong>обычно кидают <code>std::exception</code> или его наследников</strong>.</p>
<h3><a class="header" href="#Исключения-и-виртуальное-наследование" id="Исключения-и-виртуальное-наследование">Исключения и виртуальное наследование.</a></h3>
<p><strong><code>catch</code> работает тогда, когда можно однозначно определить подобъект</strong>. В частности такой код:</p>
<pre><code class="language-c++">struct A {};
struct B : A {};
struct C : A {};
struct D : B, C {};

int main() {
	try {
		throw D();
	} catch (A const&amp;) {
		std::cout &lt;&lt; &quot;Caught A.\n&quot;.
	}
}
</code></pre>
<p>не поймает исключение, пока <code>B</code> и <code>C</code> отнаследованы не виртуально.</p>
<h2><a class="header" href="#catch--и-throw" id="catch--и-throw"><code>catch (...)</code> и <code>throw;</code>.</a></h2>
<p>Ещё есть специальный тип <code>catch</code>'а — <code>catch (...)</code>, который ловит вообще всё что угодно. Но, как в известном анекдоте, есть один нюанс: <code>catch (...)</code> ловит не обязательно исключения C++. В Windows, например, исключения C++ — это частный случай исключений, встроенных в Windows. И эти встроенные исключения также ловятся при помощи <code>catch (...)</code>, что вы хотите явно не всегда. Системные исключения вообще не надо ловить, если взять POSIX'ивое исключение <code>abi::__forced_unwind</code> и проглотить его, то <a href="https://udrepper.livejournal.com/21541.html">может быть всё очень плохо</a>. Ещё более интересный момент есть в GCC. Там исключения поддерживаются не только плюсовые, а и другие разные, которые работают не так. Куча языков реализуют исключения так, что <code>catch</code> может либо прервать, либо продолжить работу. В C++ такого нет, но ABI такое поддерживает. И такое уж точно вы не хотите ловить.</p>
<p>Но <strong>вообще <code>catch (...)</code> имеет идиоматическое использование</strong>:</p>
<pre><code class="language-c++">catch (...) {
	// Что-то почистим.
	throw;
}
</code></pre>
<p><strong><code>throw;</code> просто берёт то, что поймал и кидает его же. Без копирования.</strong> Поэтому подобный синтаксис даже в обычных <code>catch</code> бывает полезен, он лучше, чем</p>
<pre><code class="language-c++">catch (const type&amp; e) {
	throw e;
}
</code></pre>
<p>потому что во втором варианте есть лишнее копирование или даже <a href="./07_inheritance.html#slicing">slicing</a>.</p>
<h2><a class="header" href="#best-practices-и-worst-practices" id="best-practices-и-worst-practices">Best practices и worst practices.</a></h2>
<p>Совет — всегда ловите исключение по константной ссылке. Если Вы, конечно, не хотите исключение менять, тогда просто по ссылке.</p>
<p>Ещё не кидайте указатель на исключение (то есть не пишите <code>throw new error_type(...);</code>). Если вы так сделаете, ловить вам надо будет <code>catch (error_type*)</code>, и тогда надо не забыть сделать <code>delete</code>. И понятно, что нельзя делать <code>catch (...)</code>, потому что тут вы никак не сделаете <code>delete</code>.</p>
<p>Также не надо ловить копию. Потому что когда вы вместо <code>catch (const error_type&amp; e)</code> вы пишете <code>catch (error_type e)</code>, тоже происходит копирование/<a href="./07_inheritance.html#slicing">slicing</a>.</p>
<h2><a class="header" href="#Цена-исключений" id="Цена-исключений">Цена исключений.</a></h2>
<p>Если открыть что-то в интернете, вам скажут, что исключения — это бесконечно дорого. Чтобы говорить об этом серьёзно, то сначала надо понять, какую операцию мы измеряем по времени.</p>
<p>Например, как работает <code>try</code>? Есть две стратегии реализации.</p>
<ol>
<li>Поддерживать связный список на стеке, по которому в случае чего мы и идём.<br />
Проблема тут в том, что каждый вход в <code>try</code> (даже если исключения не происходит) жрёт время и память. А исключения у вас должны происходить редко. Поэтому сейчас эту реализацию не
используют.</li>
<li><em>Zero-cost</em> исключения. Компилятор для каждой инструкции записывает, куда идти в случае исключения.<br />
Тогда вход в блок <code>try</code> не генерирует абсолютно никакой код. И тут у нас при <code>throw</code> никакого оверхеда от исключений почти нет. Почему «почти»? Потому что в общем случае код может быть не совсем одним и тем же. Если мы делаем какие-то операции с памятью, например, мы должны видеть все эффекты до <code>throw</code> и не видеть ни одного после. Поэтому компилятор может
меньше переупорядочивать код в таком случае.</li>
</ol>
<p>В любом случае, если написать бенчмарк для тестировки исключений, результат будет в том, что замедление небольшое.</p>
<p>Ещё есть заморочки с конкретными реализациями (в Itanium ABI, как уже обсуждалось, есть мем с продолжением выполнения после <code>throw</code>). Поэтому Itanium ABI раскручивает стек два раза — чтоб проверить, надо ли прерываться и чтобы потом вызвать деструкторы.</p>
<h2><a class="header" href="#noexcept-stdterminate" id="noexcept-stdterminate"><code>noexcept</code>. <code>std::terminate</code>.</a></h2>
<p>Что будет, если кинуть исключение из деструктора при обработке исключения? То есть мы получили исключение, вызываем деструкторы, и получаем исключение там.</p>
<p>По стандарту, это ошибка в программе: <strong>считается, что в ситуации, когда вы получили 2 исключения, происходит что-то невообразимо ужасное, и в программе вызывается <code>std::terminate</code> — экстренное завершение программы</strong>. Более простой способ получить <code>std::terminate</code> — выкинуть исключение в <code>main</code>.</p>
<p>Кстати, поскольку деструкторы не должны бросать исключение, такие функции как <code>free</code> явно в языке помечены как неспособные бросать исключения. Чтобы пометить так функцию, есть модификатор <code>noexcept</code> <strong>Бросание исключений из <code>noexcept</code> таких функций также приводит к <code>std::terminate</code></strong>. Ещё помимо <code>noexcept</code> можно указать <code>noexcept(/* булевое выражение */</code>). Это нужно, если вы <a href="./14_templates.html">шаблонный код</a> пишете, и у вас функция может в зависимости от шаблона либо быть <code>noexcept</code>, либо нет.</p>
<p>И вот что важно знать — <strong>деструкторы по умолчанию <code>noexcept</code></strong>. Если вам нужно это исправить — <code>noexcept(false)</code>. Тогда при обычном бросании исключения в деструкторе всё будет хорошо, а при двойном исключении — всё ещё <code>std::terminate</code>.</p>
<h2><a class="header" href="#Ошибки-и-аллокация-памяти" id="Ошибки-и-аллокация-памяти">Ошибки и аллокация памяти.</a></h2>
<p><code>operator new</code> и <code>operator delete</code> - работают как <code>malloc</code> и <code>free</code> (выделяют сырую память), но бросают исключения (<code>std::bad_alloc</code>), а не возвращают <code>nullptr</code>.</p>
<p>Несмотря на то, что <code>operator new</code> отличается от <code>malloc</code> только тем, что исключение кидает, вам всё равно <strong>не позволяют выделять память при помощи <code>operator new</code>, а освобождать при помощи <code>free</code></strong> (или наоборот).</p>
<!--
Посмотрим на такой пример:

```c++
my_string& my_string::operator=(char const* rhs) {
     char* old_data = data_;
     size_ = strlen(rhs);
     capacity_ = size_;
     data_ = (char*)operator new(size_ + 1);
     memcpy(data_, rhs, size_ + 1);
     operator delete(old_data);
     return *this;
}
```

Если `operator new` выкинет исключение, то получим проблему, что мы уже изменили `size_` и `capacity_`, но ничего не скопировали.

Это какие-то гарантии исключений. Причём тут это вообще?
-->
<h2><a class="header" href="#raii" id="raii">RAII.</a></h2>
<p>Давайте зададим себе такой вопрос: вот есть у нас C-шный код, где мы открываем несколько файлов. Как он выглядит? Ну, вот так:</p>
<pre><code class="language-c++">	res = 0;
	FILE* f1 = fopen(&quot;1.txt&quot;, &quot;r&quot;);
	if (f1 == NULL)
		return -1;
	FILE* f2 = fopen(&quot;2.txt&quot;, &quot;r&quot;);
	if (f2 == NULL) {
		res = -1;
		goto close_f1;
	}
	FILE* f3 = fopen(&quot;3.txt&quot;, &quot;r&quot;);
	if (f3 == NULL) {
		res = -1;
		goto close_f2_and_f1;
	}

	// ...
	if (error_while_reading) {
		res = -1;
		goto close_all;
	}
	// ...

close_all:
	fclose(f3);
close_f2_and_f1:
	fclose(f2);
close_f1:
	fclose(f1);
	return res;
</code></pre>
<p>Как мы уже обсудили, в C++ с помощью исключений это можно написать существенно проще, просто кидая исключения при ошибках, а файлы сами закроются. Но возникает вопрос, как сделать то же самое с, например, памятью:</p>
<pre><code class="language-c++">	int* p = new int(1);
	int* q = new int(2);
	// ...
	delete p;
	delete q;
</code></pre>
<p>Тут есть фундаментальная проблема, что в случае, если <code>new int(2)</code> кинет исключение, мы не освободим <code>p</code>. Хм-м-м, ну, у нас же была та же проблема с файлами в C, а <code>std::istream</code> её решил. Каким образом? Наличием деструктора, где освобождается ресурс. Значит надо сделать класс, который будет работать как указатель, но иметь деструктор, освобождающий память.</p>
<p>Когда класс <strong>при создании выделяет какой-то ресурс, а при удалении — освобождает, говорят, что он удовлетворяет идиоме <em>RAII</em></strong> (<em>resource acquisition is initialization</em>).  И в стандартной библиотеке всё по этой идиоме и работает.</p>
<p>Хотя вообще данная идиома не очень хорошо названа, потому что выделять-то мы не обязаны в конструкторе, мы можем вызвать <code>std::istream::open</code>, чтобы не при конструкторе файл открыть, а потом. Но в деструкторе мы всё равно закроем файл, если открывали.</p>
<h3><a class="header" href="#stdunique_ptr" id="stdunique_ptr"><code>std::unique_ptr</code>.</a></h3>
<p>Выше мы анонсировали класс, который похож на указатель, но работает по RAII. И в стандартной библиотеке есть несколько таких, в зависимости от того, что нужно делать при копировании.</p>
<p>Его мы почти полностью можем и сами написать, так что давайте это сделаем:</p>
<pre><code class="language-c++">template &lt;class T&gt; // Сюда смотреть пока рано.
class unique_ptr {
private:
	T* ptr;

public:
	unique_ptr() : ptr(nullptr) {}
	unique_ptr(T* ptr) : ptr(ptr) {}
	unique_ptr(const unique_ptr&amp;) = delete;
	unique_ptr&amp; operator=(const unique_ptr&amp;) &amp; = delete;

	~unique_ptr() {
		delete ptr;
	}

	T&amp; operator*() {
		return *ptr;
	}
	T* operator-&gt;() {
		return ptr;
	}
	T&amp; get() {
		return *ptr;
	}

	void reset(T* new_ptr = nullptr) {
		delete ptr;
		ptr = new_ptr;
	}
	T* release() {
		T* result = ptr;
		ptr = nullptr;
		return result
	}
};
</code></pre>
<p>Ещё должна быть внешняя функция <code>make_unique</code>, которая выделяет новый <code>unique_ptr</code>, но её мы как раз реализовать не можем, нам variadic-шаблонов не хватает.</p>
<p>Вообще функции типа <code>release</code> использовать опасно, потому что они превращают RAII'шную обёртку над указателем в сырой указатель, и в таком случае вы должны сами следить, чтобы в момент исключения он не оказался сырым.</p>
<h3><a class="header" href="#raii-вокруг-объекта-кидающего-исключение-при-закрытии" id="raii-вокруг-объекта-кидающего-исключение-при-закрытии">RAII вокруг объекта, кидающего исключение при закрытии.</a></h3>
<p>Давайте теперь рассмотрим POSIX, в котором мы файлы открываем.</p>
<pre><code class="language-c++">struct file_descriptor {
public:
	file_descriptor(const char* filename)
		: fd(open(filename, O_RDONLY)) {}

	~file_descriptor() {
		close(fd);
	}

private:
	int fd;
};
</code></pre>
<p>В чём тут проблема? В том, что на <em>man</em> написано, что <code>close</code> имеет возвращаемое значение, в нём может произойти ошибка. Это связано с тем, что <code>close</code> выполняет две операции — дозаписывает данные до конца, чтобы закрыть файл и возвращает файловый дескриптор операционной системе. Поэтому в идеальном мире мы бы разбили его на две — какой-нибудь <code>flush</code>, который дозаписывает данные и именно что <code>close</code>. И примерно такого поведения мы и хотим, а кидать исключение в случае провала <code>close</code> не хотим, потому что двойное исключение.</p>
<p>Поэтому давайте напишем всё вот так:</p>
<pre><code class="language-c++">struct file_descriptor {
public:
	file_descriptor(const char* filename)
		: fd(open(filename, O_RDONLY)) {}

	void flush() {
		int result = close(fd);
		if (result != 0)
			throw std::runtime_exception(&quot;File closing failed.&quot;);
		fd = -1;
	}

	~file_descriptor() {
		if (fd != -1)
			close(fd);
	}

private:
	int fd;
};
</code></pre>
<p>Теперь из деструктора мы ничего не бросаем. Но теперь мы <strong>обязаны явно извне вызывать <code>flush</code>, если заинтересованы в получении ошибок при закрытии</strong>.</p>
<h2><a class="header" href="#Гарантии-исключений" id="Гарантии-исключений">Гарантии исключений.</a></h2>
<p>Уважаемые знатоки, внимание, вопрос. Через одну минуту найдите ошибку в в следующем операторе присваивания для строк:</p>
<pre><code class="language-c++">struct string {
	// ...
	string&amp; operator=(const string&amp;) &amp; {
		if (this == &amp;other)
			return;

		operator delete(data);

		size = other.size;
		capacity = other.capacity;
		data = (char*)operator new(size + 1);

		memcpy(data, other.data, size + 1);

		return *this;
	}
};
</code></pre>
<p>Итак, правильный ответ:<br />
Если в <code>operator new</code> произойдёт исключение, строка останется в некорректном состоянии. Причём настолько некорректном, что на ней даже деструктор вызвать нельзя: будет double-free.</p>
<p>Поэтому когда вы пишете код с исключениями, нельзя писать его наивно. Необходимо думать, что произойдёт с вашими объектами, если из публичного метода вылетит исключение. Разделяют 4 ситуации:</p>
<ol>
<li><em>Nothrow</em> — гарантируется, что исключение из данного метода выброшено быть не может.</li>
<li><em>Strong</em> — в случае исключения состояние объекта будет сброшено на то, которое было до вызова метода, откуда было брошено исключение.</li>
<li><em>Basic</em> — в случае исключения объект останется в корректном состоянии (т.е. все инварианты останутся верными и не произойдёт утечка ресурсов), но ничего более конкретного состояние, не гарантируется.</li>
<li><em>No guarantee</em> — не <em>exception-safe</em>, ошибка в проектировании программы.</li>
</ol>
<p>Давайте немного пофантазируем на тему <code>std::vector</code>. Какие его методы каким гарантиям удовлетворяют? Понятно, какие-нибудь <code>size</code>, <code>capacity</code>, <code>empty</code> или <code>begin</code> и <code>end</code> не бросают исключений, с чего бы им. А вот что можно сказать про <code>pop_back</code>? Ну, вроде как кидать там нечего, но ведь деструктор элемента может теоретически и бросать... А вот нет — <strong>все стандартные контейнеры накладывают некоторые условия на принимаемые ими типы. И абсолютно каждый требует nothrow-деструктора</strong>. Хорошо, то есть <code>pop_back</code> — это nothrow. А что будет, если мы удалим элемент из пустого вектора? А undefined behaviour. То есть мы можем спокойно вернуть <code>*nullptr</code> и ничего не бросать в таком случае. Поэтому если нам хочется, мы вполне можем написать <code>vector</code>, который имеет <code>noexcept</code>-<code>pop_back</code>.</p>
<p>Про <code>push_back</code>, например, ясно, что она может спокойно давать строгие гарантии. А какие функции дают базовые? <code>insert</code> и <code>erase</code>. Вообще их можно сделать так, чтобы гарантии были строгими, но они базовые, чтобы можно было их выполнять через <code>swap</code>'ы. Обычно <code>swap</code>'ы не бросают исключение, но вообще могут делать это. Поэтому тут мы по сути получаем, что гарантия методов контейнера зависит от того, какой тип ему дали: есть <code>swap</code> не бросает, то гарантии у нас строгие, а иначе — базовые.</p>
<h3><a class="header" href="#swap-trick" id="swap-trick">Swap-trick.</a></h3>
<p><strong>Хорошая идея — писать оператор присваивания через <code>swap</code></strong>. Это даёт нам строгие гарантии, и не заставляет думать:</p>
<pre><code class="language-c++">my_string&amp; my_string::operator=(my_string copy) {
//        Внимание!            ^^ копия ^^
     std::swap(*this, copy);
     return *this;
}
</code></pre>
<p>Здесь при передаче вызовется конструктор копирования строки, а потом мы сделаем swap.</p>
<p>Но это не единственное, чему можно легко дать строгие гарантии, если у нас не бросающий <code>swap</code>. Пусть у нас есть <code>std::vector</code>, у которого есть <code>erase</code>, дающий базовую гарантию. Но следите за руками:</p>
<pre><code class="language-c++">void erase_strong(vector&amp; v, iterator where) {
	vector copy = v;
	copy.erase(where);
	copy.swap(v);
}
</code></pre>
<p>И лёгким движением руки базовая гарантия превращается в строгую.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="07_inheritance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="09_allocations_optimizations.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="07_inheritance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="09_allocations_optimizations.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
