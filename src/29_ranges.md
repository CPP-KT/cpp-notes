# Ranges

- [Запись лекции](https://youtu.be/l9RHsi9tFtE)

## Мотивация
До появления ```ranges``` для сортировки вектора нужно было делать примерно такое:
```c++
// C++17 and earlier
std::sort(v.begin(), v.end());
// C++20
std::ranges::sort(v)
```
То есть функция сортировки принимала два итератора и сортировала то, что между ними. 
При этом перегрузки, куда можно просто передать вектор не существовало.

Почему так было сделано? Идея такая: форма, которая принимает два итератора она более общая и, 
если нужно сортировать некоторый подотрезок, она нам подходит. 
А функция, которая принимает вектор целиком более частный случай. 

При этом короткой формы, которая принимала просто какой-то контейнер, не было, потому что добавление новых перегрузок к стандартным алгоритмам,
приводило к тому, что нужно было добавлять много дополнительных SFINAE проверок, если этого не делать, они начинают конфликтовать между собой.

Опыт использования стандартных алгоритмов показал, что от них ещё хочется какие-то вещи, и многие из них откладывались из-за того,
что нужно было сломать совместимость, или нужны были мощные SFINAE ограничения и тому подобное. Это всё откладывалось и, 
когда в языке появились концепты -- алгоритмы стандартной библиотеки переделали.

В стандарте используется подмножество библиотеки range-v3.
Eric Niebler (автор пропозала) предлагает три способа обращения с ренжами:

### D-like ranges
Ренжи в D хранят набор ещё не обработанных элементов, т.е. они постоянно
сужаются. С такими ренжами сложно работать когда алгоритму нужно похранить
позицию, например `find`. В D эта проблема решается [кучей
функций](https://dlang.org/phobos/std_algorithm_searching.html#.findSplit).
Ещё такие ренжи плохи в алгоритмах типа `partial_sort` (там нужны три
итератора).

### Position-based ranges
position это что-то типа итератора, который ссылается не на сам элемент, а на
позицию в каком-то контейнере, который нужно явно передать. С такими ренжами
легко сделать проверку на границу диапазона. Ещё такие ренжи решают проблему
времени жизни - алгоритму нельзя передать протухший итератор. Минус такого
подхода в том что нам придется ввести кучу дополнительной машинерии для
interop-а обычных итераторов и positions.

### Iterator-based ranges
Ренж просто держит два итератора под капотом. Так были построены почти все
библиотеки для ренжей. Так сделали и в стандарте.


## Range и Views
Помимо алгоритмов с ренджами в стандарт вошли *views*. Например, мы можем
получить "reverse view" вектора, т.е. обертку, которая ссылается на вектор и при
доступе к `i`-му элементу выдаёт `n-i-1`-й и т.п. Ещё можно создавать ленивые
последовательности и делать над ними преобразования:
```c++
total = accumulate(iota(1)
                  | transform([](int x) { return x * x; })
                  | take(10), 0)
```

Рассмотрим пример:
```c++
    void foo(std::vector<int32_t> const& v) {
        auto r = v | std::views::reverse;
    }
```

Возникают вопросы: является ли `r` копируемым? Если да, то за какое время? Может ли `r` жить дольше, чем `v`?
Можно ли делать `*r.begin() = 42`? Изменится ли при этом исходный `v`? Изменятся ли ответы,
если вместо `v` передать rvalue? Для ответа на эти вопросы, дадим соответствующие определения.

В первом приближении можно думать, что вьюхи -- это легковесные объекты, которые на что-то ссылаются и имеют специальные свойства, т.е. они не копируют внутрь себя ничего (обычно). 

Что такое [`std::ranges::range`](https://en.cppreference.com/w/cpp/ranges/range)? Всё что угодно, если у него определены операции `begin(r)`, `end(r)`.

[`std::ranges::view`](https://en.cppreference.com/w/cpp/ranges/view) -- Это `range`, она *movable* за `O(1)` и имеет ещё некоторое количество семантических ограничений. Для того чтобы сказать, что класс является `view`, существовал
opt-in, который назывался `enable view`.

Примеры `view`: `ref_view, owning_view, filter_view, ...`.

Примеры `range`, которые не являются `view`: `vector, array`.

Рассмотрим pipe-line:
```c++
void foo(std::vector<int32_t>& v) {
    return v 
        | std::views::filter(is_divisible_by_3) 
        | std::views::transform(square)
        | std::ranges::to<std::vector<int32_t>>();
}
```

Он работает следующим образом: `filter`, `transform` они принимают вьюху и возвращают вьюху. А если мы в начале передали не вьюху,
то его превращают во `view` специальным образом: `sts::views::all(v)`. 

Превращает он по следующим правилам (упрощённо): 

1. Если `r` уже `view`, то его же и возвращает. 
2. Если `r` -- *lvalue*, то возвращается `ref_view<R>` (вьюха, которая просто ссылается на контейнер).
3. (*) Если `r` -- *rvalue*, то возвращается `owning_view<R>` (вьюха, которая хранит сам объект). Со звёздочкой, потому что появилось не сразу вместе с std::ranges, а позже.


## Sentinel
В C++03 существовали такие "ренжи" (пара итераторв), размера, которого мы не знаем на перёд (потенциально, он может быть бесконечным).
Например, для `std::istream, std::regex_iterator`. В их реализации от того, что `begin` и `end` имеют один и тот же тип ничего не зависит.
Но это требуют практически все стандартные алгоритмы, однако когда мы реализуем, например, `std::isstream_iterator`, это дополнительная сложность.
Хотелось бы ослабить это ограничение, многим алгоритмам не нужно, чтобы `begin` и `end` были одинакового типа. 
В C++ ranges эту штуку немного поменяли, в качестве `begin` передаётся всё также итератор, а вот объект, который показывает, где конец,
стали называть `sentinel`. Проверка на конец спрятана в операторе сравнения у `sentinel`. И это позволяет нам иметь, например, бесконечные ренжи:

```c++
    auto naturals = std::views::iota(1);
    auto begin_ = naturals.begin();
    auto end_ = naturals.end(); // std::unreachable_sentinel_t
```


## Изменения в категориях итераторах

В С++ 98 были следующие категории итераторов: 

1. ```InputIterator```
2. ```OutputIterator```
3. ```ForwardIterator```
4. ```BidirectionalIterator```
5. ```RandomAccessIterator```

Для ```Forward```,```Bidirectional``` и``` RandomAccess``` итераторов есть требования, чтобы они могли возвращать ссылку на элемент и это все хорошо работает пока мы не получим следующий пример с view:

```c++
transform(v, [](int x){return x * x;})
```

Тут мы возвращаем новое значение, мы уже не можем возвращать ссылку. В Boost такое предложили разделять 2 свойства итераторов: ```Traversal``` -- то как мы проходим по диапазону, ```Access``` -- то как мы обращаемся к элементу.

В С++20 не стали выделять 2 этих свойства, для ```Forward```,```Bidirectional``` и``` RandomAccess``` решили ослабить требования к итераторам, для них убрали требования уметь возвращать ссылку, оставили только Traversal требования. При этом добавили ещё одну категорию: ```ContigousIterator``` -- он означает что элементы лежат в памяти непрерывным блоком, позволяет делать всякие операции.

Итого куча разных итераторов могут предоставить более сильные категории.

См. [C++20 iterator concepts](https://en.cppreference.com/w/cpp/iterator)

## Алгоритмы на ренжах
На каждый алгоритм в STL сделали дополнительные перегрузки: одна для
двух итераторов с sentinel-ами, а вторая для ренжа. Для "трёхногих" алгоритмов
сделали по четыре доп. перегрузки.
Если захочется поиспользовать, то в std::ranges лежат улучшенные перегрузки
старых алгоритмов для ренжей, алгоритмы для view лежат std::ranges::views.

