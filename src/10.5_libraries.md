# Динамические и статические библиотеки
- [Запись лекции](https://youtu.be/i8uYAe0E4PU?t=3884)
---

— *Пока что это просто кусок, который я вырезал из [10_allocations_optimizations](./10_allocations_optimizations.md), так как имеет с его темами мало общего, но потом я дополню этот файл до полноценного.*

---

Тут нужно вспомнить, что мы говорили про процесс компиляции.

Программы можно объединять в статические и динамические библиотеки. Их используют, например, когда есть общий код, который мы хотим включить в несколько программ (можно скомпилировать один раз и включать в линковку другим программ, но обычно это много объектных файлов),  поэтому кучу объектных файлов объединяют в библиотеку, чтобы одним именем сослаться на них. 

```c++
// sum.cpp
int sum(int a, int b){
  return a + b;
}
// four.cpp
int sum(int a, int b);
int main(){
  std::cout << sum(2, 2);
}
// five.cpp
int sum(int a, int b);
int main(){
  std::cout << sum(2, 3);
}
```
Компилируем:
```shell
g++ -c sum.cpp -o sum.o
g++ -c four.cpp -o four.o
g++ -c five.cpp -o five.o

g++ four.o sum.o -o four
g++ five.o sum.o -o five
```
Предположим, что `sum` это не один объектный файл, а целая библиотека из кучи файлов. Хочется сослаться на неё одним именем (и распространять тоже один файл, а не кучу объектных). Для этого существуют библиотеки:

```shell
ar rcs libsum.a sum.o        # rcs - 
g++ four.o -lsum -L. -o four # -lsum - указывает на имя библиотеки
g++ five.o -lsum -L. -o five #  -L. - каталог (здесь это текущий каталог)
```

Это всё было про статическую библиотеку. В таком случае код библиотеки попадал в каждую из программ. Чтобы этого избежать, применяют динамические библиотеки:
Динамические библиотеки должны уметь подгружаться по любому адресу. Для этого нужно компилировать `sum` было с ключом `-fpic`:
```shell
g++ -fpic -c sum.cpp -o sum.o
g++ -shared sum.o -o libsum.so
```
Если сейчас мы попробуем запустить программу `four`, то получим ошибку `file not found`. Дело в том, что по умолчанию система ищет библиотеки по системным путям. Есть несколько способов обойти: вшить в бинарник путь или прописать `LD_LIBRARY_PATH`:
```shell
LD_LIBRARY_PATH=... # здесь абсолютный путь к каталогу, где лежит наша библиотека
```
Если удалить `.so` файл и попробовать запустить программы, то получим ошибку, так как они на неё ссылались.
Можно посмотреть, на какие динамические библиотеки ссылается программа:
```shell
LD_LIBRARY_PATH=... ldd ./four`
```
Библиотеки можно подключать в `cmake` коммндой `add_library`.

Полезная статья про динамические библиотеки --- [How to write shared libraries, Ulrich Drepper](https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf)
