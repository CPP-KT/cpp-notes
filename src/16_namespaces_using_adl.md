# Пространства имён, using-декларации, using-директивы, ADL.
- [Запись лекции №1](https://www.youtube.com/watch?v=fgD5itE5pCQ)
---
## Пространства имён
В Си в библиотеках у функций обычно есть префикс названия библиотеки, например, `mpz_add` в GMP. Это нужно, чтобы не было двух разных функций с одинаковым именем.

В C++ для такого используется механизм `namespace`.

```c++
namespace somelib {
  struct foo {};
  void bar();
}
namespace somelib { // можно несколько раз открывать
  void baz(foo*);
}
```
Внутри неймспейса можно ссылаться на что угодно из него. Синтаксис обращения снаружи: `somelib::foo`, где `somelib::` - квалификатор. Такие имена называются квалифицированными. 

Неймспейсы могут быть вложенными:

```c++
namespace somelib {
  namespace nested {
    struct foo {};
  }
  void bar (nested::foo const&);
}
```
Тогда ссылаться надо так: `somelib::nested::foo`.

Как такие ищутся без квалификаторов? Поднимаемся по фигурным скобкам (неймспейсам) вплоть до глобального.

Если функции на разных уровнях неймспейсов называются по-разному, то выберется первая найденная. Чтобы обратиться к имени из глобального неймспейса, нужно использовать пустой квалификатор `::foo`. Но это всё про одну единицу трансляции, а что если их несколько?

Как мы помним, имя, которое передаётся линковщику кодируется и содержит в себе параметры, принимаемые функцией. Если функция в неймспейсе, то в её имени кодируется название неймспейса. Линковщик дальше работает уже с этими декорированными именами, поэтому объявление и определение работают так же, как и без неймспейсов.

Для неймспейсов можно создавать alias'ы: `namespace fs = std::filesystem`. Редко используется по причинам аналогичным неиспользованию тайпдефов.
Можно использовать, например, когда поменяли имя неймспейса, но не хотим ломать код, который уже ссылается на старое.

## Using-декларация 
```c++
namespace ns {
  void foo(int);
}
using ns:foo; // на классы тоже можно
```
Using-декларация берёт сущность, на которую ссылаемся и как бы объявляет её ещё раз в неймспейсе, в котором она написана.

При этом правило ODR (one defenition) сохраняется:
```c++
struct bar{};
using ns::bar; // так нельзя
```
Для перегрузок функций всё работает как надо.

```c++
namespace ns {
  void foo(int);
}
namespace ns2 {
  void foo(float);
}
int main() {
  using ns::foo;
  using ns2::foo;
  foo(42.5f); 
  return 0;
}
```
Using можно применять не только для неймспейсов, но и для классов.
```c++
struct base1 {
  void foo(int);
};
struct base2 {
  void foo(float);
};
struct derived : base1, base2 {
  using base1::foo;
  using base2::foo;
};
int main() {
  derived d;
  d.foo(42); // без using не делается overload resolution и будет ошибка, так как два кандидата из разных баз
  return 0;
}
```
Ещё можно применить так:
```c++
struct base {
  void foo(int);
};
struct derived : private base {
  using base::foo;
};
int main() {
  derived d;
  d.foo(42);
  return 0;
}
```
Аналогично можно и с конструкторами:
```c++
struct my_error : std::runtime_error {
  using runtime_error::runtime_error;
};
```
Можно подключать полностью весь неймспейс: `using namespace somelib;`. То, что было до этого, называлось *using-декларациями*, это называется *using-директива*. По сути, оно говорит при поиске в неймспейсе, где она написана, искать в неймспейсе `somelib`. Они немного отличаются:

```c++
namespace somelib {
  struct foo {};
  void  bar();
}
struct foo {};
// using somelib::foo; такой using приведет к ошибке
// using somelib::bar; 
using namespace somelib; // к ошибке компиляции не приводит
int main() {
  bar(); // так работает
  foo(); // а так ошибка компиляции из-за неоднозначности
}
```
Если бы namespace, который мы подключили через директиву, подключал в себе ещё какой-то namespace, то мы бы искали в их замыкании.

> Понятно, что то, что я привожу, это примеры не жизненные, так лучше не писать.
```c++
namespace ns2 {};
namespace ns1 {
  struct foo {};
  using namespace ns2; // юзингает весь неймспейс, то есть в него можно дописать что-то ниже, по смыслу это просто "ссылка" на неймспейс
}
namespace ns2 {
  struct foo {};
  using namespace ns1;
}
using namespace ns1;
int main() {
  foo a; // ошибка, так как поднялись в глобал, зашли в ns1, там using namespace ns2, в их замыкании находим два foo
  ns1::foo a; // это работает, объяснение ниже
}
```
Из примеров выше видно, что квалифированные имена работают немного иначе, оно ищет не в замыкании, а сначала ищет в самом неймспейсе, если же в нём нет, то переходит по using namespace. Обычно мы это не заметим, так как неймспейсы используются не так активно и так вообще вряд ли нужно будет писать.

Когда пишем using и alias в хедерах, то они работают везде, куда инклудят этот хедер, что мы редко хотим, поэтому есть такое правило - в хедерах юзинг-директивы и декларации не писать, так как почти никогда не хотим использовать их для пользователя.

Сложный пример:
```c++
namespace ns1 {
  uint32_t const a = 1;
  uint32_t const b = 1;
}
namespace ns2 {
  uint32_t const a = 2;
  uint32_t const b = 2;
  namespace nested {
    using ns1::a;
    using ns2::b;
    void foo() {
      std::cout << a << ' ' << b << '\n'; // 1 2
    }
  }
}
```
А если подключать не декларациями, а `using namespace ns1;`, то выведет "2 2". Почему так? Они ищутся не сразу, когда видят директиву, а только когда дойдём до наименьшего общего предка между тем неймспейсом, из которого ищем и тем, которого поюзингали.

## ADL
```c++
namespace somelib {
  struct big_integer {};
  big_integer operator+(big_integer const&, big_integer const&);
  void swap(big_intger&, big_integer&);
}
int main() {
  somelib::big_integer a;
  a + a;
  swap(a, a);
}
```
Казалось бы, оператор `+` не должен находиться, как и `swap`. Если бы это работало так, то пришлось бы везде писать `somelib::operator+` или делать using.

Кроме поиска имён, который мы обсудили ранее, есть Argument Depended Lookup. Здесь применяется он тоже: он смотрит на типы аргументов и ищет по неймспейсу, из которого эти типы. Такой поиск запускается только для имён, у которых неквалифицированное имя. У поиска ADL и обычного нет приоритетов, они запускаются оба и кандидаты из обоих уходят в overload resolution. Обычно они либо оба найдут одно и то же, либо обычный не найдет ничего и возьмется из ADL (логично?).

При этом ADL ищет по неймспейсу, в котором класс `big_integer` был определен. Если мы спрячем определение в неймспейс, а функции сделаем в другом месте, то он их не найдёт.

Стандартная практика применения: когда есть перегруженные операции или функции типа `swap`. 

```c++
template <typename U, typename V>
struct my_pair {
  void swap(my_pair& other) { 
    using std::swap;
    swap(u, other.u);
    swap(v, other.v);
  }
}
```
В таком случае будет запускаться ADL для пользовательских классов и будет находиться их `swap`. А для встроенных типов будет `std::swap` добавлять кандидатом.

## Анонимные неймспейсы
На лекции про компиляцию мы обсуждали модификатор `static` для функций.  
```c++
static void foo() {}
```
Такой `static` делал функции локальными для единицы трансляции. А что с классами?

Если мы хотим две разных структуры с одинаковым именем, которые не вытаскиваются из своих хедеров, то просто так может что-то сломаться, так как у них будут, например, генерироваться конструктор, деструктор с одинаковыми именами. А ещё их special member функции генерируются с модификатором inline и тут какие-то из них линковщик просто выкинет.

А ещё для них будут инстанцироваться шаблоны с одинаковыми декорированными именами, но структуры то разные. Поэтому по стандарту разных объявлений классов с одинаковыми именами быть не должно. 

Чтобы такого не происходило, существуют анонимные неймспейсы, которые работают следующим образом.
```c++
namespace {
  struct my_local_type {
    double b;
  };
  void foo() {}
  const int a = 42;
}
void foo() {
  std::vector<my_local_type> v;
  v.push_back(my_local_type());
}
```
Такой код эквивалентен:
```c++
namespace XXX {
  struct my_local_type {
    double b;
  };
  void foo() {}
  const int a = 42;
}
using namespace XXX;
void foo() {
  std::vector<my_local_type> v;
  v.push_back(my_local_type());
}
```

К чему это приводит: имя таких классов декорируется именем неймспейса, поэтому не будет конфликтов при линковке. Аналогично, как видно, можно делать для функций и для переменных. В общем, это нужно, чтобы делать сущности локальными.

Почему это имеет смысл для функций и переменных:
```c++
namespace {
  int a;
  int b;
  int c;
}
mytype<&a> va; // здесь это не как шаблон от целочисленного числа, оно сохраняет именно на какую переменную ссылается параметр
mytype<&b> vb;
mytype<&c> vc;
```
В этом примере не будет проблемы, если где-то есть ещё такие объявления, как у `va, vb, vc`, потому что в этом случае после инстанцирования шаблонов в именах функций закодирован namespace.

## static
```c++
static void foo(); // локальный для единицы трансляции, обсуждали
struct foo {
  // могут быть private
  static void bar(); // нет параметра *this, можно вызывать foo:bar()
  static int a; // как глобальная переменная, но с именем foo:a, хранится не в каждом экземпляре типа
};
int foo() {
  static int x = 42; // создаётся при первом заходе в функцию, живёт до конца программы и значения будут 43, 44, ...
  ++x;
  return x;
}
```
Можно словить рекурсивную инициализацию, это UB, какие-то компиляторы выдают исключение, какие-то зацикливаются, какие-то выдают 0:
```c++
int& f();
int g() {
  return f()
}
int& f() {
  static int x = g();
  return x;
}
int main() {
  f();
}
```
