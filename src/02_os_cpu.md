# ОС, процессор и память

## Прерывания

Почему программа с вечным циклом не повесит нам весь компьютер, даже если у нас всего одно ядро? Как ОС работает с устройствами? Всё это завязано на перерываниях.

Что происходит при прерывании: 
- Значения регистров текущего процесса дампаются в оперативную память
- Подгружаются значения регистров другого процесса и исполнение передаётся ему\
Такая схема называется *вытесняющей многозадачностью*.

Способы прерывания на устройства:
- _Polling_ - процессор сам опрашивает устройства, когда считает нужным.
- _Interrupt_ (прерывание) - устройство само говорит об изменении, процессор вызывает обработчик прерываний.

**Local timer interrupt** - прерывания по таймеру, своё у каждого ядра ЦП.
ОС заводит таймер, таймер срабатывает, провоцирует прерывание и ОС получает управление в обработчике прерываний.\
На самом деле, всё сложнее, потому что постоянно работающие таймеры это неэкономно, поэтому он, например, отключается, если на ядре ничего не исполняется.

**Rescheduling interrupts** - прерывания, используещиеся для перепланировки (миграции) процесса на другое ядро в целях распределения нагрузки. Реализованы с помощью [IPI](https://en.wikipedia.org/wiki/Inter-processor_interrupt).


## Про память
ОС реализует следующие принципы:

- _hardware abstraction_ - мышка может быть подключена по-разному подключенной, но программе всё равно
- _isolation process_ - программа не может повлиять на другие программы (записать в их память) 

Это достигается следующим образом:

__Физическая память__ - реальный модуль памяти (как на ЭВМ)

__Виртуальная память__ - пространство памяти процессов, "то, что видит программа". Обращение по адресу памяти в программе - обращение по адресу в виртуальной памяти. 
Процесс преобразования из виртуальной в физическую называется *трансляцией адресов* и реализуется в специальном блоке процессора [MMU](https://en.wikipedia.org/wiki/Memory_management_unit)

*дальше везде рассматривается 32-битная система*
### Страничная адресация
Способ организации виртуальной памяти, при котором виртуальные адреса отображаются на физические постранично (обычно 1 страница = 4 КB).

Память процесса может лежать в физической памяти в любом порядке:

![Memory Disorder](./images/02.15_memory_disorder.png)

Адресация реализуется через _PageTables_.

Вместо массива на много элементов храним массив (_каталог страниц_) размера 1024 из указателей на массивы размерами по 1024 (_таблицы страниц_). Почему это удобнее? Некоторые таблицы можно не хранить, если нужно выделить не все.

Это выглядит как-то так:

![Page Table](./images/02.15_page_table.png)
![Page Table](./images/02.15_page_tables.png)
Для ускорения трансляции применяется специальный кеш TLB (Translation lookaside buffer).

Подробнее можно прочитать тут: https://wiki.osdev.org/Paging

## Механизм адресации на уровне процессора:

**Пример адреса:**
Virtual adress - 0x123456789A

Младшие 12 бит виртуального адреса: смещение внутри страницы. Следующие 10 бит - индекс в таблице страниц, старшие 10 бит - индекс в каталоге страниц.  

```c++
typedef uint32_t page_table_element;
typedef uint32_t virtual_address;
struct page_directory
{
     uint32_t translate(virtual_address);
     private:
     	page_table_element data[1024];
};
```

Альтернативы:

* _Хеш-таблица_: плохо взаимодействует с кэшем. Использовалась в PowerPC

Это всё было про _32-битную архитектуру_. На _64-битной_ числа так красиво не сходятся. Используют следующее: добавляется ещё один уровень (можно и не один, на самом деле), массивы делают по 512. 

Пример: процессор может транслировать только 48 бит (соответствует размеру дерева из уровней). Физической памяти - 39 бит. Почему? "Сколько пинов у процессора есть, чтобы обращаться к памяти, столько и бит". 
Остальные биты в 64-битном адресе заполнены одинаковыми значениями и мы их не используем.

В регистре **CR3** хранится указатель на каталог страниц для процесса.

## Про системные вызовы, стек вызовов и frame pointer
**syscall** - интерфейс взаимодействия процесса программы с ядром ОС. Например, это чтение/запись в файла/терминала, завершение программы с кодом ошибки и т.д.

**rip** - регистр, в котором хранится адрес исполняемой инструкции в памяти

```nasm
main:
	mov		rdx, 42
	push		43
	push		44
	call		bar
bar:
	sub		rsp, 40
	; 
	add		rsp,40
	ret
```

Как понять, кто вызывал функцию? (WIP)

__Stack frame__ (кадр стека) - условная часть стека, принадлежащая вызванной функции. Содержит стековые переменные, адрес возврата и, опционально, описанный далее frame pointer

Компилятор умеет внедрять в файл специальную отладочную информацию: бесплатно по производительности, но занимает место в памяти.

Альтернатива: в скомпилированном коде при вызове функции обновляется stack frame pointer (указатель на кадр стека), таким образом кадры образуют односвязный список, а стек можно "раскрутить" (unwind).

Плюсы: без лишних телодвижений программа может узнать свой стек вызовов без отладчика. Минусы: при обильном вызове функций теряем в производительности.

**rbp** - регистр, который используется для указания на предыдущий кадр стека.

На https://godbolt.org можно посмотреть, что следующий код:

```nasm
int foo(char const*);

int bar()
{
    char arr[40];
    return foo(arr) + 1;
}
```

с флагами `-O2  -fno-omit-frame-pointer` компилируется во что-то такое:

```nasm
bar:
	push		rbp
	mov		rbp, rsp
	sub		rbp, 40
	;
	mov		rsp, rbp
	pop		rbp
	ret
```
