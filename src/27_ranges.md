# Ranges

- [Запись лекции](https://youtu.be/l9RHsi9tFtE)

## Мотивационный пример
Хотим посортировать вектор:
```c++
vector <int> v;
sort(v.begin(), v.end());
// в STL имеем такой синтаксис чтобы можно было посортить какой-то промежуток
```
Очень часто мы не пользуемся этой гибкостью, сортируем вектор целиком. Поэтому хотелось бы иметь какой-то шорткат для сортировки целого вектора : ```sort(v)``` .

Почему не добавить просто перегрузку для ```sort``` ?  Просто так их добавить можно, но это не самый оптимальный способ.

В примерах к концептам мы видели, что при добавлении большого количества перегрузок они начинают конфликтовать и надо следить чтобы в каждом случае выбиралась ровно одна перегрузка(см пример с ```assign```)

Городить эту машинерию со SFINAE никому не хотелось, поэтому ренджи очень тесно связаны с концептами и при их реализации предполагалось что в языке есть концепты. Так ```ranges``` появились в C++20.

Ренжи это как раз такой удобный набор утилит. Помимо того что писать приходится меньше, мы также можем комбинировать алгоритмы друг с другом получая таким образом легко читаемый код (пример про алгоритм парсинга *m3u* файла) и эффективный код. 

P.S: На лекции был пример реализации подсчета и сортировки слов по частоте вхождения в виде 6строчника на баше и 10страничной реализации Кнута на Паскале.

## Views
Помимо алгоритмов с ренджами в стандарт вошли *views*. Например мы можем
получить "reverse view" вектора, т.е. обертку которая ссылается на вектор и при
доступе к `i`-му элементу выдаёт `n-i-1`-й и т.п. Ещё можно создавать ленивые
последовательности и делать над ними преобразования:
```c++
total = accumulate(iota(1)
                  | transform([](int x) { return x * x; })
                  | take(10), 0)
```
В стандарте используется подмножество библиотеки range-v3.
Eric Niebler (автор пропозала) предлагает три способа обращения с ренжами:

### D-like ranges
Ренжи в D хранят набор ещё не обработанных элементов, т.е. они постоянно
сужаются. С такими ренжами сложно работать когда алгоритму нужно похранить
позицию, например `find`. В D эта проблема решается [кучей
функций](https://dlang.org/phobos/std_algorithm_searching.html#.findSplit).
Ещё такие ренжи плохи в алгоритмах типа `partial_sort` (там нужны три
итератора).

### Position-based ranges
position это что-то типа итератора но который ссылается не на сам элемент, а на
позицию в каком-то контейнере, который нужно явно передать. С такими ренжами
легко сделать проверку на границу диапазона. Ещё такие ренжи решают проблему
времени жизни - алгоритму нельзя передать протухший итератор. Минус такого
подхода в том что нам придется ввести кучу дополнительной машинерии для
interop-а обычных итераторов и positions.

### Iterator-based ranges
Ренж просто держит два итератора под капотом. Так были построены почти все
библиотеки для ренжей. Так сделали и в стандарте.

## std::ranges
Пусть мы делаем какой-то view:
```c++
auto rng = views::reverse(v);
```
Должны ли мы полностью перекопировать себе вектор или только похранить
указатели? Копировать будет безопаснее, но вот сделать что-то типа
`transform(reverese(v))` будет очень дорого. В C++20 решили копировать один раз,
а дальше брать только указатели.

В стандартных ренжах определены два концепта:
[`range`](https://en.cppreference.com/w/cpp/ranges/range) и
[`view`](https://en.cppreference.com/w/cpp/ranges/view). У ренжа можно только
взять `begin` и `end` а view помимо этого ещё можно мувать за O(1). Чтобы тип
считался view, его нужно "пометить", специализировав переменную `enable_view`.
Ещё, стандарт запрещает инициализировать view через rvalue ренджи.

## Sentinel
У ренжов с begin и end одинакового типа есть проблема - итераторы в которых на
месте end() заглушка (например у `std::istream`, `std::regex_iterator`), из-за
этого приходится делать всякие проверки типа `is_end()` и т.п. Поэтому стандарт
разрешает делать begin и end разных типов, которые можно сравнивать между собой
(тогда проверка на заглушку спрятана в операторе сравнения). Такие заглушки
называют sentinel-ами. А вообще range-based for мог работать с sentinel end-ом
уже в С++17. Кстати, для вещей типа `iota` есть
[`unreachable_sentinel`](https://en.cppreference.com/w/cpp/iterator/unreachable_sentinel_t).

## Изменения в категориях итераторах

В С++ 98 были следующие категории итераторов: 

1. ```InputIterator```
2. ```OutputIterator```
3. ```ForwardIterator```
4. ```BidirectionalIterator```
5. ```RandomAccessIterator```

Для ```Forward```,```Bidirectional``` и``` RandomAccess``` итераторов есть требования, чтобы они могли возращать ссылку на элемент и это все хорошо работает пока мы не получим следующий пример с view:

```c++
transform(v, [](int x){return x * x;})
```

Тут мы возвращаем новое значение, мы уже не можем возвращать ссылку. В Boost такое предложили разделять 2 свойства итераторов : ```Traversal``` -- то как мы проходим по диапазону, ```Access``` -- то как мы обращаемся к элементу.

В С++20 не стали выделять 2 этих свойства, для ```Forward```,```Bidirectional``` и``` RandomAccess``` решили ослабить требования к итераторам, для них убрали требования уметь возвращать ссылку, оставили только Traversal требования. При этом добавили ещё одну категорию : ```ContigousIterator``` -- он означает что элементы лежат в памяти непрерывным блоком, позволяет делать всякие операции.

Итого куча разных итераторов могут предоставить более сильные категории.

См. [C++20 iterator concepts](https://en.cppreference.com/w/cpp/iterator)

## Алгоритмы на ренжах
На каждый алгоритм в STL сделали дополнительные перегрузки: одна для
двух итераторов с sentinel-ами, а вторая для ренжа. Для "трёхногих" алгоритмов
сделали по четыре доп. перегрузки.
Если захочется поиспользовать, то в std::ranges лежат улучшенные перегрузки
старых алгоритмов для ренжей, алгоритмы для view лежат std::ranges::views.

