# Инициализация, constexpr

- [Запись лекции №1](https://youtu.be/Dp2AIvae27M?t=1377)

## Статическая и динамическая инициализация

```c++
int a = 42;
int f() {
    int result;
    std::cin >> result;
    return result;
}

int a = 42; // инициализируется в момент компиляции
int b = f(); // инициализируется
```

Переменные `a` и `b` устроены по разному: `a` инициализируется на этапе компиляции, а под `b` просто резевируются 4 байта, а её инициализация происходит в момент старта программы.  Говорят, что переменная `a` инициализируется *статически*, a `b` - динамически.

Динамическая инициализация глобальных переменных происходит в момент запуска программы до входа в функцию `main`, соответственно, разрушаются они после выхода из `main`.

Есть несколько причин, почему динамическая инициализация может быть нежелательно:

- Тратит время при запуске программы
- Гарантируется, что в одной единице трансляции переменные инициализируются сверху вниз, а между разными порядок не гарантирован. Это может стать проблемой, если переменная инициализация переменной в одной трансляции обращается к переменной в другой, а та ещё не инициализирована.
- Исключение в динамической инициализации завершает программу, так как до входа в `main`  его негде поймать.

## constexpr функции и переменные

Понятно, что использовать статическую инициализацию приятнее, чем динамическую, но в C++ все функции по дефолту исполняются в рантайме, но иногда мы хотим получить значение на этапе компиляции. Например, это может быть функция `max` для выбора максимального размера классов из шаблонных параметров. В принципе, это можно сделать так:

```c++
template <size_t a, size_t b>
struct max {
    static size_t const value = a < b ? b : a;
};

template <typename A, typename B>
struct variant {
    char stg[max<sizeof(A), sizeof(B)>::value];
};
```

Минус такого подхода, кроме неприятного синтаксиса, в том, что функцию `max` для рантайм-вычислений и структуру `max` приходится писать дважды.

В C++11 разрешили делать функции, которые могут исполняться во время компиляции. Если функция со спецификатором `constexpr` принимает аргументы, значения которых - компайл-тайм константы, то её значение будет вычислено в момент компиляции, иначе в рантайме.

```c++
template <typename T>
constexpr T const& max(T const& a, T const& b) {
    return a < b ? b : a;
}
```

В C++11 были жёсткие ограничения для таких функций - их тело должно было состоять только из одного `return`. В C++14, 17 ~~и 20~~ эти ограничения были сильно ослаблены. 

Если функция `constexpr`, то она должна внутри вызывать только `constexpr` функции.

С появлением `constexpr` функций обнаружилась нужда, например, в `constexpr` переменных. Отличие в том, что функция со спецификатором `constexpr` МОЖЕТ быть посчитана в компайл-тайме, а такая переменная ОБЯЗАНА быть компайл-тайм константой.

```c++
constexpr int f() {
    // ...
}
int const a = 42; // статическая инициализация
int const b = f(); // динамическая инициализация
constexpr int c = f(); // статическая инициализация
```

Переменная с модификатором `const` считается компайл-тайм константой, если она инициализируется статически. Кроме того,`const` для глобальных неявно означает, что они `static` (внутренняя линковка). Предположительно, так было сделано, потому что они подразумевались как замена дефайнов, которые обычно пишутся в хедерах.

Конструкторы и деструкторы так же, как и обычные функции, могут быть constexpr. Например, это позволяет инициализировать пользовательского типа статически (например, использовать его в constexpr-контексте).

Начиная с C++20, в constexpr-функциях можно аллоцировать и освобождать память с помощью `new`. К сожалению, `placement new`, так же стал constexpr-выражением только в C++20. Как в C++17 сделать `variant` с constexpr-конструктором? Можно вместо `std::aligned_storage` применить `union`:

```c++
template <typename A, typename B>
union storage_t {
    constexpr storage_t(A a)
        : a(std::move(a)) {}
    A a;
    B b;
};

template <typename A, typename B>
struct variant {
    constexpr variant (A a)
        : index(0),
          storage_t<A, B>(std::move(a)) {}
    A* get_first() {
        return stg.a;
    }
  private:
    size_t index;
    storage_t<A, B> stg;
};
```

`constexpr` может быть полезен, чтобы гарантировать, что static-переменные внутри функции инициализируются статически. Обычная static-переменная инициализируется в тот момент, когда исполнение программы первый раз доходит до её объявления (например, при вызове функции, если переменная не внутри каких-то ветвлений). В таком случае каждый следующий раз происходила бы проверка, инициализирована ли эта переменная. Если же эта переменная объявлена как `constexpr`, то никакие проверки не нужны, так как она инициализируется статически.

```c++
type_descriptor const* empty_type_descriptor {
    static constexpr type_descriptor instance = {
        //...
    };
}
```

## if constexpr

Расмотрим реализацию [function](https://github.com/sorokin/function), которую мы делали на практике.

В его имплементации использовался класс `type_descriptor` со SFINAE. Нам повезло, что критерий для объекта был только один (`fits_small_storage`), но если бы их было несколько, то это выглядело бы сильно хуже. Но даже в нашем случае это выглядит громоздко, например, мы  заводим функцию `initialize_storage`, которая используется только один раз.

Мы могли бы сделать это через `if`, но так получится не всегда:

```c++
struct mytype1 {
    static constexpr bool has_foo = true;
    void foo();
};

struct mytype2 {
    static constexpr bool has_foo = false;
    void bar();
};

template <typename T>
void f(T obj) {
    if (T::has_foo) {
        obj.foo();
    } else {
        obj.bar();
    }
}
```

Дело в том, что при компиляции `if` оставляет обе ветки, но одна из них не скомпилируется, если у объекта нет какой-то из функций.

В языке для этого появилась конструкция `if constexpr`. Тогда код будет выглядеть следующим образом:

```c++
template <typename T>
void f(T obj) {
    if constexpr (T::has_foo) {
        obj.foo();
    } else {
        obj.bar();
    }
}
```

`if constexpr` работает следующим образом: он требует, чтобы условие было `constexpr` выражением и делает бранчинг на этапе компиляции, не подставляя ту ветку, которая не подходит условию.