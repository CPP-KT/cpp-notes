# Perfect forwarding

Когда мы говорили про `shared_ptr`, у нас была функция `make_shared`, которая принимала какие-то аргументы и передавала их в конструктор. 

Посмотрим на возможные реализацию такой функции (для упрощения на примере одного параметра):

```c++
template<typename T>
void g1(T a){
    f(a);
}
template<typename T>
void g2(T const& a){
    f(a);
}
template<typename T>
void g3(T& a){
    f(a);
}
```

Все 3 случая не подходят:

- Принимать по значению неприятно, если объект дорого копировать
- Принимать по `const&` не получится, если на самом деле функция `f` принимает ссылку
- Принимать по `&` нельзя, так как она не биндится к `rvalue`

Можно было бы сделать перегрузку с `&` и `const&`, но тогда нужно 2^n перегрузок для n параметров, что не очень удобно.

**Perfect forwarding** - принять аргументы и передать их куда-то с теми свойствами, с которыми они пришли (rvalue/lvalue, cv). В C++11 есть специальный механизм для решения этой проблемы. Чтобы понять, как оно работает, нужно познакомиться с правилами вывода ссылок в C++11.

## Reference collapsing rule

В C++ нельзя сделать ссылку на ссылку, поэтому ссылки схлопываются (коллапсятся):

```c++
typedef int& mytype1;
typedef mytype1& mytype2;
static_assert(std::is_same_v<mytype2, mytype1>); // true

template <typename T>
void foo(T&);

int main() {
    foo<int&>(); // void foo(int&)
}
```

Это было в языке всегда с момента появления ссылок. Когда появились rvalue ссылки, правила схлопывания ссылок доопределили:

```plain
& & -> &
& && -> &
&& & -> &
&& && -> &&
```

## Universal reference

Чтобы сделать perfect forwarding, нужно как-то запомнить, передавалось в шаблон rvalue или lvalue. В C++11 правила вывода шаблонных параметров были определены специальным образом, который позволяет сохранить эту информацию:

```c++
template <typename T>
void g(T&& a) {
    f(a);
}

int main {
    g(42); // rvalue: T -> int, void g(int&&)
    int a;
    g(a); // lvalue: T -> int&, void g(int&)
}
```

Такие ссылки (шаблонный параметр + rvalue-ссылка) называются *универсальными*. 

## std::forward

Как передавать параметр дальше? Внутри тела функции параметр это именованная переменная, поэтому она lvalue (ситуация очень похожа на то, как вводили `std::move`).  Для этого передачи параметра так, как он пришёл, существует `std::forward`. 

Можно сделать так:

```c++
template <typename T>
void g(T&& a) {
    f(static_cast<T&&>(a));
}

int main {
    g(42); // rvalue: T -> int, void g(int&&), f(static_cast<int&&>(a))
    int a;
    g(a); // lvalue: T -> int&, void g(int&), f(static_cst<int&>(a))
}
```
Библиотечная функция написана примерно так:

```c++
template<typename T>
T&& forward(T& obj) {
    return static_cast<T&&>(obj);
}

template <typename T>
void g(T&& a) {
    f(forward<T>(a));
}
```

Такой `forward` может быть не очень хорошим по нескольким причинам:

- Если забыть написать тип явно в вызове, то он будет выводится и выведется не так, как нам надо. 

Это фиксится следующим образом:

```c++
template <typename T>
struct type_identity {
    typedef T type;
};

template <typename T>
T&& forward(typename type_identity<T>::type& obj) {
    return static_cast<T&&>(obj);
}
```

В STL вместо `type_identity` используется `remove_reference`. Так же есть перегрузка для rvalue (`T&&`), которая применяется, например, для форварда значения, возвращаемого функцией.

## Variadic template

Осталось понять, как делать функцию, принимающую произвольное число шаблонных параметров. Для этого в C++ сделали специальный синтаксис:

```c++
template <typename... T>
void g(T&& ...args) {
    f(std::forward<T>(args)...);
}
```

Можно думать, что `...` пишутся там, где обычно аргументы перечисляются через запятую.