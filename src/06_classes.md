# Классы, абстракция данных

- [Пример к лекции](https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp)
- [Запись №1](https://www.youtube.com/watch?v=4LkTiNYQYBU)
- [Запись №2](https://www.youtube.com/watch?v=kjJ-1-VsNRo)

## Структуры

С помощью структур можно создавать свои типы. У структуры есть поля и методы. У полей и методов есть модификаторы доступа `public`, `private`, `protected`. По дефолту все поля и методы структуры - `public`.

Классы отличаются от структур только тем, что в классах по умолчанию все `private`, а в структурах `public`. Далее всё будет называться классами.

К полям класса можно обращать сразу через указатель на экземпляр:

```c++
complex * c;
c->im // то же самое, что (*c).im
```

В отличие от языка `C`, в `C++` можно объявлять методы у структур.

```c++
struct complex {
	void conjugate() {	
		im = -im;
	}
private:
	double re;
     double im;
};
```
Чем отличается метод внутри класса от такой функции?

```c++
void conjugate(complex* c) {
	c->im = -c->im; 
}
```

- У метода есть неявный параметр - указатель `this` на текущий экземпляр.

- Метод имеет доступ к приватным полям, внешняя функция - нет.

#### Что должно быть `private`, а что `public`?

Инвариант класса - сохраняющиеся свойства класса. Например, инварианты структуры данных.
> То, что может испортить инвариант класса, должно быть private.

Проверять инварианты можно ассертами (assert), но не стоит злоупотреблять ими, потому что это дорогоЮ могут быть полезны при дебаге и тестировании.

Обычно пишут объявления функций в `class.h`, а определения в `class.cpp`. Если определение функции сделано внутри класса, то она неявно помечается как inline, но мы не всегда хотим этого (дольше время компиляции из-за зависимостей и т.д.).

```c++
// struct.h:
struct complex {
  void conjugate();
private:
  double re;
  double im;
}
// struct.cpp:
void complex::conjugate(){
	im = -im;
}
```
Как гарантировать какие-то свойства у объекта, который только создан? Это можно реализовать с помощью конструктора.

## Конструкторы

Классы можно создавать через конструкторы.

```c++
struct complex {
	complex(re, im) {
		this.re = re;
		this.im = im;
	}
	complex() {		// конструктор по умолчанию
		this.re = 0;
		this.im = 0;
	}
	void conjugate() {	
		im = -im;
	}
private:
	double re;
  double im;
};

void f(complex);
int main() {
	complex c; // вызывается конструктор по умолчанию
	complex d(1., 2.);
	f(complex(1., 2.));
}
```

Если в классе есть конструктор от одного аргумента, то может происходить неявное приведение типов (например, `big_integer a = 42`, если есть конструктор, который принимает `int`). Чтобы подавить такое поведение, конструктор нужно объявить с модификатором `explicit`.  

Так же существуют деструкторы, освобождающие ресурсы при удалении объекта. Они вызываются когда объект выходит из "зоны видимости":

```C++
~string() {
	free(data);
	// ...
}

void foo() {
	string S;
} // вызовется деструктор S при выходе из функции
```

## Немного про const и указатели

Ключевое слово `const` - неизменяемое. Относится к тому типу, который стоит слева от него. 
```c++
int const PI = 3;
int const* q = &PI; 
// int* q = &PI; - кинет ошибку
*q = 4;
	
int* a; - указатель на int
int const* b; - указатель на константный int
int* const b; - константный указатель на int
int const* const c; - константный указатель на константный int

int a = 42;
int const* p = &a; // так тоже можно, но по этому указателю нельзя будет писать
```

В функцию, которая принимает указатель, нельзя передать указатель на `const`, а наоборот - можно.
Поэтому у аргументов функции полезно не забывать `const`, если функция не меняет принимаемый аргумент.


Константными могут быть не только стандартные типы,
У константных объектов можно вызывать только методы, помеченные `const`:

```c++
struct complex {
	//...
	double real() const {
		&re; // имеет тип double const *, так как метод const
		return re;
	}
}
int main(){
	complex const c(1.1, 2.2);
	c.re = 42; // так нельзя, так как у const структуры все поля const
	c.conjugate(); // так нельзя
	c.real(); // так можно
}
```

## Операторы

[cppreference: operator overloading](https://en.cppreference.com/w/cpp/language/operators)

В С++ есть возможность определять собственные операторы для классов:

```c++
complex operator+(complex a, complex b) {
	return complex(a.re + b.re, a.im + a.im)
}
```
Если вы пишете какой то оператор, то хотя бы один из его элементов должен быть пользовательским типом (нельзя переопределить оператор для `int, int`, но можно, например, для `vector` и `int`).

Еще пример:

```c++
complex operator+=(complex a, complex b) {}
```
Мы такое сделать не можем, так как нужно поменять а, то есть передать его по указателю: `&a += b`, что не очень естественно.
Сделать такое можно, используя ссылки:


|указатель		|	ссылка			|
|---------------|-------------------|
|`int* p = &a;`	|	`int& r = a;`	|
|`*p = 5;`		|	`r = 5;`		|
|`int *pp = p`	|	`int* pr = &r;`	|
|`p->foo`|	`p.foo;`	|
|`p = &b;`		|	`// нельзя перенаправить`	|

Нужно делать так:
```c++
complex& operator+=(complex &a, complex b) { // возвращает ссылку, так что можно присвоить куда-то результат a += b;
	// поэтому можно (a += b) += c;
	return a = a + b;
}
```
Если мы принимаем экземпляр класса и нам не нужно его менять, можно передавать его по константной ссылке, тогда мы избегаем лишних копирований (в отличие от передачи по значению):
```c++
std::ostream& operator<<(std::ostream& os, complex const& a) {
	os << a.real << " + " << a.im << "i";
	return os;
}
```

Если функция принимает `const&`, то в неё можно передавать временный объект (rvalue). Если же она принимает обычную ссылку, то только `lvalue`. \
Аналогично возвращая по ссылке, возвращаем `lvalue`, а по значению `rvalue`.

## Перегрузка операторов внутри класса и снаружи:

Операторы можно перегружать как функции (снаружи класса) и как методы (внутри класса).  Соответственно, у операторов, перегруженных как методы, первым аргументов будет неявный `this`. 

У операторов может срабатывать неявное приведение типов (если есть не `explicit` конструктор). При этом если оператор перегружен как функция, то приводится любой из аргументов, а если как метод, то только правый.

Примеры:

```c++
// как методы:
struct A {
	A (int a); // не explicit конструктор
	A operator-() const; // -(*this)
	A operator-(A const& w) const; // (*this) - w, нельзя вызвать (2-v)
}

// как функции:
A operator-(A const& v);
A operator +(A const& v, A const& w);
// можно вызвать как (2-v), так как есть не explicit конструктор от int
```

Можно делать аргументы оператора другого типа но тогда его нужно перегрузить как функцию, если первый аргумент другого типа.
```c++
Vector operator*(double d, Vector const& v);
```
Некоторые операторы необходимо перегружать только внутри класса: `(type), [], (), ->, ->*, =`. 

Вот так перегружается оператор `()`, заметьте, что можно сделать это для разного количества аргументов:

```c++
bool operator()(double d) const;
void operator()(double a, double b);
```

**Пример инкремента и декремента**:

Чтобы отличать их, постфиксный перегружают с неиспользуемым (*dummy*) параметром типа `int`. Когда вызывается постфиксный оператор, всегда передаётся аргумент, хотя можно и вручную вызвать оператор как функцию и передать любое значение:`a.operator++(2)`.

```c++
struct big_integer {
     big_integer & operator++() { // prefix
         // ...
          return *this;
     }
     big_integer operator++(int) { // postfix
          big_integer tmp(*this);
          ++(*this);
          return tmp;
     }
}
```

**Пример оператора приведения в стиле C:**

```c++
struct String {
	operator bool() const {  // приведение к bool
		return size_ != 0;
	}
	operator char const*() const {   // приведение к char const*
  		if (*this) {
    			return data_;
    		} else {
    			return "";
   	 	}
	} 
	// ...
}
```

Аналогично можно перегружать и касты в стиле C++ (static_cast и др.). 

У операторов приведения, как и у конструкторов, можно указывать модификатор `explicit` и запрещать неявное приведение.

Некоторые ограничения:

- Оператор `->` должен возвращать указатель или объект класса, для которого он переопределён (по ссылке или по значению).
- Операторы `&&`, `||` при перегрузке теряют своё [специальное поведение](https://en.cppreference.com/w/cpp/language/eval_order) и ведут себя как обычные функции.
- Операторы `+=` и подобные лучше перегружать внутри класса, а `+` снаружи через `+=`. Тогда для `+` будет работать приведение типов.
- Операторы сравнений стоит определять одновременно и согласованно: если определили какой-то один из них, принято определить и все остальные так, чтобы они не противоречили друг другу.
- Хорошим тоном считается соблюдать стандартный смысл операторов: не перегружать оператор `+` как умножение.
- Приоритет операторов остаётся стандартным.



## Про указатели и массивы

```c++
int a[10]; // массивы - полноценные типы
int* p = a; // неявно приводится в указатель на тип элемента массива
int b[10] = a; // так не работает, массивы нельзя копировать

void f(int c[10]); // то же самое, что void f(int* c);

int const a[10]; // константный массив константных элементов, не может быть константно что-то одно из них

void f(int const (*p)[10]); // массив по указателю
void f(int (&c)[10]); // массив по ссылке
```

Если функция принимает массив: `void f(int a[10])`, то на самом деле она принимает `int *` и длина игнорируется. 

Но если функция принимает указатель на массив: `void g(int (*p)[10])`, то она принимает указатель на массив длины 10. Все размерности, кроме внешней, должны быть определены, так как являются частью типа элемента.

Важно: ` int *p[10]` - массив указателей, `int (*p)[10]` - указатель на массив длины 10.
