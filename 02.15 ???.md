# Прерывания
Почему программа с вечным циклом не повесит нам весь компьютер? (даже если 1 ядро)
Как ОС работает с устройствами?
1. _Polling_ процессор сам спрашивает устройства, когда надо (пока не используется)
2. _Interrupt_(прерывание) устройство само говорит об изменении, процессор вызывает обработка прерываний.

**Local timer interrupt** - делаем прерывание и ОС может сделать:
1. Продолжить прогу
2. Сохранить состояние первой программы и запустить вторую

Как ОС работает с памятью? Ядро ОС придерживается 2 принципов:
1. _hardware abstraction_ (абстракция железку) (мышка может быть подключена по-разному подключенный но программе все равно)
2. _isolation process_ (изоляция программ) - программа не может повлиять на другие программы (записать в их память)

Как это достигается:
Виртуальная память: номер ячейки к которой обращается программа пересчитывается в физическую память.
Ячейки памяти для программы - виртуальная память.
Процесс преобразования из виртуальной в физическую называется **страничной адресацией**.
## Страничная адресация
![иллюстрация разобщенности памяти процессов](https://lh3.googleusercontent.com/3bjis4tFuLLCGRN9sWvT--CDxBqX90ePws2PA10Z4dAEFjZoQ20rPxe9TD9CwHecKRbxU5wH1a9N)
Адресация реализуется через PageTables
Корень дерева 512 эл-ов по 8 байт: либо "меня нету" (глубина обычно 3)
![страничная адресация](https://lh3.googleusercontent.com/Ab3UYTM8rGYbDegvJgYfX0dwrEud8KBbuFzydkEnW-knxajrZrc0kdqI5hWLzacxnyVn51DxOMwl)
## Механизм процессора
Примерчик 
virtual adress - 0x123456789A
//TODO сделать

Дерево обычно не полное.
Альтернативы:
* хештаблица - плохо взаимодействует с кэшем
* поделим память на куски (сегменты) и сдвиг внутри сегмента.

# Кэш, Branch prediction и другое
Как работает `malloc - free`? ОС выделяет 4Кб и "откусывает" понемногу оттуда. Как "откусывает"?
Уточним модель процессора:
```
for i = 0..n				for i=0..n
	for j=0..n					for j=0..n
		a[i][j] = 0 				a[j][i] = 0
```
У этих 2 кодов большая разница из-за процессорного кэша.
**Кэши** реализованы через хэштаблицы (дискр. размера) ключ - адрес памяти, значение - что лежит
Линии кэша ~64байта : ассоциативность кэша - кол-во buckets.
**Аппаратное предсказане** - подгрузка в кэш заранее
## Конвейер (Pipelining)
Что мы делаем при условных переходах? Выполняем какую-то ветку и если угададли - ок, иначе отменим.
**Branch prediction** - прогнозирование, выполняем одну ветку if, если не угадали - откатываем

> Written with [StackEdit](https://stackedit.io/).