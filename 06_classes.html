<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Классы, абстракция данных - C++ course notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li class="chapter-item expanded "><a href="06_classes.html" class="active"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li class="chapter-item expanded "><a href="07_classes_memory_preprocessor.html"><strong aria-hidden="true">8.</strong> Ещё про классы, выделение памяти, препроцессор</a></li><li class="chapter-item expanded "><a href="08_inheritance.html"><strong aria-hidden="true">9.</strong> Наследование, виртуальные функции</a></li><li class="chapter-item expanded "><a href="09_exceptions.html"><strong aria-hidden="true">10.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li class="chapter-item expanded "><a href="10_memory_allocation.html"><strong aria-hidden="true">11.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации, статические и динамические библиотеки</a></li><li class="chapter-item expanded "><a href="11_templates.html"><strong aria-hidden="true">12.</strong> Шаблоны (templates)</a></li><li class="chapter-item expanded "><a href="12_stl_sfinae.html"><strong aria-hidden="true">13.</strong> Обзор STL, tag-dispatching, SFINAE, пространства имён</a></li><li class="chapter-item expanded "><a href="13_namespaces_using_adl.html"><strong aria-hidden="true">14.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li class="chapter-item expanded "><a href="14_move_rvalue.html"><strong aria-hidden="true">15.</strong> Move-семантика, rvalue-ссылки</a></li><li class="chapter-item expanded "><a href="15_intrusive_containers.html"><strong aria-hidden="true">16.</strong> Интрузивные контейнеры</a></li><li class="chapter-item expanded "><a href="16_smart_pointers.html"><strong aria-hidden="true">17.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li class="chapter-item expanded "><a href="17_perfect_forwarding.html"><strong aria-hidden="true">18.</strong> Perfect forwarding, variadic templates</a></li><li class="chapter-item expanded "><a href="18_decltype_auto_nullptr.html"><strong aria-hidden="true">19.</strong> Decltype, declval, auto, nullptr</a></li><li class="chapter-item expanded "><a href="19_lambdas_type_erasure.html"><strong aria-hidden="true">20.</strong> Анонимные функции, type erasure, std::function</a></li><li class="chapter-item expanded "><a href="20_signals_reetrancy_errors.html"><strong aria-hidden="true">21.</strong> Сигналы, reetrancy, обработки ошибок</a></li><li class="chapter-item expanded "><a href="21_optional_variant_tuple_stringview.html"><strong aria-hidden="true">22.</strong> Optional, variant, tuple, string_view</a></li><li class="chapter-item expanded "><a href="22_constexpr.html"><strong aria-hidden="true">23.</strong> Статическая и динамическая инициализация, constexpr</a></li><li class="chapter-item expanded "><a href="23_multithreading.html"><strong aria-hidden="true">24.</strong> Многопоточность</a></li><li class="chapter-item expanded "><a href="24_qt.html"><strong aria-hidden="true">25.</strong> Qt</a></li><li class="chapter-item expanded "><a href="25_concepts.html"><strong aria-hidden="true">26.</strong> Концепты</a></li><li class="chapter-item expanded "><a href="26_ranges.html"><strong aria-hidden="true">27.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="27_encoding.html"><strong aria-hidden="true">28.</strong> Кодировки</a></li><li class="chapter-item expanded "><a href="28_coroutines.html"><strong aria-hidden="true">29.</strong> Корутины</a></li><li class="chapter-item expanded "><a href="29_modules.html"><strong aria-hidden="true">30.</strong> Модули</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">C++ course notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/lejabque/cpp-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Классы-абстракция-данных" id="Классы-абстракция-данных">Классы, абстракция данных</a></h1>
<ul>
<li><a href="https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp">Пример к лекции</a></li>
<li><a href="https://www.youtube.com/watch?v=4LkTiNYQYBU">Запись лекции №1</a></li>
<li><a href="https://www.youtube.com/watch?v=kjJ-1-VsNRo">Запись лекции №2</a></li>
</ul>
<hr />
<ul>
<li><a href="https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp">Пример к лекции</a></li>
<li><a href="https://www.youtube.com/watch?v=nI6NEPYPRXU">Запись лекции №3</a></li>
<li><a href="https://www.youtube.com/watch?v=8JAp3tG6IrA">Запись лекции №4</a></li>
</ul>
<hr />
<h2><a class="header" href="#Методы" id="Методы">Методы.</a></h2>
<p>Как бы мы с нашими текущими знаниями реализовали структуру для комплексных чисел. Ну, как-то так:</p>
<pre><code class="language-c++">struct complex {
	double re;
	double im;
};
void conjugate(complex* c) {
	c-&gt;im = -c-&gt;im;
}
</code></pre>
<p>Это корректный и хороший C'шный код. Но в C++ позволили писать функции внутри класса. Они, как в Java принимают неявный параметр <code>this</code>, который указатель на «себя». При этом <code>this-&gt;</code> можно опустить везде, где он есть. То есть в C++ код выше был бы написан так:</p>
<pre><code class="language-c++">struct complex {
	double re;
	double im;

	void conjugate() {
		im = -im;     // this-&gt;im = -this-&gt;im;
	}
};
</code></pre>
<p>Компилятор генерирует один и тот же код для программы в C'шном стиле и для программы в C++ стиле.</p>
<p>Также важный момент: <strong>когда вы хотите указать, что <code>this</code> имеет тип <code>const complex* const</code> (а не <code>complex* const</code>), вы пишете <code>const</code> после закрывающей скобки аргументов функции</strong>.</p>
<h2><a class="header" href="#Немного-про-компиляцию-классов" id="Немного-про-компиляцию-классов">Немного про компиляцию классов.</a></h2>
<p>Кстати. Можно написать сначала метод, а потом поля, это ни на что не влияет. Почему? А потому что компилятор откладывает разбор тел функций на конец класса. Но тут же возникает вопрос, почему так не делали с обычными функциями?</p>
<ol>
<li>По историческим причинам. Когда у компьютеров было мало памяти, такие штуки компиляторы вообще никак не могли себе позволить. Поэтому по развитию GCC можно посмотреть,
что сначала он оптимизировал только одну функцию за раз, потом только одну единицу трансляции, а теперь уже у нас есть LTO. Понятно, что если с LTO компилировать что-то огромное, вам нужно будет гигов этак двадцать.</li>
<li>Второй аргумент — хочется прекомпилировать заголовки. <em>Прекомпиляция заголовков</em> — это когда вы проходитесь по заголовку один раз, сохраняете состояние компилятора и потом загружаете его, чтобы не разбирать заголовок снова. И если бы заголовки зависели от того, что после них, такое было бы невозможно.</li>
</ol>
<p>Кстати, это поясняет, почему методы можно определять сразу внутри класса. Ранее было упомянуто, что <strong>класс в середине его определения всё ещё считается incomplete type</strong>. Кажется, это должно запретить нам использовать класс в определении его методов. Но методы разбираются после класса, потому нет.</p>
<p>А вообще обычно пишут объявления функций в <em>class.h</em>, а определения в <em>class.cpp</em>. Если определение функции сделано внутри класса, то она неявно помечается как <code>inline</code>, но мы не всегда хотим этого (дольше время компиляции из-за зависимостей).</p>
<pre><code class="language-c++">// struct.h:
struct complex {
	void conjugate();
private:
	double re;
	double im;
};
</code></pre>
<pre><code class="language-c++">// struct.cpp:
void complex::conjugate() {
	im = -im;
}
</code></pre>
<h2><a class="header" href="#Права-доступа" id="Права-доступа">Права доступа.</a></h2>
<p>А в чём глобально разница между внешней функцией и методом? Ну, во внешнюю функцию можно передать <code>nullptr</code>, но это легко исправляется ссылками (см. дальше), они тоже не бывают <code>nullptr</code>. А вот что действительно важно — права доступа. Как и в Java, вы можете показывать и скрывать поля и методы класса ключевыми словами <code>public</code> и <code>private</code> соответственно: к <code>public</code> полям и методам могут обращаться все вообще, а к <code>private</code> — только методы того же класса. Ещё есть модификатор <code>protected</code>, он тоже как в Java, и о нём <a href="./08_inheritance.html#protected">попозже</a>. Итого такой код:</p>
<pre><code class="language-c++">struct complex {
private:
	double re;
	double im;

public:
	void conjugate() {
		im = -im;
	}
};
</code></pre>
<p>Скомпилируется, а если сделать <code>conjugate</code> внешней функцией — то нет.</p>
<h3><a class="header" href="#Что-должно-быть-private-а-что-public-Инварианты-класса" id="Что-должно-быть-private-а-что-public-Инварианты-класса">Что должно быть <code>private</code>, а что <code>public</code>? Инварианты класса.</a></h3>
<p>На кой нам вообще <code>private</code>? А вот есть у вас двоичное дерево:</p>
<pre><code class="language-c++">struct node {
	node* left;
	node* right;
	node* parent;
	int value;
};
</code></pre>
<p>Но двоичное дерево — это же не только вот это, а ещё и набор условий (из серии <code>this-&gt;right-&gt;parent == this</code> или что все значения слева меньше текущего). Если любой лох может изменить поля любым образом, то ситуация будет вырисовываться довольно грустной. Поэтому у нас и есть <code>private</code>, который не позволяет всяким лохам это делать. Но на самом деле не только для этого, об этом чуть позже. А пока промежуточный вывод: <strong>то, что может испортить инвариант класса, должно быть <code>private</code>.</strong></p>
<p>Условия, истинность которых считается эквивалентной корректности класса называются <em>инвариантом класса</em>. Инварианты класса, кстати, не всегда очевидны. Вот есть у вас дробь:</p>
<pre><code class="language-c++">struct rational {
	int32_t num;
	int32_t denom;
};
</code></pre>
<p>Какой у неё инвариант? А вот есть два варианта:</p>
<ul>
<li><code>denom != 0</code>.</li>
<li><code>denom &gt; 0 &amp;&amp; gcd(num, denom) == 1</code>.</li>
</ul>
<p>Самое грустное, что оба варианта верны — в зависимости от выбора изменятся реализации функций. Например, в случае <code>denom != 0</code> будет сложение попроще, а сравнение посложнее. И, что грустно, зачастую понять инвариант вы можете только по коду (а код ещё и ошибки может содержать).</p>
<p>Поэтому <strong>полезно бывает в отладочных целях писать метод <code>void check_invariant() const</code>, после чего на тестировании вставлять его до и после каждого публичного метода</strong>. Была даже история о том, как чуваки взяли много проектов по красно-чёрным деревьям из GitHub, повставляли в них проверку инварианта и нашли кучу ошибок. А единственные проекты, где не нашли, уже содержали проверку. А дело в том, что красно-чёрное дерево может не сломаться полностью, если допустить в нём ошибку — вы можете ошибиться так, что оно всё ещё будет деревом поиска, всё ещё сможет добавлять и удалять элементы, но оно будет работать медленнее, чем должно теоретически, потому что будет неправильно покрашено. И в этом случае вам проверка инварианта и поможет.</p>
<p>Но есть грустный момент: <strong>иногда инвариант проверить невозможно</strong>. Скажем, мы пишем контейнер, у него должны быть <code>capacity</code> выделенных байт, первые <code>size</code> из которых проинициализированы. Ну, фиг мы это проверим. Мы можем теоретически написать какой-то умный аллокатор, который имеет проверку первого, а разломав компилятор сможем проверить второе. Но это никто делать не будет, увы:(</p>
<p>Теперь вернёмся к основному вопросу (для чего <code>private</code>) и выделим ещё один аргумент. Можем ли мы делать в классе <code>complex</code> поля доступными? Мы можем хранить числа в полярной форме, а вещественную и мнимую часть считать, но это кринж. Есть аргумент получше: в компилятор GCC, например, имеет встроенные комплексные числа через ключевое слово <code>__complex__</code>. И использует в реализации <code>std::complex</code> он именно их, а не два <code>double</code>'а. Поэтому тут уже сто́ит сделать их <strong><code>private</code> — мы даём себе простор для модификации</strong>. </p>
<p>Проверять инварианты можно ассертами (<code>assert</code>), про них в отдельном файле. Будет.</p>
<!--
Не стоит злоупотреблять ими, потому что это дорого, лучше делать это при дебаге и тестировании.

Это противоречит тому, что рассказывали нам. Точнее, "Не стоит злоупотреблять ими". Нам наоборот было сказано, если ваш код не замедляется от assert'ов вдвое, в нём мало assert'ов.
-->
<h2><a class="header" href="#Конструкторы" id="Конструкторы">Конструкторы.</a></h2>
<p>Все его публичные методы класса предполагают, что инвариант выполнен до вызова. Поэтому когда мы создаём новый объект, хотелось бы, чтобы он выполнялся с самого начала. Для этого есть специальные методы — <em>конструкторы</em>:</p>
<!--
```c++
struct complex {
	complex(re, im) {
		this.re = re;
		this.im = im;
	}
	complex() {		// конструктор по умолчанию
		this.re = 0;
		this.im = 0;
	}
	void conjugate() {	
		im = -im;
	}
private:
	double re;
	double im;
};

void f(complex);
int main() {
	complex c; // вызывается конструктор по умолчанию
	complex d(1., 2.);
	f(complex(1., 2.));
}
```

Это не очень показательный пример (в смысле, как первый пример) из-за того, что никаких инвариантов тут нет. Поэтому я заменю его на класс с инвариантами.
-->
<pre><code class="language-c++">struct string {
private:
	char* data;
	size_t size;
	size_t capacity;
	/* Инвариант:
	 * 1) `capacity` байт выделено в `data`.
	 * 2) `size &lt;= capacity` из них заполнено.
	 * 3) `data` — корректный указатель либо `nullptr` (если `capacity == 0`).
	 */

public:
	// Вот это конструктор.
	// Он обеспечивает исполнение инварианта в начале.
	string() {
		data = nullptr;
		size = capacity = 0;
	}
};
</code></pre>
<p>Конструктор без аргументов называется <em>конструктором по умолчанию</em>. <strong>Конструкторы вызываются компилятором (и только им) всегда, когда вы создаёте объект.</strong> Вы можете явно указать, какой конструктор вызвать вот так:</p>
<pre><code class="language-c++">struct complex {
private:
	double re;
	double im;

public:
	complex() {
		re = im = 0;
	}
	complex(double re, double im) {
		// Так называть параметры можно. Можно и ещё круче, но в разделе про списки инициализации.
		this-&gt;re = re;
		this-&gt;im = im;
	}
};
void main() {
	complex a1;
	complex a2();
	complex a3 = complex();
	complex a4{};

	complex b1(1, 2);
	complex b2 = complex(1, 2);
	complex b3{1, 2};
}
</code></pre>
<p>Первые 4 определения равносильны. Как и последние 3. Кстати, выражение вида <code>complex(1, 2)</code> может как оно есть в функцию передаваться — тогда создастся временный объект и передастся. Этот временный объект, кстати, является rvalue.</p>
<p>Теперь давайте внимательнее посмотрим на <code>a3</code> и <code>b2</code>. Там мы вроде как сначала создаём объект, а потом присваиваем его куда-то. Так вот да, но нет. У компилятора есть такое понятие как избегание копирования: если правый аргумент — rvalue, то он ничего не копирует, а просто вызывает конструктор на <code>a3</code>/<code>b2</code>.</p>
<h3><a class="header" href="#Неявные-конструкторы" id="Неявные-конструкторы">Неявные конструкторы.</a></h3>
<pre><code class="language-c++">struct complex
{
private:
	double re;
	double im;

public:
	complex() { /*...*/ }
	complex(double re, double im) { /*...*/ }
	complex(double re) {
		this-&gt;re = re;
		this-&gt;im = 0;
	}
};

void foo(complex) { /*...*/ }

void main() {
	complex a = 42;
	foo(42.0);
}
</code></pre>
<p>Такой код неявно преобразует <code>42.0</code> в <code>complex</code> и вызовет от него функцию. В случае с <code>complex</code> это оправдано, но если у вас контейнер инициализируется количеством элементов, то так неявно делать странно. Поэтому если вы такого не хотите, напишите перед конструктором слово <code>explicit</code>: тогда вы запретите ещё <code>complex a = 42</code>, можно будет только <code>complex a(42)</code>.</p>
<h2><a class="header" href="#Деструкторы" id="Деструкторы">Деструкторы.</a></h2>
<p>Помните <code>struct string</code>? Там же нам надо освободить данные при удалении объекта. А вот для конструкторов есть парные функции — деструкторы, которые автоматически вызываются, когда объект уничтожается:</p>
<pre><code class="language-c++">struct string {
private:
	char* data;
	size_t size;
	size_t capacity;

public:
	// ...
	~string() {
		free(data);
	}
}

void foo() {
	string s;
} // Вызовется деструктор `s` при выходе из функции.
</code></pre>
<p>Когда происходит уничтожение?</p>
<ul>
<li>Обычные переменные умирают когда наступает фигурная скобка блока, где вы объявили переменную. Совершенно не важно, каким образом вы покидаете блок, <code>return</code> у вас, <code>break</code>, <code>throw</code> или даже <code>goto</code>. Только <strong>если <code>longjmp</code> вы используете, тогда вы не знаете, вызовутся деструкторы или нет</strong>. Мораль — <strong>не используйте <code>longjmp</code></strong>, потому что он всё равно корректно работает только вверх по стеку, а вверх по стеку можно заменить на <code>throw</code>-<code>catch</code>.</li>
<li>Временные объекты умирают по концу выражения, где они созданы.</li>
<li>Для глобальных переменных конструктор вызывается до main, а деструктор — после него.</li>
<li>Для полей класса конструктор вызывается до конструктора этого класса, а деструктор — после его деструктора.</li>
</ul>
<p>При этом <strong>деструкторы объектов одного блока вызываются в порядке, обратном порядку конструкторов</strong>.</p>
<!--
## Немного про const и указатели

Вот это всё не тут, а там же, где макросы (в компиляции).
Что тут, что там это выглядит не очень, но тут как-то более не к месту.
Но вообще в обсуждении `this` выше хорошо бы уже знать про const указатели, то есть раньше, чем тут.
-->
<h2><a class="header" href="#Операторы" id="Операторы">Операторы.</a></h2>
<p>Для класса <code>complex</code> очень хочется иметь арифметические операции, и не хочется как в какой-то помойной Java называть их <code>add</code> или <code>mul</code>. Чтобы так можно было, в C++ есть ключевое слово <code>operator</code>. Они пишутся как обычные функции, только называются как <code>operator+</code>, <code>operator-</code> и тому подобное.</p>
<p>Также как и обычные функции операторы могут быть внешними или внутренними (правда, не все):</p>
<pre><code class="language-c++">complex operator+(complex a, complex b) {
	return complex(a.real() + b.real(), a.imag() + b.imag());
}
</code></pre>
<p>Или</p>
<pre><code class="language-c++">class complex {
	// ...
	complex operator+(complex other) const {
		return complex(re + other.re, im + other.im);
	}
};
</code></pre>
<p>Работают они как совершенно обычные функции, поэтому сказать непосредственно про них можно немногое.</p>
<p>Если вы <strong>пишете оператор, то хотя бы один из его элементов должен быть пользовательским типом</strong> (нельзя переопределить оператор для <code>int, int</code>, но можно, например, для <code>std::vector&lt;int&gt;</code> и <code>int</code>).</p>
<p>Если есть желание почитать поподробнее, то почитайте <!-- К чему тут cppreference вообще? К дополнительному чтению? --><a href="https://en.cppreference.com/w/cpp/language/operators">cppreference</a>.</p>
<h3><a class="header" href="#Оператор--" id="Оператор--">Оператор <code>-&gt;</code>.</a></h3>
<p>Особо нужно посмотреть на <code>-&gt;</code>. Его обычно перегружают, когда пишут какие-то свои указатели. И выглядят это вот так:</p>
<pre><code class="language-c++">struct my_ptr {
	// Что-то.
	complex* operator-&gt;() {
		return /* Что-то */;
	}
};
</code></pre>
<p>Можно было бы подумать, что <code>-&gt;</code> — это бинарный оператор (у него есть то, у чего мы берём поле/метод и имя этого самого поля/метода). Но правая штука — это не выражение. В C++ нет рефлексии. Поэтому <strong><code>-&gt;</code> — это унарный оператор</strong>. Если вы возьмёте <code>my_ptr x</code> и вызовете <code>x-&gt;im</code>, то это преобразуется в <code>(x.operator-&gt;())-&gt;im</code>. Поскольку <code>operator-&gt;</code> возвращает <code>complex*</code>, к нему нормально можно применить <code>-&gt;</code>. А ещё можно из оператора <code>-&gt;</code> вернуть что-то другое, к чему применим оператор <code>-&gt;</code>. И тогда они будут вызываться по цепочке, пока не дойдём до обычного указателя.</p>
<h2><a class="header" href="#Ссылки" id="Ссылки">Ссылки.</a></h2>
<p>Операторы подводят нас к вопросу, что делать с <code>+=</code> и подобными? Точнее, как перегрузить его вовне класса? Совершенно точно не так:</p>
<pre><code class="language-c++">void operator+=(complex a, complex b) {
	a.set_real(a.real() + b.real());
	a.set_imag(a.imag() + b.imag());
}
</code></pre>
<p>Есть идеологически неверное, но всё же рабочее решение:</p>
<pre><code class="language-c++">void operator+=(complex* a, complex b) {
	a-&gt;set_real(a-&gt;real() + b.real());
	a-&gt;set_imag(a-&gt;imag() + b.imag());
}
int main() {
	complex x, y;
	&amp;x += y;
}
</code></pre>
<p>Сделать такое можно, используя ссылки. О них можно думать, как о константных указателях со специальным синтаксисом:</p>
<pre><code class="language-c++">T a;                         T a;

T* const ptr = &amp;a;           T&amp; ref = a;
foo(*ptr);                   foo(ref);
ptr-&gt;bar;                    ref.bar;
</code></pre>
<p>Ещё <strong>ссылки нельзя перенаправлять на другие объекты</strong> (раз уж это неизменяемый указатель), и <strong>ссылка не бывает <code>nullptr</code></strong>, (ну, правда, зачем вам константный указатель на <code>nullptr</code>).</p>
<p>И теперь мы можем увидеть, как делать нужно:</p>
<pre><code class="language-c++">complex&amp; operator+=(complex &amp;a, complex b) {
	return a = a + b;
}
</code></pre>
<p><strong>Во всех присваиваниях (хоть <code>=</code>, хоть <code>@=</code>) возвращаемое значение — это левый аргумент</strong>, чтобы было консистентно со строенными типами.</p>
<p>А ещё если мы принимаем экземпляр класса и нам не нужно его менять, можно передавать его по константной ссылке, тогда мы избегаем лишних копирований:</p>
<pre><code class="language-c++">//       Вот сюда смотреть:     vvvvv        v
complex&amp; operator+=(complex &amp;a, const complex&amp; b) {
// Или так, смысл такой же:     complex const&amp; b
	return a = a + b;
}
</code></pre>
<p>Если функция принимает <code>const&amp;</code>, то в неё можно передавать временный объект (rvalue). Если же она принимает обычную ссылку, то только lvalue. <br />
Также возвращая по ссылке, возвращаем lvalue, а по значению — rvalue.</p>
<h2><a class="header" href="#Немного-best-practices-until-c23" id="Немного-best-practices-until-c23">Немного best practices (until C++23).</a></h2>
<p>Сто́ит посмотреть, что делать, если вы реализуете свою строку. Вам хочется оператор <code>[]</code>. По-хорошему он выглядит так:</p>
<pre><code class="language-c++">struct string {
private:
	char* data;
	size_t size;
	size_t capacity;
public:
	// ...
	char&amp; operator[](size_t index) {
		return data[index];
	}
};
</code></pre>
<p>Но на самом деле вы хотите вызывать этот оператор на неизменяемой строке тоже, а от неё указанный оператор не вызывается (нельзя кастовать <code>const string* const this</code> в просто <code>string* const this</code>). Поэтому вам придётся написать ещё один вариант этого же оператора:</p>
<pre><code class="language-c++">	const char&amp; operator[](size_t index) const {
		return data[index];
	}
</code></pre>
<p>Почему <code>const char&amp;</code>, а не <code>char</code>? Чтобы от константности строки не зависело, lvalue у вас или rvalue. А <strong><code>const char&amp;</code> — это lvalue, у него есть адрес</strong>.</p>
<h2><a class="header" href="#Продолжение-темы-операторов" id="Продолжение-темы-операторов">Продолжение темы операторов.</a></h2>
<h3><a class="header" href="#Перегрузка-операторов-внутри-класса-и-снаружи" id="Перегрузка-операторов-внутри-класса-и-снаружи">Перегрузка операторов внутри класса и снаружи.</a></h3>
<p>Операторы можно перегружать как функции (снаружи класса) и как методы (внутри класса). Соответственно, у операторов, перегруженных как методы, первым аргументом будет неявный <code>this</code>. </p>
<p>У операторов может срабатывать неявное приведение типов (если есть не <code>explicit</code> конструктор). При этом если оператор перегружен как функция, то приводится любой из аргументов, а если как метод, то все кроме первого:</p>
<pre><code class="language-c++">struct complex {
	// ...
	/* implicit */ complex(double re) { /*...*/ }

	complex operator-(const complex&amp; other) const {
	return complex(re - other.re, im - other.im);
}
};
complex operator+(const complex&amp; a, const complex&amp; b) {
	return complex(a.real() + b.real(), a.imag() + b.imag());
}
void main() {
	complex a;
	a + 42; // ok, operator+(a, 42).
	a - 42; // ok, a.operator+(42).
	42 + a; // ok, operator+(42, a).
	42 - a; // Error, `42.operator-(a)` у int нет методов.
}
</code></pre>
<p>Мораль: <strong>перегружайте операторы внешне</strong>. Если первый аргумент — это ваш тип, то проблема уже описана выше, а если не ваi, то внутренне его вообще не перегрузить.</p>
<pre><code class="language-c++">Vector operator*(double d, Vector const&amp; v);
</code></pre>
<p>Некоторые операторы необходимо перегружать только внутри класса: <code>(type)</code>, <code>[]</code>, <code>()</code>, <code>-&gt;</code>, <code>-&gt;*</code>, <code>=</code>. С ними не возникает проблем с конверсией первого аргумента (если вы хотите неявно преобразовывать аргумент этих операторов куда-то, что-то вы делаете не так). Но с присваиванием есть еще одна проблема.</p>
<!--
Вот так перегружается оператор `()`, заметьте, что можно сделать это для разного количества аргументов:

```c++
bool operator()(double d) const;
void operator()(double a, double b);
```

Какая-то не самая полезная информация, как мне кажется. РАз уж тут есть ссылка на cppreference.
-->
<pre><code class="language-c++">struct complex {
	// ...
	complex&amp; operator=(const complex&amp; other) { /*...*/ }
};

complex foo() { /*...*/ }

int main() {
	foo() = complex(1, 2);
}
</code></pre>
<p>Бредятина какая-то. А дело в том, что никто не знает, что <code>operator=</code> должен принимать не временный объект первым аргументом. Если бы можно было перегрузить его внешне, то такой проблемы бы не было (там было бы явно указано <code>complex&amp; left</code>). И эта проблема в C++11 правится так:</p>
<pre><code class="language-c++">struct complex {
	// ...
	complex&amp; operator=(const complex&amp; other) &amp; { /*...*/ }
	//          Вот сюда смотреть:           ^
};
</code></pre>
<h3><a class="header" href="#increment-и-decrement" id="increment-и-decrement">Increment и decrement.</a></h3>
<p>Кстати, надо сразу рассказать, как перегружать <code>++</code> и <code>--</code>, ведь у вас два таких. Тут синтаксический костыль — <strong>постфиксные операторы принимают второй аргумент <code>int</code>, который не используется</strong>. Неиспользуемый — <em>dummy</em>. Когда вызывается постфиксный оператор, всегда передаётся аргумент, хотя можно и вручную вызвать оператор как функцию и передать любое значение: <code>a.operator++(2)</code>.</p>
<pre><code class="language-c++">struct big_integer {
     big_integer&amp; operator++() { // prefix
        // ...
        return *this;
     }
     big_integer operator++(int) { // postfix
        big_integer tmp(*this);
        ++(*this);
        return tmp;
     }
};
</code></pre>
<h3><a class="header" href="#c-style-cast" id="c-style-cast">C-style cast.</a></h3>
<pre><code class="language-c++">struct string {
	// ...

	// Приведение к `bool`.
	operator bool() const {
		return size_ != 0;
	}

	// Приведение к `char const*`.
	operator char const*() const {
  		if (*this) { // Тут используется приведение к `bool`.
    		return data_;
    	} else {
    		return &quot;&quot;;
   	 	}
	} 
}
</code></pre>
<!--
Аналогично можно перегружать и касты в стиле C++ (static_cast и др.).

Простите, что? Как?
-->
<p>У операторов приведения, как и у конструкторов, можно указывать модификатор <code>explicit</code> и запрещать неявное приведение.</p>
<h3><a class="header" href="#Некоторые-ограничения" id="Некоторые-ограничения">Некоторые ограничения:</a></h3>
<!--
- Оператор `->` должен возвращать указатель или объект класса, для которого он переопределён (по ссылке или по значению).

Это в отдельном разделе.
-->
<ul>
<li>Операторы <code>&amp;&amp;</code>, <code>||</code> при перегрузке теряют своё <a href="https://en.cppreference.com/w/cpp/language/eval_order">специальное поведение</a> и ведут себя как обычные функции.</li>
<li>Операторы <code>+=</code> и подобные лучше перегружать внутри класса, а <code>+</code> снаружи через <code>+=</code>. Тогда для <code>+</code> будет работать приведение типов. При этом любое присваивание выглядит так: <code>T&amp; T::operator@=(const T&amp; other) &amp;</code>;</li>
<li>Операторы сравнений стоит определять одновременно и согласованно: если определили какой-то один из них, принято определить и все остальные так, чтобы они не противоречили друг другу. При этом принято, чтобы сингнатуры у них были одинаковые. Так, либо ни одна, либо все должны быть <code>noexcept</code>.</li>
<li>Хорошим тоном считается соблюдать стандартный смысл операторов: не перегружать оператор <code>+</code> как умножение.</li>
<li>Приоритет операторов остаётся стандартным.</li>
<li>Перегружать операторов, которых нет изначально, нельзя.</li>
<li>Перегружать <code>::</code>, <code>?:</code>, <code>.</code> и <code>.*</code> нельзя.</li>
</ul>
<!--
## Про указатели и массивы

Этот тут какого чёрта вообще делало?
-->
<h2><a class="header" href="#special-function-member-функции" id="special-function-member-функции">Special function member функции.</a></h2>
<h3><a class="header" href="#Копирование-и-присваивание" id="Копирование-и-присваивание">Копирование и присваивание.</a></h3>
<p>Давайте посмотрим на такой код:</p>
<pre><code class="language-c++">int main() {
    string s = &quot;Hello&quot;;
    string t = s;
}
</code></pre>
<p>Wait a second, мы же не написали как строки копировать. Почему компилятор их копирует? И самое главное, как? А вот покомпонентно. Если покомпонентно нас не утраивает (а в данном случае не устраивает, потому что мы два раза освободим скопированный указатель), надо написать свой конструктор копирования. И в пару ему оператор присваивания, который легко пишется из предыдущего:</p>
<pre><code class="language-c++">string&amp; operator=(string other) &amp; {
//Внимание!       ^^^ копия ^^^
    std::swap(other, *this); // Как работает std::swap, оставим за кадром. Пока что.
    return *this;
}
</code></pre>
<p>Это называется <em>swap-trick</em>, и его мы ещё <a href="./09_exceptions.html#swap-trick">обсудим в контексте исключений</a>. Кстати, оператор присваивания также генерируется компилятором. Также покомпонентный. То, что компилятор генерирует сам, называется <em>специальными функциями-членами класса</em>. Это:</p>
<table><thead><tr><th align="center">Метод</th><th align="center">Когда генерируется</th><th align="center">Что делает по умолчанию</th></tr></thead><tbody>
<tr><td align="center">Конструктор по умолчанию</td><td align="center">Не написан ни один конструктор</td><td align="center">Конструирует по умолчанию все поля</td></tr>
<tr><td align="center">Деструктор</td><td align="center">Не написан деструктор</td><td align="center">Удаляет все поля</td></tr>
<tr><td align="center">Копирующий конструктор</td><td align="center">Не написан копирующий конструктор</td><td align="center">Инициализирует объект копиями всех полей</td></tr>
<tr><td align="center">Оператор присваивания</td><td align="center">Не написан оператор присваивания</td><td align="center">Присваивает всем полям поля того, что присваиваем</td></tr>
</tbody></table>
<h3><a class="header" href="#-default-и--delete" id="-default-и--delete"><code>= default;</code> и <code>= delete;</code>.</a></h3>
<p>Есть штуки, которые либо не скопировать. Сетевое соединение, например. Тогда, чтобы явно пометить, что копировать и присваивать класс нельзя, есть вот такой синтаксис:</p>
<pre><code class="language-c++">my_string&amp; operator=(my_string const&amp;) = delete;
my_string(my_string const&amp;) = delete;
</code></pre>
<p>Так можно запретить любую специальную функцию-член класса. И можно явно указать, что сгенерированный по-умолчанию вам подходит. Например, можно явно создать конструктор по умолчанию, если есть уже какой-то другой и из-за него по умолчанию не сгенерируется.</p>
<pre><code class="language-c++">my_string() = default;
</code></pre>
<p>Так ещё может быть полезно писать, чтобы явно документировать, что функция-член класса вам подходит.</p>
<p>Отличается ли чем-то пустой конструктор от дефолтного? А вот да: <strong>пустой конструктор — это <em>user-defined</em></strong> конструктор. Класс с <strong><em>default</em> конструктором — это  <em>trivially constructible</em></strong>. Для них, например, при создании массива не будут вызываться конструкторы.</p>
<p>Если <code>= default</code> писать в определении в какой-нибудь из единиц трансляции, то другие единицы трансляции во время компиляции не будут знать, что класс <em>trivially constructible</em>.</p>
<h2><a class="header" href="#Списки-инициализации" id="Списки-инициализации">Списки инициализации.</a></h2>
<p>Посмотрим вот на что:</p>
<pre><code class="language-c++">struct string {
    // ...
    string() {
        data = strdup(&quot;&quot;);
        size = capacity = 0;
    }
    string(const char* str) { /*...*/ }
    string(const string&amp; other) { /*...*/ }
    string&amp; operator=(const string&amp; other) &amp; { /*...*/ }
    ~string() {
        free(data);
    }
};
struct person {
    string name;
    string surname;
    person() {
        name = &quot;Eric&quot;;
        surname = &quot;Adams&quot;;
    }
};
int main() {
    person p;
}
</code></pre>
<p>Сколько тут будет аллокаций и деаллокаций памяти? А вот 6. Почему? Давайте аккуратно считать.</p>
<p>0. Мы вызываем конструктор класса person.<br />
2. У двух <code>string</code>'ов вызывается конструктор по умолчанию, каждый из которых выделает память (<code>strdup</code>).<br />
4. Неявно вызываются конструкторы <code>string(&quot;Eric&quot;)</code> и <code>string(&quot;Adams&quot;)</code>, которые тоже выделяют память.<br />
6. Два раза выполняется присваивание, которые выделяют и освобождают память.</p>
<p>Можно ли это оптимизировать? Компилятор теоретически может, конечно, но срабатывают эти оптимизации настолько редко и ненадёжно, что надеяться на них нельзя. Как это оптимизировать программисту? При помощи списков инициализации — хочется указать, что мы сразу вызываем конструктор <code>name</code> и <code>surname</code> от строки, а не по-умолчанию. Это делается при помощи такого синтаксиса:</p>
<pre><code class="language-c++">struct person {
    string name;
    string surname;
    person() : name(&quot;Eric&quot;), surname(&quot;Adams&quot;)
    {}
};
int main() {
    person p;
}
</code></pre>
<p>И тут аллокаций будет 2, как и ожидается. Кстати, если есть объект, который не имеет конструктора по-умолчанию, то без списков инициализации просто невозможно.</p>
<p>Что сто́ит сказать про это? А то что списки инициализации — это не только (и не столько) оптимизация, сколько по смыслу не то же самое, что мы написали сначала. Только для встроенных типов разницы особой нет, но вообще списки инициализации обычно и для них используются, потому что это гораздо более идиоматический код. А ещё сто́ит сказать, что <strong>если в списке инициализации не написано ничего для некоторого поля, то для него используется конструктор по-умолчанию</strong>.</p>
<p>Поскольку деструктор у нас один, разрушаются поля в определённом порядке. А в конструкторе вы, вроде как, можете в разном написать. Так вот нет, потому что <strong>список инициализации всегда вызывает конструкторы в порядке расположения полей структуры</strong>. И лучше бы вам писать список инициализации в этом же порядке, чтобы не путать людей. И, кстати, в инициализации некоторого поля можно использовать то, что было создано ранее. Аналогично с использованием <code>this</code> в списке инициализации — можно, но осторожно, надо понимать, что конструктор <code>this</code> ещё недовыполнился. Аналогично осторожным быть надо в деструкторе по той же причине. Подробнее про порядок инициализации <a href="https://en.cppreference.com/w/cpp/language/constructor">здесь</a>.</p>
<p>Кроме того, конструкторы можно делегировать:</p>
<pre><code class="language-c++">person() : person(&quot;Ivan&quot;, &quot;Sorokin&quot;) {}
</code></pre>
<p>Сначала вызовется конструктор от двух <code>char const*</code>, а затем будет выполнять тело текущего конструктора.</p>
<h2><a class="header" href="#Ещё-немного-best-practices" id="Ещё-немного-best-practices">Ещё немного best practices.</a></h2>
<p>Давайте вот ещё на что посмотрим. Наш класс <code>string</code> вызывает в конструкторе аллокацию памяти. Так вот, вообще считается, что это кринж, так делать не надо.</p>
<p>А ещё при присваивании C-строки в нашу строку мы сначала конструируем, а потом присваиваем, давайте вместо этого явно пропишем <code>operator=(const char*)</code>, и будет также меньше аллокаций.</p>
<h2><a class="header" href="#new-и-delete" id="new-и-delete"><code>new</code> и <code>delete</code>.</a></h2>
<p>Итак, мы обсудили, когда вызываются конструкторы и деструкторы. А если вы хотите вызывать их в произвольный момент, конструируя объект тогда, когда захочет пользователь? Тогда есть <code>new</code> и <code>delete</code>. Вы пишете <code>Type* p = new Type(...);</code> — это конструирует вам объект в куче, а <code>delete p;</code> разрушает вам этот объект.</p>
<p>Как это работает? В C есть <code>malloc</code> и <code>free</code>, они выделяют память на стеке в тот момент, когда вы её попросите (опять же, в рандомный момент). Выделение на куче, кстати, немного дороже, чем на стеке.</p>
<pre><code class="language-c++">    void* p = malloc(42); // Выделяет 42 байта.
    free(p); // Чистит память, выделенную ранее.
    free(p); // Освобождать то, что уже освободил, нельзя.

    free(nullptr); // Так можно, ничего не произойдет.
</code></pre>
<p>Двойной <code>free</code> вызывает UB или даже <a href="https://awakened1712.github.io/hacking/hacking-whatsapp-gif-rce/">уязвимость</a>.</p>
<p>Разница между ними и <code>new</code>—<code>delete</code> (упрощённо) в том, что второй вариант гарантирует вызов конструкторов и деструкторов. И в большинстве <code>new</code> просто является комбинацией из <code>malloc</code>'а и <a href="https://en.cppreference.com/w/cpp/language/new#Placement_new">вызова конструктора на выделенной памяти</a>. Аналогично <code>delete</code> вызывает деструктор и <code>free</code>.</p>
<p>Ещё есть <code>new[]</code> и <code>delete[]</code> — менеджмент массива. На всём массиве вызываются конструкторы по умолчанию:</p>
<pre><code class="language-c++">person* p = new person(&quot;Ivan&quot;, &quot;Sorokin&quot;);
delete p;

person* p = new person[10];
delete[] p;
</code></pre>
<p>При этом ни в коем случае <strong>нельзя освобождать объект другим способом, нежели он был выделен</strong>. Это в любом случае undefined behaviour, даже если, вроде как, не должно:</p>
<pre><code class="language-c++">person* p = new person(&quot;Ivan&quot;, &quot;Sorokin&quot;);

p-&gt;~person();
free(p);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="05_compilation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="07_classes_memory_preprocessor.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="05_compilation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="07_classes_memory_preprocessor.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
